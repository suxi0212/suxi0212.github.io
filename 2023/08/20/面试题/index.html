<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>web前端面试题 | 苏惜的小世界</title><meta name="author" content="苏惜"><meta name="copyright" content="苏惜"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="web前端面试题"><meta name="application-name" content="web前端面试题"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="web前端面试题"><meta property="og:url" content="http://example.com/2023/08/20/%E9%9D%A2%E8%AF%95%E9%A2%98/index.html"><meta property="og:site_name" content="苏惜的小世界"><meta property="og:description" content="JavaScript普通函数与箭头函数的区别? 箭头函数没有原型对象prototype 箭头函数是匿名函数不能作为构造函数不能被new 箭头函数不能当作Generator函数，不能使用yeild关键字。 箭头函数不绑定arguments，取而代之用…rest参数解决 箭头函数不绑定this，会捕获他"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://example.com/img/userimg.jpg"><meta property="article:author" content="苏惜"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/img/userimg.jpg"><meta name="description" content="JavaScript普通函数与箭头函数的区别? 箭头函数没有原型对象prototype 箭头函数是匿名函数不能作为构造函数不能被new 箭头函数不能当作Generator函数，不能使用yeild关键字。 箭头函数不绑定arguments，取而代之用…rest参数解决 箭头函数不绑定this，会捕获他"><link rel="shortcut icon" href="/img/userimg.jpg"><link rel="canonical" href="http://example.com/2023/08/20/%E9%9D%A2%E8%AF%95%E9%A2%98/"><link rel="preconnect" href="//npm.elemecdn.com"/><link rel="preconnect" href="//npm.onmicrosoft.cn"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":null},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 苏惜","link":"链接: ","source":"来源: 苏惜的小世界","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#3b70fc","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '苏惜的小世界',
  title: 'web前端面试题',
  postAI: '',
  pageFillDescription: 'JavaScript, 普通函数与箭头函数的区别?, Generator函数, 什么是Promise?, promise的使用场景?, 什么是回调地狱？, 对this的理解？, 什么是事件循环, 事件循环机制的组成, 事件轮询的机制 也叫事件循环的机制（eventLoop）, for in和for of区别？, new一个对象的过程？, 什么是闭包？, 什么是堆内存和栈内存？, 节流和防抖？, 哪些数组方法可以改变原数组？, 虚拟DOM, 谈一谈垃圾回收机制?, less 和 sass 的区别 ?, CSS预处理器是什么？, 纯函数, 浏览器的同源策略机制?, token一般存放在哪里?为什么不存放在cookie内?, token是什么, 如何实现一条0.5像素的线, 构造函数, asyncx2Fawait, transform的属性, IE盒模型和标准盒模型, css实现三角形, axios, JQ中$()符, 普通函数和构造函数的区别, 浮动与定位, 递归函数, label标签, ajax执行步骤, 最后一个元素选中css, 统计字符串中出现最多的字母, 自执行函数, 数组 对象区别, 元素绑定事件, 数组拉平, postion属性的值有哪些, 静态方法 实例方法和原型方法, documentFragment, 创建对象的方式, 本地对象 内置对象 宿主对象, SPA, JQ链式调用, 网页渲染过程, 获取元素属性, 回调函数, css权重, delete与vue.delete, 盒子模型, javaScript的组成, JSON方法, http状态码, 最后一个圆角, document.reday与window.onload的区别, if有作用域吗, ajax生命周期x2F状态, 同步异步, 会话cookie和持久cookie, typeof返回值, 获取时间, url请求过程, 数据类型, 回流和重绘, 如何减少回流和重绘, GET 和 POST, 内存泄漏, 深拷贝, 浅拷贝, 继承, 事件冒泡, H5新标签, 浏览器内核, 跨域, 异步加载js, pxem和rem的区别, link和@import的区别, 性能优化, img 中 title和alt区别, DOM与BOM分别是什么？, 数组去重, 区分数组对象, 反转字符串, 事件委托, 原型对象和对象的原型, 形参和实参是什么？, arguments是什么？, 解决跨域的方法, 面向对象, 面向对象的特征：封装、继承、多态、抽象。, 原型 原型链, this指向的情况有哪些, Null和undefined的区别？, Call、apply、bind的区别？, DOCtype(document type)的作用, JS语言主要分哪几部分 三部分, 原型对象、实例对象、构造函数三者之间的关系, 判断对象自身是否包含此属性, 认识函数, JavaScript数组常用方法有哪些？, 导致JavaScript中this指向混乱的原因是什么, 1、函数调用方式不同：, 2、箭头函数的使用：, 3、使用apply、call、bind方法, 4、对象的嵌套和继承：, 怎么实现虚拟列表, 说说对轮询的理解, 什么是轮询, 轮询和长轮询有什么区别, 前端轮询的实现方法有什么, 轮询有什么缺点, 如何避免轮询的缺点, 作用域和作用域链, 作用域, 全局作用域, 函数作用域, 块级作用域, 词法作用域, 作用域链, ES6有哪些新特性, 1、let、const 块级作用域以及和 var 的区别, 2、解构-快速提取数组x2F对象中的元素, 数组解构, 对象解构, 3、模板字符串, 4、字符串扩展方法, 5、参数默认值amp剩余参数, 6、展开数组, 7、箭头函数, 特性amp优势：, 8、对象字面量增强, 9、Object.assign(target1 target2 targetN)-复制x2F合并对象, 10、Object.is(value1 value2), 11、Proxy(object handler), 12.Reflect, 13.Promise, 14.classamp静态方法amp继承, 定义, 方法, 继承：子类使用 extends 关键字实现继承可以继承父类所有属性, 15.Set, 说明：, 特性：, 用途：, 16.Map, 说明：, 区别：, 实例：, 17.Symbol, 说明：, 作用：, 18.for…of…, 用途：, 特性：, 实例：, 19. 迭代器模式, 作用：, 外部可以通过 for…of…去迭代内部的数据, 20、Generator函数, 21.includes 函数-es2016, 22. 运算符-es2016, 23.values 函数-es2017, 24.entries 函数-es2017, 25.Object.getOwnPropertyDescriptors(obj)-es2017, 26.padStart padEnd 函数-es2017, 参数：, 规则：, 作用：, 函数式编程, 是什么, 概念, 优缺点, 优点, 缺点, cookie、localStorage和sessionStorage 三者之间有什么区别, 生命周期, 存放数据大小, 易用性, 浏览器有哪几种缓存各种缓存的优先级是什么样的？, 强制缓存：, 协商缓存：, Service Worker 缓存：, Web Storage 缓存：, 这些缓存的优先级如下：, 项目首屏提速, 用户感知提速, 技术加载提速, css元素隐藏, css元素居中, em和rem的区别, em, rem, HTTP1.0和HTTP2.0的区别, 1、连接复用, 2、请求-响应方式, 3、头部压缩, 4、二进制协议, 5、流控制和优先级, 6、长连接支持, （DFS）深度优先搜索算法, BFS（宽度优先算法）, 冒泡排序, 快速排序, JavaScript中常见的数据结构, Queue 队列, Stack 栈, Linked List 链表, 集合, 树, 二叉树, 堆, es6中map和object的区别是什么, Vue, Vue的最大优势是什么?, MVVM和MVC区别是什么?, MVC ： 传统的设计模式。, MVVM： vue所使用的设计模式, 1. 在vue中不推荐直接手动操作DOM！！！, 2. 在vue中通过数据驱动视图不要在想着怎么操作DOM而是想着如何操作数据！！(思想转变), vue第一次加载页面, Vue常用修饰符有哪些?, 对Vue渐进式的理解, vue 生命周期, 说出至少4个Vue指令及作用, 为什么避免v-for和v-if在一起使用, v-if与v-show区别逐字稿, Vue中key值作用, 面试官你好我是这么理解key值的key值的主要作用是给元素添加一个唯一标识符用于提高vue渲染性能当data发生变化的时候vue会使用diff算法来对比新旧虚拟DOM.如果key值相同才会考虑复用元素.如果key值不同则会强制更新元素.一般通过给元素key设置为id来保证vue更新数据的时候可以最大限度复用相同的key值的元素., v-for指令使用key值几种情况, Vue中key作用 为什么不能用索引, v-model的作用及原理, Vue中有时候数组会更新页面有时候不更新这是为什么?, 请说下封装 vue 组件的过程, vue组件传值, Vue 组件 data 为什么必须是函数, 讲一下组件的命名规范, scoped作用与原理, Vue 的 nextTick 的原理是什么?, 子组件修改父组件的数据, vue事件冒泡, 响应式, 插槽, v-show  v-if, 自定义指令的方法有哪些?它有哪些钩子函数?还有哪些钩子函数参数?（必会）, vue路由作用与原理, 路由之间是怎么跳转的？有哪些方式?, 再用动态路由的时候防止刷新白屏, vue-router怎么配置路由（路由配置六个流程）, vue-router的钩子函数都有哪些（导航守卫）, 完整的导航解析流程, 什么是路由守卫？, 路由传值的方式有哪几种, Vue路由传参方式如何接收对应的值？, Vue的路由实现模式：hash模式和history模式, 请说出路由配置项常用的属性及作用, $route和$router的区别?, keep-alive, 跟keep-alive有关的生命周期是哪些？, vuex作用及五大组成部分, vuex中action工作流程, vuex刷新页面丢失数据原因和解决方法？, 说一下你在vue中踩过的坑, 小程序, 小程序的登录流程是什么, 小程序项目允许的最大体积是多少, 小程序和普通网页区别, 小程序的项目构成, 小程序页面的组成部分**,  app.json中的配置有哪些, window配置中的配置项有哪些, tabBar配置中的配置项有哪些, 如何自定义tabBar, networkTimeout配置中的配置项有哪些, 小程序渲染数据如何渲染, 列表渲染的指令是什么, 列表渲染如何修改item和index的名字, 列表渲染可以渲染的数据类型有哪些, block标签的作用是什么, 小程序中如何实现响应式的数据修改, 小程序生命周期函数有哪些, 页面级生命周期函数有哪些, 组件级生命周期函数有哪些, 组件的主要生命周期, input组件如何实现双线数据绑定, input组件用户输入内容时如果修改键盘右下角文字提示可以修改成哪些值, input组件中有几种键盘类型分别是什么, scroll-view组件想要纵向滚动时必须要设置的内容有哪些, navigator组件的跳转方式有哪些, navigate和 redirect方式有什么区别共同点, navigate和 switchTab 方式有什么区别共同点, navigate和 reLaunch 方式有什么区别共同点, 图片组件是否有默认宽高默认宽高是多少?, wxss和css的不同之处有哪些, 小程序有几种绑定事件的方式有什么区别, 常见移动端事件有哪说出5个以上, 触摸事件的事件对象中有哪些常见属性作用是什么, target 和currentTarget两者的区别是什么, 小程序中的事件如何传递数据, 小程序中全局数据如何使用有什么特点, 如何自定义一个组件, 关于父子组件之间样式是如何影响的, 组件的外部样式类如何设置, 小程序想要实现多个插槽使用如何设置, 父组件如何传值给子组件, 子组件如何传值给父组件, 组件如何监听页面级生命周期, 小程序中的交互API有哪些, 小程序中域名无法识别如何处理, 网络请求限制如何配置合法域名？, 小程序中base64与二进制数据流之间的转换如何转换, 你是怎么封装微信小程序的数据请求的？, 小程序支付如何实现？, 小程序如何进行分包, 普通分包和独立分包有什么不同, 分包有哪些注意事项, uni-app, uni-app有哪些优势?, uni-app语法、组件 及 生命周期 的 相同之处？, uni-app的不同之处？, 网络封装, Vue3, vue2和Vue3的区别, 一. 根节点不同, 二. 组合式API和选项式API, 三. 生命周期的变化, 四. v-if和v-for的优先级, 五. diff算法不同, 六. 响应式原理不同, 更多vue3请看我的vue3 + ts 哦！普通函数与箭头函数的区别箭头函数没有原型对象箭头函数是匿名函数不能作为构造函数不能被箭头函数不能当作函数不能使用关键字箭头函数不绑定取而代之用参数解决箭头函数不绑定会捕获他所在上下文的值作为自己的值箭头函数的永远指向其上下文的任何方法都改变不了其指向如函数函数也叫生成器函数是提供的一种异步编程解决方案函数像一个状态机保存了许多状态并将这些状态作为遍历器对象返回为了和传统的函数区别函数后面会跟着一个号函数内部通常有许多后跟着表达式表示状态函数特性传统的函数被调用后会立马执行且一次执行到结束而函数被调用时不会立马执行内部的语句而是返回了一个遍历器对象由遍历器对象的方法启动遇到后又会暂停直到下一个才会继续启动函数和构造函数的区别函数返回的遍历器是函数的实例也继承了函数的对象上的方法返回一个遍历器对象什么是是解决异步的方法对象有两个特点对象的状态不受外界的影响状态一旦改变便不会再次改变而且它的状态改变只会由并且这两种情况只要发生其中一个状态便固定了的优点支持链式调用可以将异步操作以同步的方式显示出来避免回调地狱的使用场景获取文件信息配合获取信息解决回调地狱实现单行任务队列中进行本地操作的异步过程什么是回调地狱多层回调函数的相互嵌套就形成了回调地狱缺点代码耦合性太强牵一发而动全身难以维护大量冗余的代码相互嵌套代码的可读性变差对的理解任何情况下直接在中写入的都指向函数中的在非严格模式下指向的是严格模式下是指向箭头函数中的都指向函数外上下文环境的指向对象中的指向对象外上下文环境的回调中的指向回调函数不管是不是严格模式都指向通过函数内执行当前回调函数和递归中的在非严格模式下指向的是严格模式下指向的是使用执行函数时指向事件中的回调函数指向事件监听的对象方法执行时如果第一个参数传入的不是或者是那么传入什么指向什么如果第一个参数传入的是或非严格模式下指向的类中的指向构造函数中的指向当前实例类所产生的实例对象类中实例化方法中指向谁执行该方法指向谁类中静态方法中指向该类或者该类的构造函数类中实例化箭头方法仍然指向当前类实例化的实例对象的原形对象中的指向在原型的方法中指向实例化当前构造函数的实例化对象就是谁执行该方法就指向谁什么是事件循环事件循环机制就是一种同步编程模型用于异步处理操作当代码中遇到需要等待操作结果的语句时引擎不会一直等待而是将该语句放入事件的队列中并执行下一步语句异步操作完成的时候就会将其对应的事件加入到事件队列中事件循环机制的组成事件队列用来存储事件的队列包括鼠标点击键盘输入定时器等等执行栈用来存储正在执行的代码宏任务指的是需要被放入事件队列中的任务例如等微任务指的是需要当前任务执行完成后立即执行的任务例如的方法事件轮询的机制也叫事件循环的机制一个用来等待和发送消息和事件的程序结构所有任务都在主线程上执行形成一个执行栈主线程发现有异步任务如果是微任务就把他放到微任务的消息队列里如果是宏任务就把他放到宏任务的消息队列里执行栈所有同步任务执行完毕执行微任务队列之后再执行宏任务队列以上步骤重复执行就是事件轮询宏任务微任务优先于回调函数最后执行一旦被定义就会立即执行和区别用于遍历对象的键会遍历自身和原型链上的枚举属性如果是数组将会把数组索引当做对象来遍历枚举属性是由值决定的为可枚举为不可枚举可枚举可以理解为是否可以被遍历中预定义的原型属性一般是不可枚举的而自己定义的属性一般可枚举可以通过方法判断该属性是否可枚举和一样是直接得到值不能用于对象一个对象的过程在堆内存中申请了一块空间创建一个新对象将新对象的指向构造函数中的原型对象新对象会绑定到函数调用的比如实例对象捕获构造函数的当做自己的执行构造函数中的代码为这个新对象添加属性返回新对象将初始化完毕的新对象地址保存到等号左边的变量中什么是闭包能够读取外层函数内部变量的函数当内层函数调用外层函数的变量或参数时产生闭包访问作用域函数嵌套在作用域外被调用闭包的优点只有函数内部的子函数才能读取局部变量可以避免全局污染避免全局污染闭包的缺点变量常驻内存得不到释放会使内存持续增压导致内存泄漏使用场景回调函数防抖什么是堆内存和栈内存堆内存是一种非连续的树形存储数据结构每个节点有一个值栈内存是一种连续存储数据结构具有先进后出的性质堆主要用于存放复杂类型的变量堆是先进先出空间较大堆的申请和释放是由程序员控制的容易产生内存泄漏栈主要是存储基本类型的变量栈是先进后出空间较小栈是由系统自动分配释放栈的效率高节流和防抖防抖是连续触发的事件只会执行最后一个节流是每隔一段时间触发一次实现防抖通过定时器实现节流通过时间戳使用场景防抖搜索时用户在不断输入值时用防抖来节约请求资源登陆发短信倒计时防止用户点击过快以至于发送多次请求节流鼠标不断触发某事件时如点击只在单位事件内触发一次懒加载时要监听计算滚动条的位置但不必要每次滑动都触发可以降低计算频率而不必要浪费资源哪些数组方法可以改变原数组虚拟本质上就是一个对象当数据发生变化时我们不直接操作真实因为很昂贵我们去操作这个对象就不会触发大量回流重绘操作再加上算法可以找到两次虚拟之间改变的部分从而去一次性更新真实性能得到了大大的提升谈一谈垃圾回收机制它具有自动回收机制就是对那些不再用的变量对象进行回收进行空间的释放回收的两种机制标记清除当它进入执行环境的时候它会被打上进入环境离开的时候再被打上离开环境被打上离开环境标记的都会被清除掉引用计数原理就是垃圾收集器会定时找出那些不继续使用的变量然后释放其内存因为如果内存开销比较打他的会停止响应其他操作他会阻塞其他应用程序的执行垃圾回收是按照固定时间周期性的去执行的和的区别相同点和都是一种预处理器区别在上运行在上使用两者编写变量的方式不同变量定义符不一样用的是而用在中仅允许循环数值而在中可以遍历任何类型的数据有有预处理器是什么预处理器是一种脚本语言用一种专门的编程语言来进行页面的样式设计然后再转换为正常的样式进而实现构建动态样式预处理器为增加了一些编程的特性无需考虑浏览器的兼容性问题纯函数就是一个函数的返回结果只依赖于它的参数并且在执行过程中没有副作用我们就把这个函数叫做纯函数中的就是纯函数优点可复用性纯函数仅依赖于传入的参数这意味着你可以随意将这个函数移植到别的代码中只需要提供他需要的参数即可可测试性纯函数非常容易进行单元测试因为不需要考虑上下文环境只需要考虑输入和输出并行代码纯函数是健壮的改变执行次序不会对系统造成影响因此纯函数的操作可以并行执行浏览器的同源策略机制同源策略指的是浏览器限制当前网页只能访问同源的接口资源所谓同源两方必须是同协议且同域名且同端口只要有一个不相同则会受到浏览器的约束不允许请求一般存放在哪里为什么不存放在内首先有两个存放位置一个是本地存储另一种是但是两种都有缺点存在本地存储中这意味着任何在你的网站上的运行的都可以访问所以容易受到攻击如果存在内的话浏览器的请求默认会在请求头中携带所以容易受到攻击我的意见是放到本地存储中撇开的各种优点不谈如果做好适当的防护收益是远大于风险的因为具有更灵活更大空间天然免疫的特征空间有限而一半都占用较多字节而且有时你不止需要存储一个攻击简单的说是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作如发邮件发信息甚至财产操作如转账和购买商品攻击是一种代码注入攻击攻击者通过在目标网站注入恶意脚本在用户的浏览器上运行利用这些恶意脚本攻击者可以获取用户的敏感信息如等进而危害数据安全是什么其实就是访问资源凭证一般在用户成功登陆后服务器将登陆凭证做数字签名加密后的字符串作为如何实现一条像素的线方法一定位缩放利用的是缩放功能将缩放一半同时利用定位将伪元素覆盖整个元素从而达到伪元素与本身元素的合并效果方法二利用的是的扩散半径可以设置为原理方法三直接使用属性构造函数用关键字来调用定义的函数称为构造函数默认返回的是一个新对象这个新对象具有构造函数定义的变量和函数以及方法是提出的基于的解决异步的最终方案使用搭配可以通过编写形似同步的代码来处理异步流程提高代码的简洁性和可读性用于申明一个是异步的而用于等待一个异步方法执行完成的属性不转换定义转换使用六个值的矩阵定义转换使用个值的矩阵定义转换定义转换轴转换轴转换轴转换定义缩放定义缩放轴缩放轴缩放轴缩放定义旋转定义旋转轴的旋转轴的旋转轴的旋转定义倾斜轴的倾斜轴的倾斜盒模型和标准盒模型怪异盒子模型怪异盒的元素宽度标准盒模型普通盒模型的元素宽度实现三角形是一个基于封装的请求库特点可以转换请求数据和响应数据会把响应回来的数据转成类型的数据拦截请求和响应相当于给请求加条件批量发送多个异步请求在浏览器端端都可以使用安全性更高中符叫做的构造函数就是在里面可以传参数作用就是获取元素普通函数和构造函数的区别构造函数调用方式不一样构造函数内部会创建一个新的对象构造函数出来的实例函数内部的指向构造函数出来的实例默认的返回值是构造函数出来的实例返回基本类型无效引用类型有效普通函数在函数的内部不会创建新的对象函数内部的指向调用函数的对象如果没有对象调用默认是返回值由语句决定浮动与定位只是行内的左右的改变如果后面的元素不清除浮动的话会影响后面元素的位置而定位的影响比较广既能定义一个容器的定位也能定义一个容器里面的任意定位递归函数递归就是一个函数在它的函数体内调用它自身执行递归函数将反复调用每调用一次就进入新的一层递归函数必须有结束条件优点代码简洁缺点时间和空间的消耗比较大重复计算栈溢出标签标签为元素定义标注当用户选择该标签时浏览器就会自动将焦点转到和标签相关的表单控件上执行步骤首先创建一个异步对象然后使用设置请求方式和请求地址用发送请求监听状态变化接收返回的数据最后一个元素选中统计字符串中出现最多的字母判断参数是否为字符串键为字母值为次数遍历字符串每一个字母当前字母保证初始值为次数加存储字母字母对应的次数遍历比较后存储次数多的字母以及它对应的次数返回结果出现次数最多的字母为自执行函数属于匿名函数直接调用在初次加载的时候会执行一次自执行函数只能执行一次自执行函数会形成一个独立的作用域优点将全局变量写在立即执行函数里作为局部变量防止变量污染全局避免多次声明造成变量覆盖缺点不能重复调用数组对象区别创建方式不同数组表示有序数据的集合而对象表示无序数据的集合调用方法不同对象键值唯一数组可以重复对象没有长度不能用循环元素绑定事件在上绑定点击事件使用获取元素并添加绑定事件事件侦听注册事件方法监听注册事件绑定事件使用要引入数组拉平递归原始数组属性的值有哪些默认值元素没有开启定位元素的相对定位以自身为参照物元素的绝对定位以开启了定位的祖先元素为参照物元素的固定定位静态方法实例方法和原型方法静态方法定义在构造函数上的方法只能被构造函数访问实例方法构造函数中上添加的属性都属于实例属性只能被实例对象访问原型方法是共享的方法通过构造函数的定义的方法能被实例直接访问构造函数需通过才可访问是一个保存多个的容器对象保存在内存当更新其中的一个或者多个时页面不会更新只有当容器中保存的所有更新后再将其插入到页面中才能更新页面用来批量更新创建对象的方式利用字面量创建对象优点简单方便缺点无法量产张三疯男使用对象调用对象的属性我们采取对象名属性名调用属性另一种方法对象名属性名调用对象的方法对象名方法名千万别忘记加上函数的小括号利用创建对象通过这种方式我们可以调用任意的构造函数无参的和带参数的要大写张三疯男利用等号赋值的方法添加对象的属性和方法每个属性和方法之间用分号结束利用构造函数创建对象构造函数的语法格式创建构造函数名属性值方法调用构造函数名使用构造函数名属性使用类的方法这个方法调用无参的构造函数创建对象使用类的方法这个方法调用有参数的和私有的构造函数使用方法当我们调用一个对象的方法就会创建一个新的对象将前面对象的内容全部拷贝进去用方法创建对象并不会调用任何构造函数使用反序列化当我们序列化和反序列化一个对象会给我们创建一个单独的对象在反序列化时创建对象并不会调用任何构造函数本地对象内置对象宿主对象本地对象与宿主无关无论在浏览器还是服务器中都有的对象就是标准中定义的类构造函数在使用过程中需要我们手动创建内置对象与宿主无关无论在浏览器还是服务器中都有的对象已经帮我们创建好的对象在使用过程中无需我们动手创建和它们也是本地对象根据定义每个内置对象都是本地对象宿主对象浏览器提供的对象所有的和都是宿主对象什么是宿主宿主就是指运行环境可以在浏览器中运行也可以在服务器上运行对于嵌入到网页中的来说其宿主对象就是浏览器所以宿主对象就是浏览器提供的对象所有的和都是宿主对象单页面应用程序页面内容的变化通过局部更新实现同时支持浏览器地址栏的前进与后退操作又称单页面多视图其实现原理是基于地址的变化改变会导致浏览器访问记录的改变但不会触发新的请求最核心的技术点就是前端路由优点良好的交互体验内容的改变不会重新加载页面页面数据通过异步获取没有页面之间的跳转不会出现跳转白屏的现象良好的前后端分离工作模式前端只需要专注于页面的渲染更利于前端工程化的发展后端只需要专注于接口的提供更易实现接口的复用减轻服务器的压力服务器只提供数据不负责页面的合成和逻辑的处理吞吐能力提高几倍缺点首屏加载慢解决方案路由懒加载加速代码压缩网络传输压缩不利于搜索引擎优化解决方案服务器端渲染链式调用用于链式调用方法的返回值除了获取几乎均返回对象链式调用是通过的形式来实现的通过对象上的方法最后加上把对象再返回来对象就可以再继续调用方法实现链式操作了中链式结构断开怎么办用方法结束当前链条中的最近的筛选操作并将匹配元素集还原为之前的状态链式调用的好处节省代码量代码看起来更优雅链式调用的问题所有对象的方法返回的都是对象本身也就是说没有返回值所以这种方法不一定在任何环境下都适合网页渲染过程解析文件构建树解析构建规则树将和合并构建渲染树重排根据计算节点信息重绘根据计算好的信息绘制整个页面获取元素属性属于原生的方法属于中的方法回调函数函数当作参数传递函数当作返回值返回回调函数就是一个通过函数指针调用的函数权重的权重是指样式的优先级内联样式权重值为选择器权重值为类伪类权重值为标签选择器权重为与只是将删除的元素变成了其他的元素的键值还是不变数组长度也不变是直接删除该元素也改变了数组的键值长度发生变化盒子模型包括外边距边框内边距和实际内容外边距边框内边距内容的组成描述了的语法和基本对象处理网页内容的方法和接口与浏览器交互的方法和接口方法指的是对象表示法是轻量级的文本数据交换格式具有自我描述性更易理解我们可以使用方法将对象转换为字符串我们可以使用方法将数据转换为对象状态码请求成功服务器成功处理了请求但没有返回任何内容请求的网页已永久移动到新位置请求的网页临时移动到新位置服务器不理解请求的语法服务器拒绝请求服务器找不到请求的网页请求的资源永久删除服务器遇到错误服务器目前无法使用最后一个圆角正数与的区别表示文档结构已经加载完成不包含图片等非文字媒体文件表示包含图片等文件的所有元素都加载完成有作用域吗只有函数有作用域是没有作用域的但是有一种情况会让看上去有作用域就是在语句中使用他们会有块级作用域因为才拥有块级作用域生命周期状态初始化请求对象与服务器建立链接并开始向服务器发送请求服务器已经接受请求处理请求请求已处理完成响应就绪可以在此阶段获取数据同步异步同步执行完函数或方法后需要等待系统返回值或消息这时程序是阻塞的必须接收到返回的值或消息后才往下执行其他的命令异步执行完函数或方法后不必等待返回值或消息只需要向系统委托一个异步过程那么当系统接收到返回值或消息时系统会自动触发委托的异步过程从而完成一个完整的流程会话和持久如果不包含到期日期则可视为会话会话存储在内存中决不会写入磁盘当浏览器关闭时将从此永久丢失如果包含到期日期则可视为持久性在指定的到期日期将从磁盘中删除过期时间设置方式不记录会话级关闭浏览器失效会话过期时间为小时持久返回值是以字符串的形式返回你查看的这个值是什么类型的可以判断类型也有六种分别是检测返回检测返回检测返回获取时间获取当前的日期和时间方法获取当前日期返回当前时间从对象返回当前年份从对象返回当前月份从对象返回月份的当前日从对象返回星期几从对象的当前小时请求过程十步版请求报文响应报文在浏览器地址栏中输入网址浏览器通过用户输入的构建请求报文浏览器发起寻址解析将域名转换为地址浏览器将请求报文发送给服务器服务器接收请求报文并解析服务器处理用户请求并将处理结果封装成响应报文服务器将响应报文发送给浏览器浏览器接收服务器响应的响应报文并解析浏览器解析页面并展示最终浏览器展示出了页面完整版解析将域名地址解析成地址按照以下顺序进行解析浏览器缓存系统缓存路由器缓存网络运营商缓存递归搜索若以上种都未找到则会进行连接三次握手第一次握手由浏览器发起告诉服务器我要请求数据第二次握手由服务器发出告诉浏览器我准备好接受数据了你可以发送请求了第三次握手由浏览器发出告诉服务器我马上就发你准备接受发送请求处理请求请求报文接受响应响应报文浏览器解析渲染页面断开连接四次挥手第一次挥手由浏览器发器发送给服务器我东西发完了请求报文你准备关闭吧第二次挥手由服务器发器告诉浏览器我东西接受完了请求报文我准备关闭了你也准备好第三次挥手由服务器发器告诉浏览器我东西发送完了响应报文你准备关吧第四次挥手由浏览器发器告诉服务器我东西接受完了我准备关了你也准备好吧数据类型基本数据类型引用数据类型基本数据类型是保存在栈内存中操作的是值改变源数据不会影响新的变量引用数据类型保存在堆内存中操作的是地址改变其中一个会影响另一个回流和重绘改变某个元素的结构之后会重新绘制元素的样式重绘此时会引起浏览器重绘改变页面布局之后会发生回流布局重新排列回流会引起重绘但是重绘不会引起回流如何减少回流和重绘浏览器中的优化机制浏览器会维护一个队列队列中存放的是会触发回流和重绘的操作当队列中的操作达到一定阀值或者到了一定的时间间隔时浏览器就会清空队列进行批处理这样就会让多次的回流重绘变成一次回流重绘自己进行优化使用集中修改样式使用定位让元素脱离文档流在设置的元素上操作最后显示出来使用文档片段在当前外构建一个子树在它上面操作所有再把它拷贝回文档和把参数包含在中通过传递参数在浏览器回退时是无害的而会再次提交请求请求只能进行编码而支持多种编码方式请求参数会被保留在浏览器历史记录里而中的参数不会被保留请求在中传送的参数是有长度限制的而没有对参数的数据类型只接受字符而没有限制比更不安全因为参数直接暴露在上所以不能用来传递敏感信息内存泄漏意外的全局变量引起的内存泄漏原因解决可以使用严格模式避免全局变量不会被回收闭包引起的内存泄漏原因闭包可以维持函数内局部变量使其得不到释放解决将事件处理函数定义在外部解除闭包或者在定义事件处理函数的外部函数中删除对的引用没有清理的元素引用原因对象中还存在对的引用解决手动删除即可忘记的定时器或者回调原因定时器中有的引用即使删除了但是定时器还在解决手动清除定时器和深拷贝深拷贝拷贝的是键和值深拷贝会开辟一个新的栈新对象跟原对象不共享内存修改新对象不影响原对象深拷贝实现方式手写递归的浅拷贝拷贝出来的目标对象的指针和源对象的指针指向的是同一块内存空间目标对象源对象继承原型链继承通过改变原型的指向实现继承缺点不能传递参数如果父类的属性是引用类型子类实列修改了该属性其他的子类实列会共享该属性借用父级构造函数实现继承通过修改指向不会继承缺点子类无法继承父类在原型链上的属性和方法每个实例都拷贝一份占用内存大尤其是方法过多的时候函数复用又无从谈起了本来我们用就是解决复用问题的优点解决了子类实列修改了父类属性其他的子类实列会共享该属性的问题组合继承原型链继承借用构造函数继承组合继承是最常用的继承模式缺点组合继承最大的问题就是无论在什么情况下都会调用两次构造函数一次是在创建子类型原型时另一次是在子类构造函数内部寄生组合继承常用寄生组合继承就是避免两次调用父类构造函数通过赋值直接继承父类的原型事件冒泡事件冒泡当某个元素的某类型事件被触发时如它父级的同类型事件也会被触发它的父级的父级同类型事件也会被触发以此类推一直触发到根元素途中如果有节点绑定了相应的事件处理函数这些函数都会被一次触发新标签新增的语义化布局标签和标签页面中一个内容区块的头部和尾部布局导航区域标签页面中独立的内容部分布局标签在独立内容之外但是又与有关联的部分布局新增媒体标签音频视频新增和绘画元素表示位图区域定义矢量图新增表单增强元素表单元素的属性扩充下面都属于的类型输入日期输入邮件输入地址呈现搜索常规的文本域输入一定范围内的数值输入月份颜色输入数值以及表单元素通过属性进行表单验证必填项验证表单输入浏览器内核浏览器内核又可以分成两部分渲染引擎和引擎渲染引擎负责获取网页的内容并显示引擎负责解析语言执行语言来实现网页的动态效果常用内核内核种类很多怎么分析内核常见浏览器内核可以分这四种拆呢内核带构火狐四声琳谷歌凯谷歌浏览器内核内核也是俗称的内核浏览器内核是内核苹果浏览器内核内核搜狗浏览器内核兼容模式高速模式百度浏览器内核跨域为什么有跨域因为有同源策略同源策略同源策略是一种约定它是浏览器最核心也最基本的安全功能当一个请求的协议域名端口三者之间任意一个与当前页面不同即为跨域异步加载标签中增加属性异步加载但要等文档全部解析完树生成才会被执行只有能用标签中增加属性异步加载加载完就执行只能加载外部脚本不能把写在标签里标准以下不支持封装一个函数兼容性的异步加载文件并且可以按需执行该文件里面的函数按需加载和的区别代表像素呈现的大小和屏幕分辨率有关系分辨率越高元素尺寸越小分辨率越低尺寸约大是相对于父元素大小的相对尺寸是元素相对于根元素的相对尺寸所有浏览器默认的字体大小是和的区别属于标签而完全是提供的一种方式加载顺序的差别当一个页面被加载的时候就是被浏览者浏览的时候引用的会同时被加载而引用的会等到页面全部被下载完再被加载兼容性的差别由于是提出的所以老的浏览器不支持只有在以上的才能识别而标签无此问题性能优化雪碧图雪碧图是根据音译过来的就是将很多小图标放在一张图片上就称之为雪碧图可以减少网站请求数量不过随着字体图片图片的流行该技术慢慢退出了舞台将图片的内容以格式内嵌到中可以减少请求数量但是编码之后的大小比图片大了使用字体图标来代替图片减少重定向尽量避免使用重定向当页面发生了重定向就会延迟整个文档的传输在文档到达之前页面中不会呈现任何东西也没有任何组件会被下载降低了用户体验如果一定要使用重定向的话如重定向到要使用永久重定向而不是临时重定向因为如果使用则每一次访问都会重定向到页面而永久重定向在第一次从重定向到之后每次访问会直接返回的页面使用缓存使用或这类强缓存的时候缓存不过期的情况下不会向服务器发起请求强缓存过期的时候会使用或这类协商缓存向服务器发起请求如果资源没有变化则服务器返回响应浏览器继续从本地缓存加载资源如果资源更新了则服务器将更新后的资源发送到浏览器并返回不使用使用会造成额外的请求避免使用空的和标签设置空的会重定向到当前页面的地址设置空的会提交表单到当前页面的地址压缩代码压缩就是压缩在文本文件中有意义但是在中不显示的字符包括空格制表符压缩压缩包括无效代码删除与语义合并压缩与混乱压缩与混乱包括无效字符及注释的删除代码语义的缩减和优化降低代码的可读性实现代码的保护图片压缩使用是内容分发网络它能够实时地根据网络流量和各个节点的连接负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上其目的是使用户可以就近的取得所需内容解决网络拥挤的状况提高网站的响应速度使用预解析当浏览器访问一个域名的时候需要解析一次获得对应域名的地址在解析过程中按照浏览器缓存系统缓存路由器换算缓存域名服务器的顺序逐步读取缓存直到拿到地址持久连接使用或者来建立持久连接降低了延时和连接建立的开销优化资源加载资源加载位置通过优化资源加载位置更改资源加载时机使尽可能快地展示出页面内容尽可能快地使用功能可用文件放在中先外链后本页文件放在底部先外连后本页处理页面处理页面布局的文件放在中如文件文件中尽量不写标签和标签资源加载时机异步标签异步加载在解析完成后执行的实际效果与将代码放在底部类似异步加载加载完成后立即执行模块按需加载在等业务比较复杂的系统中需要根据路由来加载当前页面所需要的业务模块按需加载是一种很好的优化网页或应用的方式这种方式实际上是先把代码在一些逻辑断点处分离开然后在一些代码块中完成某些操作后立即引用另外一些新的代码块这样加快了应用的初始加载速度减轻了它的总体体积提供了两类技术优先选择的方式是使用符合提案的语法第二种就是使用特定的使用资源预加载和资源预读取让浏览器提前加载指定资源需要执行时候再执行可以加快当前页面的加载速度告诉浏览器加载下一个页面可能会用到的资源可以加速下一个页面的加载速度资源懒加载与资源预加载资源延迟加载也称为资源懒加载延迟加载资源或符合某些条件的时候才加载某些资源资源预加载是提前加载用户所需的资源保证良好的用户体验资源懒加载和资源预加载都是一种错峰操作在浏览器忙碌的时候不能操作浏览器空闲的时候再加载资源优化了网络性能中和区别图片中的属性是在图片不能显示时出现的文本提示有利于优化图片中的属性是在鼠标在移动到图片上的文本提示与分别是什么是文档对象模型它指的是把文档当作一个对象来对待提供访问和操作网页内容的方法和接口方法获取一个的部分获取一个的部分获取标签获取文本获取元素根据获取元素点击事件点击事件是浏览器对象模型它指的是将浏览器当作一个对象来对待提供与浏览器交互的方法和接口方法显示可提示用户输入的对话框显示带有一个提示信息和一个确定按钮的警示框显示一个带有提示信息确定和取消按钮的对话框关闭浏览器窗口根据给定的打开一个新的浏览器窗口在指定的毫秒数后调用函数或计算表达式按照指定的周期以毫秒计来调用函数或表达式数组去重一利用去重中最常用二利用嵌套然后去重中最常用三利用配合去重四利用五利用六利用递归去重区分数组对象通过通过通过特地新增检测变量是否是数组反转字符串第一种字符串转数组反转数组数组转字符串根据空字符串拆分数组数组反转元素位置数组转回字符串且不带分隔符第二种定义新的空字符串遍历通过是取字符串的最后一个字符再取倒数第二个以此类推都放到新的字符串前面这样就是倒序的了事件委托事件委托又称事件代理不是直接给标签添加事件是给标签的父级添加事件通过事件对象判断触发事件的标签是谁执行不同的事件处理函数原型对象和对象的原型原型对象是创建函数引擎自动创建的对象对象的原型是实例化对象的原型会自动继承原型对象中的属性形参和实参是什么实参可以是常量变量表达式函数等在进行函数调用时它们都必须有确定的值通常将函数处理的数据影响函数功能的因素或者函数处理的结果作为形参实参是用来填充形参的是形参为实参是什么是一个对应于传递给函数的参数的类数组对象类数组是数组的形式有但不具有数组的一切方法作用可以用对象判断传递给函数的参数个数并获取参数解决跨域的方法第一种方法在后端服务器设置请求头第二种方法允许指定源访问浏览器请求路径注意谷歌浏览器不允许本地文件右键谷歌浏览器设置目标加上注意前面有空格第三种方法后端中下载插件然后引入第四种方法在前端通过标签解决跨域问题都不受同源策略的影响可以直接缺点不能接收数据只能接收代码前端通过变量或者是函数名来接收无法携带拼接的参数只能携带固定字符串不能携带拼接在后面的内容标签是同步操作第一个执行完才能执行第二个第五种方法通过动态创建的本质前端发起请求发起请求前声明一个函数后端返回一个函数调用后端返回的函数名和前端声明的函数名要一致前端的函数中的参数也就是接受的就是后端返回的数据动态标签是可以传递拼接在后边的参数的动态创建标签的三个步骤创建一个空标签给标签添加属性将创建好的标签追加到尾部第六种方法代理总的结论正向代理隐藏用户反向代理隐藏服务器正向代理用户发送请求到自己的代理服务器自己的代理服务器发送请求到服务器服务器将数据返回到自己的代理服务器自己的代理服务器再将数据返回给用户反向代理用户发送请求到反向代理服务器访问的其实是反向代理服务器但用户不知道反向代理服务器发送请求到真正的服务器真正的服务器将数据返回给反向代理服务器反向代理服务器将数据返回给用户面向对象在中对象是一个无序的数据集合或者也可以说是属性和方法的集合可以动态的添加属性和方法面向对象是一种软件开发的思想和面向过程是相对应的就是把程序看做一个对象将属性和方法封装其中以提高代码的灵活性复用性可扩展性面向过程是按需求一步一步的用代码从上往下实现这样做代码不易维护复用扩展所以大型项目中我们需要以面向对象的方式去开发这样就体现了用面向对象的方法写出来的代码易维护易复用易扩展面向对象的特征封装继承多态抽象封装我对封装的理解就是把属性和方法封装其中将不需要对外公开的内容隐藏起来提供接口让用户访问属性和方法继承继承就好比我继承了我爸部分的相貌特征但我和我爸又不完全长一个样子而且我自己没有钱但我爸有钱我爸的钱可以给我花就是指子类构造函数继承父类构造函数的一些属性和方法但其本身也有一些自己的方法和属性多态多态性是指相同的操作或函数过程可作用于多种类型的对象上并获得不同的结果比如一个我养了条狗和一个猫我对它们发出叫的指令时它们一个是汪汪汪的叫一个是喵喵喵的叫我给的指令是一样的它们发出来的声音却不一样抽象先不去考虑细节的东西从大的方向开始比如学生就是一个抽象实体他的属性并不足以描述出一个人需要更多的细节才能描述一个人的方方面面使用抽象可以尽可能避免过早考虑一些细节原型原型链原型所有的函数默认都有一个这样公有且不可枚举的属性它会指向另一个对象这个对象就是原型原型链当访问对象的属性或者方法时首先对象从自身去找找不到就会往原型中去找也就是他构造函数的中如果原型中找不到即构造函数中也没有该属性就会往原型后面的原型上去找这样就形成了链式的结构称为原型链指向的情况有哪些事件绑定中的普通函数执行中的箭头函数执行中的构造函数中的基于强制改变中的和的区别是的关键字而是的一个全局变量也就是挂载在对象上的一个变量并不是关键字在使用运算符进行检测时类型的值会返回而类型的值返回为在需要进行字符串类型的转换时会转换成字符串而会转换字符串在进行数值类型的转换时会转换为无法参与计算而会转换为可以参与计算建议无论在什么情况下都没有必要将一个变量显示的赋值为如果需要定义某个变量来保存将来要使用的对象应该将其初始化为的区别是一个方法是函数的方法可以调用函数可以改变函数中的指向和相同点都会调用函数不同点传参的方式不同传参时一直往后加参数传参数是以数组的形式传参和相同点传参的方式一样不同点会调用函数不会调用函数它会作为一个返回值返回一个函数然后才可以调用的作用是文档类型的缩写用于告诉浏览器该以什么文档标准去解析这个文档主要作用是告诉浏览器的解析器使用哪种规范或者规范来解析页面语言主要分哪几部分三部分提供核心语言功能文档对象模型提供访问和操作网页内容的方法和接口浏览器对象模型提供与浏览器交互的方法和接口原型对象实例对象构造函数三者之间的关系实例是由构造函数生成原型是构造函数的构造函数原型上的属性是构造函数本身实例的属性指向构造函数原型判断对象自身是否包含此属性认识函数函数内部定义函数闭包函数内部调用其他函数函数调用函数内部调用参数传过来的函数回调函数函数内部调用自己这个函数递归数组常用方法有哪些在数组末尾添加一个或者多个元素返回新数组的长度移除并返回数组末尾的元素在数组头部添加一个或多个元素返回新数组的长度移除并返回数组头部的元素合并两个或者多个数组并返回合并后的新数组该方法不会影响原数组从数组的指定位置截取元素返回一个新数组不会影响原始数组从数组指定位置删除或替换元素可修改原始数组查找指定元素在数组的索引位置如果没找到返回从数组尾部查找指定元素的索引位置如果没找到返回查找数组中是否有指定元素返回布尔值数组转字符串并用指定分隔符连接它们反转数组影响原始数组数组排序默认根据字母顺序排列会修改原始数组对数组每一个元素执行提供的函数遍历数组返回所有符合条件的元素创建一个新数组其中包含对数组中的每一个元素操作后的结果将数组中的元素进行累积操作返回一个单一值遍历数组判断数组中是否有符合条件的元素返回布尔值遍历数组判断数组中元素是否都符合条件返回布尔值遍历数组返回第一个符合条件的元素本身导致中指向混乱的原因是什么在中的指向是动态的也就是指向会根据上下文的环境变化而发生变化导致他的指向变得混乱或难以预测常用的导致指向混乱的原因包括一下几个方面函数调用方式不同当一个函数被调用时它的指向取决于调用方式如果使用普通函数调用方式如则会指向全局对象如果是方法调用如则指向调用该方法的对象箭头函数的使用箭头函数不具有自己的值他会捕获上下文中的值因此如果在箭头函数中访问它会指向外层作用域中的值使用方法方法都可以改变指向其中方法可以立即执行函数并传入参数而方法可以返回一个新函数该函数的值被绑定到指定对象上对象的嵌套和继承当一个对象被嵌套在另一个对象中或者使用继承时的指向可能变得混乱这是因为的指向取决于函数被调用时的上下文环境而不是对象本身因此在嵌套对象或继承类中使用时需要特别注意他的指向怎么实现虚拟列表虚拟列表是一种优化长列表渲染性能的技术他只渲染可视化区域内的内容从而降低了页面渲染的复杂度具体而言实现虚拟列表需要以下几个步骤计算可视化区域首先计算出可见区域内的列表数量和位置渲染可见区域只渲染可见区域内的内容而不是整个列表动态调整列表高度由于只渲染了部分列表项因此需要动态调整列表容器的高度确保滚动条可以正确显示并且用户可以滚动整个列表延迟加载非可见区域当用户滚动列表的时需要根据当前滚动条位置动态加载非可见区域的列表项以便在用户滚动到该区域是能够及时显示说说对轮询的理解什么是轮询轮询是指在一定时间内定时向服务器发送请求获取最新数据的过程轮询通常用于从服务器获取实时更新的数据轮询和长轮询有什么区别轮询是在固定的时间间隔内向服务器发送请求既是服务器没有数据更新也会继续发送请求而长轮询则是发送一个请求服务器如果没有数据更新则不会返回而是一直挂着直到有数据更新再返回结果前端轮询的实现方法有什么有两种基于定时器的轮询和基于递归的轮询基于定时器的轮询使用方法来定时发送请求基于递归的轮询则使用方法来控制下一次请求的时间轮询有什么缺点轮询会产生大量的无效请求浪费宽带和服务器资源并且对服务器压力比较大同时在短时间内频繁对服务器发起请求可能会被服务器视为恶意行为导致被封禁等问题如何避免轮询的缺点可以使用和等技术来实现实时数据更新是一种双向通信协议能够实现服务器与客户端之间的实时通信而是一种基于的单向通信协议可以实现服务器向客户端推送实时数据这些技术都能够减少无效请求提高数据传输效率并且对服务器资源的消耗也比较小作用域和作用域链作用域作用域即变量变量作用域又称上下文和函数生效能被访问的区域或集合换句话说作用域决定了代码区块中变量和其他资源的可见性我们一般将作用域分为全局作用域局部作用域块级作用域全局作用域不在任何函数中和大括号中的变量我们都视为全局作用域全局作用域下的变量可以在任意位置访问到函数作用域函数作用域也称局部作用域如果一个变量在函数内部声明那么这个变量只能在这个函数体内部才能被访问到函数外是访问不到的块级作用域中引入和关键字和关键字不同的是在大括号中使用和声明的变量存在于块级作用域在大括号外是访问不到的词法作用域又叫静态作用域变量被创建时就确定好了就是遵循的词法作用域相同层级的两个函数没有办法访问打彼此作用域中的变量作用域链当中使用一个变量时首先引擎会在当前作用域下去查找如果没找到则会去它的上层作用域查找依次类推直到找到该变量或者找到了全局作用域如果在全局作用域找不到在非严格模式下回隐式声明该变量严格模式直接报错有哪些新特性块级作用域以及和的区别声明方式变量提升作用域初始值重复定义是函数级不需要允许否块级不需要不允许否块级必需不允许解构快速提取数组对象中的元素数组解构单独解构根据数组索引将数组解构成单独的元素默认值解构时可以给变量设置默认值数组没有这个元素的话设置默认值剩余解构用变量名解构剩余参数到新数组只能用一次对象解构单个多个解构跟数组解构差不多解构重命名给解构出来的变量重命名默认值给解构变量设置默认值模板字符串用法使用将字符串包裹起来功能可以换行插值使用标签函数进行字符串操作换行插值字符串扩展方法是否包含是否以什么开始是否以什么结束参数默认值剩余参数给函数形参设置默认值带默认参数的形参一般放在后面减少传参导致的错误几率使用形式设置剩余形参支持无限参数剩余参数转化成数组展开数组使用将数组展开等价于中以下写法箭头函数特性优势简化了函数的写法没有机制继承自上一个函数的上下文如果上一层没有函数则指向作为异步回调函数时可解决指向问题对象字面量增强同名属性可以省略形式直接函数可以省略形式可以直接可以使用计算属性比如复制合并对象后面的属性向前面的属性合并如果是空对象可以创建一个全新对象而不是对象引用作用比较两个值是否相等特性没有隐式转换可以比较作用代理一个对象的所有包括读写操作和各种操作的监听用法不允许修改与对比优势拥有很多没有的属性方法对数组的监视更方便以非侵入的访视监管对象的读写作用用于对对象的统一操作集成相关的所有方法作用解决异步编程中回调嵌套过深问题静态方法继承定义使用关键字定义类方法实例方法需要实例化之后才能调用指向实例静态方法用修饰符修饰可以直接通过类名调用不需要实例化不指向实例而是指向当前类实例方法静态方法调用静态方法调用实例方法继承子类使用关键字实现继承可以继承父类所有属性说明是一种类似于数组的数据结构特性元素唯一性不允许重复元素使用增加重复元素将会被忽略用途数组去重数据存储说明类似以形式存储数据区别键不会隐式转换成字符串而是保持原有类型实例说明第六种原始数据类型用来定义一个唯一的变量作用创建唯一的变量解决对象键名重复问题为对象类函数等创建私有属性修改对象的标签为对象添加迭代器属性如何获取对象的属性实例对象属性重名问题为对象类函数等创建私有属性定义标签用途已统一的方式遍历所有引用数据类型特性可以随时使用终止遍历而不行实例基本用法遍历数组遍历遍历迭代对象实现可迭代的接口迭代器模式作用通过对外提供统一的接口获取内部的数据外部可以通过去迭代内部的数据增加的任务函数函数前添加生成一个生成器一般配合关键字使用最大特点惰性执行调才会往下执行主要用来解决异步回调过深的问题返回一个遍历器对象函数判断数组是否包含某个元素包含解决无法查找问题函数运算符指数运算指数运算符中十次方中十次方函数将对象的值以数组的形式返回函数将对象以键值对二维数组返回使之可以使用遍历获取对象的描述信息可以通过获得的描述信息配合来完整复制对象包含方法普通方法方法会把当做普通属性复制从而为修改不管用通过来复制对象可以完整复制对象包含函数在字符串前或者后面追加指定字符串参数填充后的目标长度填充的字符串规则填充的字符串超过目标长度会在规定长度时被截断填充字符串太短会以空格填充未传值以空格填充作用一般用来对齐字符串输出函数式编程是什么主要编程范式有三种命令式编程声明式编程函数式编程简单来说函数式编程就是把过程逻辑写成函数定义好输入参数只关心他的输出结果概念纯函数就是一个函数的返回结果只依赖于它的参数并且在执行过程中没有副作用我们就把这个函数叫做纯函数高阶函数就是以函数作为输入或者输出的函数被称为高阶函数柯里化函数柯里化是把一个多参数函数转化成一个嵌套的一元函数的过程组合与管道组合函数目的是将多个函数组合成一个函数优缺点优点更好的管理状态因为他的宗旨是无状态或者说更少的状态能最大化的减少这些未知优化代码减少出错情况更简单的复用固定输入固定输出没有其他外部变量影响并且无副作用这样的代码复用时完全不需要考虑他的内部实现和外部影响更优雅的组合往大了说网页是由各个组件组成的往小了说一个函数也可能由多个小函数组成的更强的复用性带来更强大的组合隐性好处减少代码量提高维护性缺点性能函数式编程相对于指令式编程性能绝对是一个短板因为他往往对一个方法过度包装从而产生上下文切换的性能开销资源占用在中为了实现对象状态不可变往往会创建新的对象因此他对垃圾回收所产生的压力远远超过其他编程方式递归陷阱在函数式编程中为了实现迭代通常会采用递归操作和三者之间有什么区别生命周期可设置失效时间没有设置的话默认是关闭浏览器后失效除非手动删除否则将会永久保存仅在当前网页会话下有效关闭页面或浏览器后就会被清除存放数据大小左右和可以保存的信息易用性需要程序员自己封装原生的不友好和原生的可以接受亦可再次封装来对和有更好的支持浏览器有哪几种缓存各种缓存的优先级是什么样的强制缓存浏览器发送请求服务器返回响应响应头中的缓存标识响应内容浏览器本地缓存秒缓存时间内再次加载资源就会命中强缓存失效具体时间年月日星期三缓存时间内再次加载资源就会命中强缓存同时设置和优先级更高浏览器再次发送相同请求不会再进过服务器直接从浏览器本地缓存拿出进行返回协商缓存协商缓存步骤如下缓存标识对浏览器发起请求服务器返回响应响应头中的缓存标识内容的值只有内容改变了才会变化修改时间哪怕内容没有变化重新保存可能都会导致修改时间变化同时设置和优先级更高浏览器再次发送相同的请求请求头中的缓存标识服务器会检查或者是否相等相等就命中缓存服务端返回从本地缓存中取即可否则未命中缓存返回最新的数据和响应头中的缓存标识缓存是一种特殊的脚本可以拦截网络请求并返回缓存的响应以实现离线访问和更快的加载速度等功能缓存包括和用于存储用户在网站上的永久性数据而则用于存储用户会话过程中的临时数据这些缓存的优先级如下缓存由于其可以完全控制网络请求因此具有最高的优先级即使是强制缓存也可以被它所覆盖强制缓存如果存在强制缓存并且缓存没有过期则直接使用缓存不需要向服务器发送请求协商缓存如果强制缓存未命中但协商缓存可用则会向服务器发送条件请求询问资源是否更新如果服务器返回响应则直接使用缓存缓存缓存的优先级最低只有在网络不可用或者其他缓存都未命中时才会生效项目首屏提速大致可以分两种用户感知提速因为用户在很多情况下对于速度的感知是非常主观的所以说呢我们可以通过一些加载动画来拖慢用户的这种感知技术加载提速我们可以在服务端通过进行一个预渲染然后以的形式完成首页的一个服务端渲染然后把我们后续的渲染交给客户端去进行渲染这样的话我们就组成了一种同构渲染的方式来完成一个渲染的提速还有一些静态资源的渲染比如说图片的加载比如说数据的加载我们可以借助来完成一些懒加载的处理元素隐藏渲染树不会渲染对象死了踢元素在页面内仍占据空间但是不会响应绑定的监听事件哦怕死踢元素在页面中仍占据空间并且能够响应元素绑定的监听事件通过使用绝对定位将元素移除到可视化区域外来隐藏元素使其他元素覆盖给元素给将元素缩放为元素仍在页面中占据位置但是不会响应绑定的监听事件元素居中布局设置居中给容器设置写在父元素上这就是定义了一个伸缩容器主轴对齐方式默认是横轴纵轴对齐方式默认是纵轴绝对定位设置居中使用绝对定位的方式实现水平垂直居中容器设置子元素设置绝对定位设置居中使用绝对定位的方式实现水平垂直居中容器设置子元素设置盒子宽的一半盒子高的一半还有一种奇葩的方法这个奇葩方式和使用绝对定位相似容器设置子元素设置设置固定宽度和高度都设置为设置为也能实现垂直水平居中和的区别是一个相对单位相对于当前父级文本的如果当前文字的字体尺寸没有设置则相对于浏览器的默认字体尺寸即特点的值并不是固定的会继承父元素的字体大小是相对单位是相对根元素比如标签设置那么就相当于特点为元素设定字体大小的时候是相对于根元素进行计算的当我改变根元素下的字体大小时下面的大小都会改变通过既可以做的只修改根元素就可以成比例的调整所以字体又可以避免字体大小逐层复合的连锁反应和的区别连接复用每个请求都需要建立一个新的连接请求结束后立即关闭连接这样的方式会导致每个请求都需要重新建立连接增加了延迟和开销引入了多路复用技术允许在同一个连接上发送多个请求和响应避免了建立和关闭多个连接的开销提高了性能和效率请求响应方式采用的是单向请求响应模式即每个请求只能对应一个响应请求和响应是一一对应的引入了机制服务器可以在客户端请求之前主动推送相关资源避免了客户端重复请求的等待事件提高了页面加载速度头部压缩每个请求和响应的头部都包含大量的重复信息造成了较大的网络传输开销使用算法对头部进行压缩减少了头部的大小降低了网络传输开销二进制协议采用文本形式进行数据传输易于阅读和调试但是传输效率较低采用二进制格式传输数据减少了解析的复杂性提高了传输效率流控制和优先级没有流控制和优先级的概念所有请求头都是按照发生的顺序进行处理引入了流控制和优先级的机制可以根据需求对请求进行优先级排序和流量控制确保重要请求的及时处理长连接支持基本都是短连接每个请求响应完成之后立即关闭连接支持长连接即一个连接可以承载多个请求和响应减少连接的建立和关闭次数提高了性能深度优先搜索算法其过程为沿着每一个可能的路径向下进行搜索直到不能再深入为止并且每一个节点只能访问一次宽度优先算法它并不考虑结果的可能位置彻底地搜索整张图直到找到结果为止简单来说好像是一个耳听六路眼观八方的人冒泡排序原理相邻的数据进行两两比较小数放在前面大数放在后面这样一趟下来最小的数就被排在了第一位第二趟也是如此如此类推直到所有的数据排序完成快速排序原理选择数组中的一个值作为基准将数组中小于该值的数置于该数之前大于该值的数置于该数之后接着对该数前后的两个数组进行重复操作直至排序完成中常见的数据结构队列队列是一个先进先出的数据结构一般中采用队列解决问题时会用到入队在数组的尾部添加元素出队移除数组中第一个元素取数组的第一个元素确定队列是否为空获取队列中元素的数量栈栈作为一种数据结构是一种只能在一端进行插入和删除操作的特殊线性表它按照先进后出的原则存储数据先进入的数据被压入栈底最后的数据在栈顶需要读数据的时候从栈顶开始弹出数据最后一个数据被第一个读出来中没有栈但是可以用实现栈的功能栈中数组长度减一即为栈尾元素也就是最后进入的那个元素最先出去的那个元素中对栈的操作一般会使用到方法将元素压入栈顶方法从栈顶弹出删除元素并返回该元素方法返回栈顶元素不删除方法清空栈拿到栈中元素数量链表链表是由多个元素组成的列表链表中的元素储存不连续用指针连接在一起数组增删非数组元素需要移动元素链表增删非首尾元素不需要移动元素只需要更改的指向即可链表是一个链式数据结构每个节点由两个信息组成节点的数据和指向下一个节点的指针链表和传统数组都是线性数据结构具有序列化的存储方式中没有链表但是可以用来模拟链表集合集合一种无序且唯一的数据结构集合区别队列栈链表最大的区别就是元素不能重复中中新增了集合这种数据结构可以通过实例化对象来创建集合树前端树结构还是比较常见的例如级联选择层级目录等都是树形结构中没有树这个数据结构但是一般用和来模拟树树的常用遍历方式深度优先遍历广度优先遍历二叉树叉树是个结点的有限集合该集合或者为空集称为空二叉树或者由一个根结点和两棵互不相交的分别称为根结点的左子树和右子树组成树的每个节点最多只能有两个子节点中自然也没有二叉树这个数据结构一般还是用对象来模拟二叉树二叉树遍历递归前序遍历根节点左子树右子树每次遍历到一个节点都重复一次前序遍历中序遍历左子树根节点右子树每次遍历到一个节点都重复一次中序遍历后序遍历左子树右子树根节点每次遍历到一个节点都重复一次后序遍历注意前序遍历第一个为根节点中序遍历根节点左边为左子树右边为右子树后序遍历最后一个为根节点堆堆是一种特殊的完全二叉树所有的节点都大于等于最大堆或者小于等于最小堆他的子节点中和的区别是什么的键可以是任意值而的键必须是一个或是中的是有序的而的键是无序的的键值对个数可以轻易地通过属性获取而的键值对个数只能手动计算可以直接被迭代而不可以直接被迭代在频繁增删键值对的场景下表现更好而的效率比较差的最大优势是什么比较轻量中国人自己写的框架文档易读这里比较轻松拿出平时和朋友聊天的语气双向数据绑定数据驱动视图组件化开发数据和视图分离单页面应用可以实现页面数据局部刷新和区别是什么传统的设计模式设计模式一套广泛被使用的开发方式模型模型就是数据的意思视图视图就是页面的意思控制器控制器在这里写业务逻辑把数据渲染到视图有点类似于我们之前学习的把数据渲染到页面所使用的设计模式数据模型里定义视图页面标签视图模型源码通过数据双向绑定让数据自动地双向同步不再需要操作修改视图数据自动同步修改数据视图自动同步设计模式是一套被反复使用的多数人知晓的经过分类编目的代码设计经验的总结代码分层架构设计在中不推荐直接手动操作在中通过数据驱动视图不要在想着怎么操作而是想着如何操作数据思想转变第一次加载页面创建实例在创建实例的时候执行了初始化在过程中先调用了钩子函数同时监听数据初始化内部事件进行属性和方法的计算模板开始编译把里面的数据和语法编译成当页面第一次加载时会触发常用修饰符有哪些提交事件不再重载页面阻止单击事件冒泡只执行一次这个事件监听键盘键对渐进式的理解主张最少自底向上增量开发组件集合便于复用个人见解使用模块化规范实现自助餐式开发用什么导什么最大程度上节省资源生命周期什么是生命周期和生命周期钩子函数在实例初始化之后和并未初始化这个时期变量还不能使用在下的数据和下的方法中的事件都不能获得到完成了数据的初始化没有这个时候可以操作实例中的数据和各种方法但是还不能对节点进行操作完成了和初始化这里的是虚拟的完成挂载在这发起后端请求拿回数据配合路由钩子做一些事情挂载完毕这时节点被渲染到文档内一些需要的操作在此时才能正常进行是指层数据变化前不是中的数据改变前触发是指层的数据变化之后你确认删除吗当前组件已被删除清空相关内容什么是生命周期实例从创建到销毁的过程就是生命周期也就是从开始创建初始化数据编译模板挂载渲染更新渲染卸载等一系列过程生命周期的作用是什么它的生命周期有多个事件钩子让我们在控制整个实例的过程时更容易形成好的逻辑生命周期总共有几个阶段它可以总共分为个阶段创建前后载入前后更新前后销毁前销毁后第一次页面加载会触发哪几个钩子第一次页面加载时会触发这几个钩子渲染在哪个周期中就已经完成渲染在中就已经完成了简单描述每个周期具体适合哪些场景生命周期钩子的一些使用方法可以在这加个事件在加载实例时触发初始化完成时的事件写在这里如在这结束事件异步请求也适宜在这里调用挂载元素获取到节点如果对数据统一处理说出至少个指令及作用给标签绑定函数可以缩写为例如绑定一个点击函数函数必须写在里面动态绑定作用及时对页面的数据进行更改可以简写成分号缩写为组件插槽根据数组的个数循环数组元素的同时还生成所在的标签显示内容显示与隐藏必须和连用不能单独使用否则报错解析文本解析标签为什么避免和在一起使用处理指令时比具有更高的优先级虽然用起来也没报错好使但是性能不高如果你有个元素被循环也会分别执行次与区别逐字稿面试官你好我是这么理解和的本质其实是动态的创建或者删除元素节点一般不用频繁切换要么显示要么隐藏的情况我都会用因为是惰性的如果初始值为那么这些元素就直接不创建了这样就可以节省一些初始渲染开销本质是在控制元素的样式一般元素需要频繁的切换显示隐藏用因为在频繁切换会大量的创建和删除元素消耗性能中值作用在渲染的时候会先把新与旧进行对比如果结构一致则会复用旧的此时可能造成数据渲染异常使用可以给添加一个唯一标识符让强制更新面试官你好我是这么理解值的值的主要作用是给元素添加一个唯一标识符用于提高渲染性能当发生变化的时候会使用算法来对比新旧虚拟如果值相同才会考虑复用元素如果值不同则会强制更新元素一般通过给元素设置为来保证更新数据的时候可以最大限度复用相同的值的元素指令使用值几种情况指令使用值几种情况逐字稿没有值默认是下标不复用就地更新值为下标相当于没设置不复用就地更新值是复用相同的更新不同的总结值优先设置没有就用下标中作用为什么不能用索引是给循环生成标签颁发唯一标识的用于性能的优化因为数据项的顺序改变也不会移动元素来匹配数据项的顺序而是就地更新每个元素的作用及原理作用数据双向绑定指令专门给表单元素原理是一个语法糖他背后本质上是包含两个操作绑定一个属性指令给当前元素绑定事件实现原理的例子等于框的事件中有时候数组会更新页面有时候不更新这是为什么因为内部只能监测到数组顺序位置的改变数量的改变但是值被重新赋予监测不到变更可以用请说下封装组件的过程有复用的地方就有封装先分析需求确定业务需求把页面中可以复用的结构样式以及功能具体步骤或者在配置项中定义组件名可以在中接受给组件传的参数和值子组件修改好数据后想把数据传递给父组件可以采用方法组件传值父传子子组件定义变量父组件在使用子组件时通过行内属性给变量传值特点单向数据流子传父子组件触发父的事件父在使用组件用自定义事件名父的方法子把值带出来特点事件监听非父子组件事件总线事件总线是一种通过中央事件管理器来实现组件通信的方式在中可以使用实例作为事件总线来发送和接收事件组件为什么必须是函数因为组件是需要在多个地方使用的如果是一个对象对象是引用类型一旦某一个地方修改就会全部修改是一个函数每一次复用组件的时候就会从这个函数返回一个新的对象这样组件在复用的时候就可以做到数据互不干扰讲一下组件的命名规范一种是使用链式命名一种是使用大驼峰命名因为要遵循规范中的自定义组件名字母全小写且必须包含一个连字符避免和当前以及未来的元素相冲突作用与原理作用组件作用域避免子组件内部的样式被父组件覆盖默认情况下如果子组件和父组件选择器权重相同优先加载父组件样式原理给元素添加一个自定义属性一针见血答案通过属性选择题来提高权重值的的原理是什么为什么需要是异步修改的并且不鼓励开发者直接接触但有时候业务需要必须对数据更改刷新后的做相应的处理这时候就可以使用这个了最终答案的原理是通过异步队列控制更新底层是所以是微任务这个一定要知道子组件修改父组件的数据子组件通过自定义事件名称传递的参数父组件通过子组件标签接收组件标签自定义事件名称自定义名称自定义名称灵活事件名传递的参数事件名接收的回调也算是一种事件冒泡当一个父元素包裹着一个子元素同时都有点击事件我们点击子元素不想触发父元素的事件我们可以采用阻止事件冒泡解决清除事件冒泡阻止默认行为只触发一次只允许元素自己触发响应式简单说就是用户更改数据时视图可以自动刷新页面能够响应数据变化原理在生成实例时为对传入的进行遍历使用把这些属性转为每个实例都有一个实例它会在实例渲染时记录这些属性并在触发时通知重新渲染插槽更高级的组件复用方式接收片段或内容加工处理后返回显示匿名插槽默认插槽写在插槽组件中的内容或者没有命名都会视为匿名插槽相当于我是匿名插槽接收的数据组件我要接收匿名插槽数据的具名插槽插槽组件中在模板上使用命令绑定一个名称插槽组件使用内置组件用属性去匹配名称要传的内容插槽组件内要传的内容会在这里显示作用域插槽父组件中的插槽模板里其作用域属于插槽组件父传子父组件使用向插槽组件进行传参子传父插槽组件在组件上使用反向传参父组件使用参数接收数据子集父级什么时候使用插槽当子组件被复用时需要在特定的区域展示不同的定制化的内容插槽的使用场景共同点和都是动态显示元素区别编译过程是真正的条件渲染因为它会在切换过程对元素和组件适当的销毁和重建的元素始终会被渲染只是基于属性的切换编译条件是惰性的如果在初始渲染时条件为假则什么也不做直到条件第一次变为真时才会开始渲染不管初始条件是什么元素总是会被渲染并且只是简单地基于进行切换性能消耗有更高的切换消耗有更高的初始渲染消耗应用场景适合条件很少改变时使用适合频繁切换自定义指令的方法有哪些它有哪些钩子函数还有哪些钩子函数参数必会全局定义指令在对象的方法里面有两个参数一个是指令名称另外一个是函数组件内定义指令钩子函数绑定事件触发节点插入的时候触发组件内相关更新钩子函数参数路由作用与原理路由作用实现单页面应用原理监听的值路由之间是怎么跳转的有哪些方式跳转到指定的并在中添加记录点击回退返回到上一个页面跳转到指定的但是中不会添加记录点击回退到上上个页面向前或者后跳转个页面可以是正数也可以是负数再用动态路由的时候防止刷新白屏新的路由怎么配置路由路由配置六个流程引入组件配置路由和组件和生成路由对象创建路由对象把路由对象挂载到页面使用承载路由设置路由导航声明式导航方式编程式跳转的钩子函数都有哪些导航守卫关于中的钩子函数主要分为类全局钩子函数全局前置守卫所有路由生效函数有三个参数分别是即将进入的路由对象当前导航即将离开的路由进行管道中的一个钩子如果执行完了则导航的状态就是确认的否则为终止导航单独路由独享组件只对这个路由生效组件内钩子渲染路由组件前路由改变路由离开完整的导航解析流程导航被触发在失活的组件里调用守卫调用全局的守卫在重用的组件里调用守卫在路由配置里调用解析异步路由组件在被激活的组件里调用调用全局的守卫导航被确认调用全局的钩子触发更新调用守卫中传给的回调函数创建好的组件实例会作为回调函数的参数传入什么是路由守卫路由守卫又叫导航守卫就是路由跳转前中后过程中的一些钩子函数这个函数能够让你操作一些其他的事路由传值的方式有哪几种传参可以分为两大类分别是编程式的导航和声明式的导航编程式导航字符串直接传递路由地址但是不能传递参数对象命名路由这种方式传递参数目标页面刷新会报错查询参数和配对的是接收参数声明式导航字符串命名路由还可以值需要提前在路由规则里值查询参数还可以路由传参方式如何接收对应的值三种分别是动态路由传参接收通过方式传递过来的参数一般是通过接收通过方式传递过来的参数一般是通过接收通过动态路由传参方式传递过来的参数一般是通过接收的路由实现模式模式和模式路径不同有没有工作模式不同修改当前页面不需要服务器额外配会给服务器发送请求需要服务器配置模式在浏览器中符号以及后面的字符称之为用读取特点虽然在中但不被包括在请求中用来指导浏览器动作对服务端安全无用不会重加载页面模式采用的新特性且提供了两个新方法可以对浏览器历史记录栈进行修改以及事件的监听到状态变更请说出路由配置项常用的属性及作用路由配置参数跳转路径路径相对于的组件命名路由子路由的配置参数路由嵌套路由解耦重定向路由和的区别对象用于跳转路由和传递参数对象用于接收路由跳转参数组件作用就是保持一个组件活着缓存状态组件他不会渲染成真实只是将被包裹的自定义组件的状态缓存到内存中多用于缓存表单填写的组件它不能缓存循环渲染出来的组件属性表示在被管理的组件中哪些需要保持活跃有多个需要保持的以逗号隔开属性表示在被管理的组件中哪些不需要保持活跃跟有关的生命周期是哪些前言在开发项目的时候大部分组件是没必要多次渲染的所以提供了一个内置组件来缓存组件内部状态避免重新渲染生命周期函数在被包含的组件路由中会多出两个生命周期的钩子与钩子在组件第一次渲染时会被调用之后在每次缓存组件被激活时调用钩子组件被停用离开路由时调用作用及五大组成部分作用全局数据管理解决复杂的父子组件传值作用存储数据作用派生数据相当于计算属性作用修改中的数据作用异步更新数据作用模块化处理数据中工作流程组件给发送消息异步请求数据将请求到的数据提交给同步更新中的数据刷新页面丢失数据原因和解决方法原因因为的数据都是保存在浏览器的堆和栈内的刷新浏览器页面以前堆栈申请的内存被释放这就是浏览器的运行机制那么堆栈里的数据自然就被清空了解决方法使用或第二种方法是安装第三种方法是安装第四种方法是安装说一下你在中踩过的坑操作中的数据发现没有响应式原因数组中有很多方法有的会改变数组例如有的不会改变数组例如解决方案通过对象属性值这种方式就可以达到对象新添加的属性是响应式的在操作的时候是报错的获取不到这个时候实例实例没有挂载解决方案回调函数进行获取小程序小程序的登录流程是什么用户点击登录按钮通过获取用户的码通过网络请求将码发送给开发者服务器后端开发者拿到码后需要通过向微信接口服务器请求当前用户的和后端得到和后会自定义一个登录态和及进行绑定后端会将返回给小程序端将小程序端得到后要将存到本地小程序项目允许的最大体积是多少不适用分包的情况下小程序总体积不能超过如果使用分包的情况下总体积不能超过单个包体积不能超过小程序和普通网页区别运行环境不同网页在浏览器运行小程序在微信环境运行开发模式不同网页开发用浏览器代码编辑器小程序有自己的一套标准开发模式使用小程序开发工具不同运行环境不同所以小程序没有办法调用和的小程序可以调用微信环境提供的各种比如扫码支付地理定位摇一摇附近的人等等小程序的项目构成用来存放所有小程序页面用来存放工具性质模块比如格式化时间文件封装请求数据组件文件小程序项目的入口文件类似的小程序项目的全局配置文件小程序项目的全局样式文件项目的配置文件用来配置小程序是否允许被微信搜索引擎搜索到比如在微信小程序搜京东会弹出京东小程序如果关闭搭建的项目微信是无法搜索到的小程序页面的组成部分每个页面由四个基本文件组成在文件中配置好后小程序会自动生成文件文件存放页面脚本文件存放页面的数据事件处理函数等写逻辑代码文件当前页面配置文件配置窗口的外观表现等文件存放页面布局类似但不同文件存放样式类似但是和不同新增了像素单位只能引入外链文件和样式背景图等都必须外链文件中的配置有哪些用于保存页面的路径配置页面头部的导航栏配置页面底部菜单栏页面加载时初始化的页面配置网络超时时间配置小程序的分包功能配置中的配置项有哪些导航栏背景色只支持十六进制的颜色表示法一给身霸拜克哥软的卡乐导航栏的文本样式只支持两个值导航栏的标题文本设置下拉刷新的背景色下拉刷新界面的文本样式只支持两个值是否启用下拉刷新功能以内当瑞服瑞吃导航栏的样式只支持两个值与表示默认显示导航栏表示隐藏导航栏只保留右侧胶囊按钮可以自己定义配置中的配置项有哪些配置底部的菜单栏列表项设置默认状态的文本颜色设置激活状态的文本颜色设置菜单栏的背景色设置菜单栏的上边框样式支持和菜单栏的位置只支持和自定义菜单栏或者如何自定义首先在中配置对象然后创建数组写实际的路径最少两个最多五个配置中的配置项有哪些配置网络请求的超时时间配置既时通讯的超时时间配置上传内容的超时时间配置下载文件的超时时间小程序渲染数据如何渲染使用插值表达式渲染数据列表渲染的指令是什么列表渲染如何修改和的名字列表渲染可以渲染的数据类型有哪些标签的作用是什么专门用于条件渲染和列表渲染使用的标签不会渲染到页面视图中小程序中如何实现响应式的数据修改获取数据使用变量名通过方法来修改数据小程序生命周期函数有哪些整个小程序初始化完成小程序加载完成或者当小程序切回前台时触发小程序切换到后台时触发页面级生命周期函数有哪些当前页面加载时触发的时间当前页面在前台显示时触发当前页面初次渲染完成后触发当前页面隐藏是触发当前页面卸载是触发组件级生命周期函数有哪些当前组件初始化完成时触发无法调用方法当前组件在页面中挂载是会触发当前组件已经全部渲染完成后触发当前组件从节点树中的一个位置移动到另一个位置时触发当前组件被移除是触发组件的主要生命周期在小程序中最重要的生命周期函数有三个分别是组件实例刚刚被创建好触发不能调用用来给组件的添加一些自定义属性组件完全初始化完毕进入页面节点树后触发已经被初始化完毕初始化工作比如发送请求组件离开页面节点树触发生命周期函数清理性质工作组件如何实现双线数据绑定需要通过将数据渲染到输入框中再通过事件获取用户输入的内容来修改数据的值组件用户输入内容时如果修改键盘右下角文字提示可以修改成哪些值发送搜索下一个前往完成组件中有几种键盘类型分别是什么键盘类型文本输入键盘数字输入键盘身份证输入键盘带小数点的数字键盘密码安全输入键盘指引昵称输入键盘组件想要纵向滚动时必须要设置的内容有哪些必须设置高组件的跳转方式有哪些和方式有什么区别共同点保留当前页面关闭当前页面共同点不能跳到页面可以携带参数和方式有什么区别共同点保留当前页面不可以跳转可以携带参数跳转到页面并关闭其他所有非页面不可以传参没有共同点和方式有什么区别共同点保留当前页面不可以跳转关闭所有页面允许跳转任意页面共同点可以传递参数图片组件是否有默认宽高默认宽高是多少宽高和的不同之处有哪些文件在小程序中不能使用通配符选择器新增了尺寸单位新增样式导入使用语句可以导入外联样式表该语句后面必须要以分号结尾不然会报错可以配置全局样式与局部样式全局样式直接写在中小程序有几种绑定事件的方式有什么区别小程序的事件系统两种绑定事件的语法与通过绑定通用事件会产生事件流如果祖级元素有相同类型的事件会同时触发绑定通用事件不会产生事件流与绑定时语法为事件名但是中间的可以省略常见移动端事件有哪说出个以上移动端事件触摸事件长按事件被代替手指触摸动作开始事件手指触摸动作结束事件手指触摸后移动事件手指触摸动作被打断如来电提醒弹窗手指触摸后超过再离开如果指定了事件回调函数并触发了这个事件事件将不被触发在支持的设备重按时会触发触摸事件的事件对象中有哪些常见属性作用是什么事件对象在小程序的事件绑定函数上不允许加括号调用触摸事件的事件对象记录发生改变的手指的数量表示真正触发事件的元素元素与设备左侧的距离元素与设备上方的距离记录参数信息手指触摸的坐标手指触摸的元素记录手指触摸的个数事件类型和两者的区别是什么表示的是手指触摸的元素而表示响应事件的元素我们可以通过中的内容来进行判断实现事件委托的操作我们可以通过中的属性来进行判断触发的是哪一个组件实现事件委托的操作小程序中的事件如何传递数据通过属性来传递数据例变量名传递的数据通过变量名接收数据小程序中全局数据如何使用有什么特点在中配置一个属性在这个属性中保存的内容就是全局数据在其他页面中使用时通过方法可以获取到实例从而使用就可以拿到数据在中的数据不能通过方法来更新如何自定义一个组件在项目中新建一个目录该目录用于保存自定义组件在页面的文件中的字段中引入对应的组件路径之后就可以在对应页面的中使用该组件关于父子组件之间样式是如何影响的在组件的文件中可以添加一个该选项是一个对象对象中可以添加一个属性用于控制父子组件之间的样式隔离问题属性有个可选值默认不会相互影响父影响子相互影响组件的外部样式类如何设置在子组件希望有样式的标签上添加一个类名在子组件的构造器中添加添加上的类名在父组件的子组件标签上添加对应的的属性名值是一个父组件的类名在父组件的中设置对应的的样式即可生效小程序想要实现多个插槽使用如何设置如果想要同时使用多个需要在组件的文件的选项内开启配置才会生效父组件如何传值给子组件在父组件的子组件标签上动态绑定一个自定义属性将要需要传递的数据放到属性值中在子组件的文件中通过属性来接收父组件传递的数据子组件如何传值给父组件在子组件的事件函数中通过向父组件发出一个自定义事件该方法有两个参数第一个是自定义事件名第二个是传递的参数在父组件的子组件标签上通过监听子组件发出的自定义事件在事件对象的属性中可以接收到子组件传递过来的数据组件如何监听页面级生命周期通过属性来监听该属性对象中有三个响应函数表示组件所在页面被展示时的函数表示组件所在页面被隐藏时的函数表示组件所在页面尺寸发生变化时的函数小程序中的交互有哪些消息提示框显示模态对话框显示提示框需主动调用才能关闭提示框显示操作菜单隐藏消息提示框隐藏提示框小程序中域名无法识别如何处理在小程序本地设置中勾选不校验合法域名选项即可请求在发布阶段如果希望能够请求服务器资源那么我们必须为这个服务器配置白名单网络请求限制如何配置合法域名出于安全考虑小程序对数据接口的请求有限制要求小程序只能请求类型接口必须将接口的域名添加到信任列表中否则控制台会提示警告登录小程序公众平台开发管理开发设置服务器域名修改合法域名小程序中与二进制数据流之间的转换如何转换你是怎么封装微信小程序的数据请求的在根目录下创建目录及文件和文件在封装基础的和等请求方法设置请求体带上和异常处理等在中引入封装好的请求方法根据页面数据请求的设置对应的方法并导出在具体的页面中导入或将所有的接口放在统一的文件中并导出在中创建封装请求数据的方法小程序支付如何实现小程序注册要以公司的身份去注册一个小程序才有微信支付权限绑定商户号在小程序填写合法域调用获取调用时间戳从年月日至今的秒数即当前的时间随机字符串长度为个字符以下统一下单接口返回的参数值提交格式如签名类型默认为支持和注意此处需与统一下单的签名类型一致签名具体签名方案参见微信公众号支付帮助文档成功回调失败接口调用结束的回调函数调用成功失败都会执行小程序如何进行分包在字段里面的页面都是分包内容分包根目录分包别名分包页面路径普通分包和独立分包有什么不同普通分包那么该包必须依赖主包才能加载不允许单独加载独立分包独立运行不需要先加载主包分包有哪些注意事项页面不允许放在分包中只能放在主包一个分包的根目录不能是另一个分包的子目录一个分包不能导入另一个分包的文件但是可以使用主包的文件一个分包不能使用另一个分包中的资源但是可以使用主包资源有哪些优势开发者案例的数量最多平台能力不受限制性能体验优秀周边生态丰富学习成本低开发成本低语法组件及生命周期的相同之处所有的语法接近与可以使用的所有的指令以及中的语法所有的组件接近与微信小程序所有的生命周期接近于小程序的不同之处条件编译可以在任意位置出现是以注释的形式来添加条件编译表示包含那些端渲染起始位置表示排除那些端渲染起始位置表示结束位置各端的条件表示移动端表示所有小程序表示微信小程序表示端端的开发如果你不开发那么是不需要使用的引擎内置了引擎可以让具有直接调用原生能力在和小程序端没有引擎的因此如果需要使用这个引擎还是需要加条件编译网络封装网址和的区别一根节点不同中必须要有根标签中可以没有根标签会默认将多个根标签包裹在一个虚拟标签中有利于减少内存二组合式和选项式在中采用选项式将数据和函数集中起来处理将功能点切割了当逻辑复杂的时候不利于代码阅读在中采用组合式将同一个功能的代码集中起来处理使得代码更加有序有利于代码的书写和维护三生命周期的变化创建前使用创建后使用挂载前挂载后更新前更新后销毁前销毁后异常捕获被激活被包含在中的组件会多出两个生命周期钩子函数被激活时执行切换比如从组件切换到组件组件消失时执行四和的优先级在中的优先级高于可以放在一起使用但是不建议这么做会带来性能上的浪费在中的优先级高于一起使用会报错可以通过在外部添加一个标签将移到外层五算法不同中的算法遍历每一个虚拟节点进行虚拟节点对比并返回一个对象用来存储两个节点不同的地方用记录的消息去更新缺点比较每一个节点而对于一些不参与更新的元素进行比较是有点消耗性能的特点特别要提一下的是即时的并不是打包所有修改最后一起操作也就是在中边记录变更新则是将更新放入队列后集中处理中的算法在初始化的时候会给每一个虚拟节点添加一个是一种优化的标识只会比较发生变化的节点进行识图更新而对于没有变化的元素作静态标记在渲染的时候直接复用六响应式原理不同通过的和来做数据劫持结合和发布订阅者模式来实现会遍历每一个属性通过代理的方式实现的优势不需要像的那样遍历每一个属性有一定的性能提升可以理解为在目标对象之前架设一层拦截外界对该对象的访问都必须通过这一层拦截这个拦截可以对外界的访问进行过滤和改写当属性过多的时候利用要通过遍历的方式监听每一个属性利用则不需要遍历会自动监听所有属性有利于性能的提升更多请看我的哦',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-04 16:29:51',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/img/userimg.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">苏惜的小世界</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/img/wxewm.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="/img/wxewm.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/zfbewm.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="/img/zfbewm.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">web前端面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-08-20T09:30:24.000Z" title="发表于 2023-08-20 17:30:24">2023-08-20</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-09-04T08:29:51.304Z" title="更新于 2023-09-04 16:29:51">2023-09-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为北京"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>北京</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2023/08/20/%E9%9D%A2%E8%AF%95%E9%A2%98/"><header><h1 id="CrawlerTitle" itemprop="name headline">web前端面试题</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">苏惜</span><time itemprop="dateCreated datePublished" datetime="2023-08-20T09:30:24.000Z" title="发表于 2023-08-20 17:30:24">2023-08-20</time><time itemprop="dateCreated datePublished" datetime="2023-09-04T08:29:51.304Z" title="更新于 2023-09-04 16:29:51">2023-09-04</time></header><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="普通函数与箭头函数的区别"><a href="#普通函数与箭头函数的区别" class="headerlink" title="普通函数与箭头函数的区别?"></a>普通函数与箭头函数的区别?</h2><ul>
<li>箭头函数没有原型对象prototype</li>
<li>箭头函数是匿名函数不能作为构造函数不能被new</li>
<li>箭头函数不能当作Generator函数，不能使用yeild关键字。</li>
<li>箭头函数不绑定arguments，取而代之用…rest参数解决</li>
<li>箭头函数不绑定this，会捕获他所在上下文的this值，作为自己的this值</li>
<li>箭头函数的 this永远指向其上下文的this ，任何方法都改变不了其指向，如 call() , bind() , apply()</li>
</ul>
<h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><p>Generator函数也叫生成器函数是 ES6提供的一种异步编程解决方案<br>Generator函数像一个状态机，保存了许多状态，并将这些状态作为遍历器对象返回<br>为了和传统的函数区别，Generator函数function后面会跟着一个*号，函数内部通常有许多yield后跟着表达式表示状态。<br>Generator函数特性<br>1.传统的函数被调用后会立马执行，且一次执行到return结束，而Generator函数被调用时不会立马执行内部的语句，而是返回了一个遍历器对象，<br>2.由遍历器对象的next()方法启动，遇到yield后又会暂停，直到下一个next()才会继续启动。<br>Generator函数和构造函数的区别<br>1.Generator 函数返回的遍历器是 Generator 函数的实例，也继承了 Generator 函数的prototype对象上的方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">yield</span> <span class="number">2</span>); <span class="comment">// undefined</span></span><br><span class="line">		<span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">let</span> ge=<span class="title function_">gen</span>() <span class="comment">//返回一个遍历器对象</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(ge.<span class="title function_">next</span>()) <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(ge.<span class="title function_">next</span>()) <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(ge.<span class="title function_">next</span>()) <span class="comment">//  &#123;value: 3, done: false&#125;</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(ge.<span class="title function_">next</span>()) <span class="comment">//  &#123;value: 4, done: true&#125;</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(ge.<span class="title function_">next</span>()) <span class="comment">// &#123;value: undefined , done: true&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise?"></a>什么是Promise?</h2><p>promise是解决异步的方法。</p>
<ul>
<li>Promise对象有两个特点：<ul>
<li>1）对象的状态不受外界的影响。</li>
<li>2）状态一旦改变，便不会再次改变。而且它的状态改变只会由（pending-&gt;fulfilled、pending-&gt;rejected）并且这两种情况只要发生其中一个，状态便固定了。</li>
</ul>
</li>
<li>Promise的优点：<ul>
<li>支持链式调用（可以将异步操作以同步的方式显示出来）避免回调地狱</li>
</ul>
</li>
</ul>
<h2 id="promise的使用场景"><a href="#promise的使用场景" class="headerlink" title="promise的使用场景?"></a>promise的使用场景?</h2><p>1.获取文件信息<br>2.配合Ajax获取信息<br>3.解决回调地狱，实现单行任务队列<br>4.node中进行本地操作的异步过程</p>
<h2 id="什么是回调地狱？"><a href="#什么是回调地狱？" class="headerlink" title="什么是回调地狱？"></a>什么是回调地狱？</h2><p>多层回调函数的相互嵌套 就形成了回调地狱<br>缺点：<br>    代码耦合性太强 牵一发而动全身 难以维护<br>    大量冗余的代码相互嵌套 代码的可读性变差</p>
<h2 id="对this的理解？"><a href="#对this的理解？" class="headerlink" title="对this的理解？"></a>对this的理解？</h2><p>1.任何情况下直接在script中写入的this都指向window<br>2.函数中的this在非严格模式下指向的是window，严格模式下是指向undefined<br>3.箭头函数中的this都指向函数外上下文环境的this指向<br>4.对象中的this指向对象外上下文环境的this<br>5.回调中的this指向：<br>①setTimeout，setInterval回调函数不管是不是严格模式都指向window<br>②通过函数内执行当前回调函数和递归中的this，在非严格模式下指向的是window，严格模式下指向的是undefined<br>③使用arguments执行函数时，this指向arguments<br>④事件中的回调函数，this指向事件监听的对象<br>6.call，apply，bind方法执行时，如果第一个参数传入的不是null或者是undefined，那么传入什么this指向什么；如果第一个参数传入的是null或undefined，非严格模式下this指向window<br>7.ES6的类中 this的指向<br>①构造函数中的this指向当前实例类所产生的实例对象<br>②类中实例化方法中this指向 谁执行该方法，this指向谁<br>③类中静态方法中this指向该类或者该类的构造函数<br>④类中实例化箭头方法，this仍然指向当前类实例化的实例对象<br>8.ES5的原形对象中的this指向<br>在原型的方法中，this指向实例化当前构造函数的实例化对象，就是谁执行该方法，this就指向谁</p>
<h2 id="什么是事件循环"><a href="#什么是事件循环" class="headerlink" title="什么是事件循环"></a>什么是事件循环</h2><p>事件循环机制就是一种同步编程模型，用于异步处理操作，当代码中遇到需要等待操作结果的语句时 js引擎不会一直等待，而是将该语句放入事件的队列中，并执行下一步语句，异步操作完成的时候，就会将其对应的事件加入到事件队列中</p>
<h2 id="事件循环机制的组成"><a href="#事件循环机制的组成" class="headerlink" title="事件循环机制的组成"></a>事件循环机制的组成</h2><ul>
<li>事件队列：<br>  用来存储事件的队列，包括鼠标点击、键盘输入、定时器等等</li>
<li>执行栈：<br>  用来存储正在执行的代码</li>
<li>宏任务：<br>  指的是需要被放入事件队列中的任务，例如setTimeout&#x2F;setInterval等</li>
<li>微任务：<br>  指的是需要当前任务执行完成后立即执行的任务，例如Promise的then&#x2F;catch&#x2F;finally方法</li>
</ul>
<h2 id="事件轮询的机制-也叫事件循环的机制（eventLoop）"><a href="#事件轮询的机制-也叫事件循环的机制（eventLoop）" class="headerlink" title="事件轮询的机制 也叫事件循环的机制（eventLoop）"></a>事件轮询的机制 也叫事件循环的机制（eventLoop）</h2><p>一个用来等待和发送消息和事件的程序结构。<br>1、所有任务都在主线程上执行，形成一个执行栈。<br>2、主线程发现有异步任务，如果是微任务就把他放到微任务的消息队列里，如果是宏任务就把他放到宏任务的消息队列里。<br>3、执行栈所有同步任务执行完毕。<br>4、执行微任务队列，之后再执行宏任务队列。<br>5、以上步骤重复执行就是事件轮询</p>
<ul>
<li>宏任务：setInterVal setTimeout ajax</li>
<li>微任务：promise async await .then<ul>
<li>promise优先于setTimeout，setTimeout回调函数最后执行，promise一旦被定义就会立即执行</li>
</ul>
</li>
</ul>
<h2 id="for-in和for-of区别？"><a href="#for-in和for-of区别？" class="headerlink" title="for in和for of区别？"></a>for in和for of区别？</h2><ul>
<li>for  in 用于遍历对象的键，会遍历自身和原型链上的枚举属性 如果是数组将会把数组索引当做对象来遍历</li>
<li>枚举属性是由enumerable值决定的，true为可枚举，false为不可枚举</li>
<li>可枚举可以理解为是否可以被遍历</li>
<li>JS中预定义的原型属性一般是不可枚举的，而自己定义的属性一般可枚举</li>
<li>可以通过propertyIsEnumerable方法判断该属性是否可枚举</li>
<li><code>for of</code>和<code>forEach</code>一样,是直接得到值</li>
<li><code>for of</code>不能用于对象</li>
</ul>
<h2 id="new一个对象的过程？"><a href="#new一个对象的过程？" class="headerlink" title="new一个对象的过程？"></a>new一个对象的过程？</h2><ul>
<li>在堆内存中申请了一块空间 创建一个新对象</li>
<li>将新对象的__proto__指向构造函数中的原型对象prototype</li>
<li>新对象会绑定到函数调用的this(比如：实例对象捕获构造函数的this当做自己的this)</li>
<li>执行构造函数中的代码（为这个新对象添加属性）</li>
<li>返回新对象。| 将初始化完毕的新对象地址，保存到等号左边的变量中</li>
</ul>
<h2 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h2><p>能够读取外层函数内部变量的函数</p>
<ul>
<li>当内层函数调用外层函数的变量或参数时产生闭包<br>1.访问作用域<br>2.函数嵌套<br>3.在作用域外被调用</li>
<li>闭包的优点：只有函数内部的子函数才能读取局部变量,可以避免全局污染(避免全局污染)</li>
<li>闭包的缺点：变量常驻内存，得不到释放会使内存持续增压，导致内存泄漏<br>使用场景<br>1.setTimeout<br>2.回调<br>3.函数防抖</li>
</ul>
<h2 id="什么是堆内存和栈内存？"><a href="#什么是堆内存和栈内存？" class="headerlink" title="什么是堆内存和栈内存？"></a>什么是堆内存和栈内存？</h2><p>堆内存是一种非连续的树形存储数据结构，每个节点有一个值<br>栈内存是一种连续存储数据结构，具有先进后出的性质</p>
<ul>
<li><p>堆主要用于存放复杂类型的变量</p>
<ul>
<li>堆是先进先出</li>
<li>空间较大</li>
<li>堆的申请和释放是由程序员控制的，容易产生内存泄漏</li>
</ul>
</li>
<li><p>栈主要是存储基本类型的变量</p>
<ul>
<li>栈是先进后出</li>
<li>空间较小</li>
<li>栈是由系统自动分配释放</li>
<li>栈的效率高</li>
</ul>
</li>
</ul>
<h2 id="节流和防抖？"><a href="#节流和防抖？" class="headerlink" title="节流和防抖？"></a>节流和防抖？</h2><p>防抖是连续触发的事件，只会执行最后一个<br>节流是每隔一段时间触发一次<br>实现防抖通过定时器<br>实现节流通过时间戳</p>
<ul>
<li>使用场景<br>  防抖：<br>  search搜索时，用户在不断输入值时，用防抖来节约请求资源。<br>  登陆，发短信（倒计时），防止用户点击过快，以至于发送多次请求<br>  节流：<br>  鼠标不断触发某事件时,如点击,只在单位事件内触发一次.<br>  懒加载时要监听计算滚动条的位置,但不必要每次滑动都触发,可以降低计算频率,而不必要浪费CPU资源.</li>
</ul>
<h2 id="哪些数组方法可以改变原数组？"><a href="#哪些数组方法可以改变原数组？" class="headerlink" title="哪些数组方法可以改变原数组？"></a>哪些数组方法可以改变原数组？</h2><p>shift()  unshift()  pop()  reverse()  sort()  splice()  push()</p>
<h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><p>本质上就是一个JS对象，当数据发生变化时，我们不直接操作真实DOM，因为很昂贵，我们去操作这个JS对象，就不会触发大量回流重绘操作，再加上diff算法，可以找到两次虚拟DOM之间改变的部分，从而去一次性更新真实DOM 性能得到了大大的提升</p>
<h2 id="谈一谈垃圾回收机制"><a href="#谈一谈垃圾回收机制" class="headerlink" title="谈一谈垃圾回收机制?"></a>谈一谈垃圾回收机制?</h2><p>js它具有自动回收机制 就是对那些不再用的变量对象进行回收 进行空间的释放</p>
<ul>
<li>回收的两种机制<br>  1.标记清除 当它进入执行环境的时候 它会被打上进入环境 离开的时候再被打上离开环境 被打上离开环境标记的都会被清除掉<br>  2.引用计数</li>
<li>原理就是 垃圾收集器会定时找出那些不继续使用的变量 然后释放其内存 因为如果内存开销比较打 他的GC会停止响应其他操作 他会阻塞其他应用程序的执行<br>垃圾回收是按照固定时间 周期性的去执行的</li>
</ul>
<h2 id="less-和-sass-的区别"><a href="#less-和-sass-的区别" class="headerlink" title="less 和 sass 的区别 ?"></a>less 和 sass 的区别 ?</h2><p>相同点：<br>Sass和Less都是一种CSS预处理器<br>区别：</p>
<ul>
<li>Less在JS上运行，Sass在Ruby上使用；</li>
<li>两者编写变量的方式不同；<br>  变量定义符不一样，less用的是@，而sass用$。</li>
<li>在Less中仅允许循环数值，而在Sass中可以遍历任何类型的数据；</li>
<li>Sass有Compass，Less有Preboot。</li>
</ul>
<h2 id="CSS预处理器是什么？"><a href="#CSS预处理器是什么？" class="headerlink" title="CSS预处理器是什么？"></a>CSS预处理器是什么？</h2><p>CSS预处理器是一种脚本语言，用一种专门的编程语言来进行Web页面的样式设计，然后再转换为正常的CSS样式，进而实现构建动态CSS样式。<br>CSS 预处理器为 CSS 增加了一些编程的特性，无需考虑浏览器的兼容性问题。</p>
<h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><p>就是一个函数的返回结果只依赖于它的参数，并且在执行过程中没有副作用，我们就把这个函数叫做纯函数。<br>（redux中的reducer就是纯函数）<br>优点：</p>
<ul>
<li>可复用性 纯函数仅依赖于传入的参数，这意味着你可以随意将这个函数移植到别的代码中，只需要提供他需要的参数即可</li>
<li>可测试性 纯函数非常容易进行单元测试，因为不需要考虑上下文环境，只需要考虑输入和输出。</li>
<li>并行代码 纯函数是健壮的，改变执行次序不会对系统造成影响，因此纯函数的操作可以并行执行。<!--
// 不是纯函数，依赖了外部变量a
var a = 1
function add(b) { return a+b }
add(1) // 2
// 是纯函数
function add(a, b) { return a+b }
add(1, 2) // 3
-->
<!-- 
// 不是纯函数，有副作用，改变obj里面的a
var obj = {a: 1}
function mul(obj) {
  return obj.a *= 2
}
mul(obj) //2
obj.a //2
// 是纯函数
var obj = {a: 1}
function mul(a) {
  return a *= 2
}
mul(obj.a) //2
obj.a //1 --></li>
</ul>
<h2 id="浏览器的同源策略机制"><a href="#浏览器的同源策略机制" class="headerlink" title="浏览器的同源策略机制?"></a>浏览器的同源策略机制?</h2><p>同源策略，指的是浏览器限制当前网页只能访问同源的接口资源。<br>所谓同源 两方必须是同协议、且同域名、且同端口。只要有一个不相同，则会受到浏览器的约束，不允许请求。</p>
<h2 id="token一般存放在哪里-为什么不存放在cookie内"><a href="#token一般存放在哪里-为什么不存放在cookie内" class="headerlink" title="token一般存放在哪里?为什么不存放在cookie内?"></a>token一般存放在哪里?为什么不存放在cookie内?</h2><p>首先有两个存放位置<br>一个是本地存储 另一种是cookie<br>但是两种都有缺点<br>存在本地存储中 这意味着任何在你的网站上的运行的JavaScript都可以访问，所以容易受到XSS攻击<br>如果存在cookie内的话，浏览器的请求默认会在请求头中携带cookie，所以容易受到csrf攻击<br>我的意见是 放到本地存储中<br>撇开localStorage的各种优点不谈，如果做好适当的XSS防护，收益是远大于风险的。<br>因为localStorage具有更灵活，更大空间，天然免疫 CSRF的特征。Cookie空间有限，而JWT一半都占用较多字节，而且有时你不止需要存储一个JWT。</p>
<ul>
<li>CSRF攻击<br>简单的说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如：发邮件、发信息、甚至财产操作如转账和购买商品）</li>
<li>XSS攻击<br>是一种代码注入攻击。攻击者通过在目标网站注入恶意脚本，在用户的浏览器上运行。利用这些恶意脚本，攻击者可以获取用户的敏感信息如Cookie、SessionID等，进而危害数据安全。</li>
</ul>
<h2 id="token是什么"><a href="#token是什么" class="headerlink" title="token是什么"></a>token是什么</h2><p>token其实就是访问资源凭证 一般在用户成功登陆后 服务器将登陆凭证做数字签名 加密后的字符串作为token</p>
<h2 id="如何实现一条0-5像素的线"><a href="#如何实现一条0-5像素的线" class="headerlink" title="如何实现一条0.5像素的线"></a>如何实现一条0.5像素的线</h2><p>方法一： 定位+缩放<br>利用的是 transform 缩放功能，将 1px 缩放一半，同时利用定位，将伪元素覆盖整个 div 元素，从而达到伪元素与本身元素的合并效果。</p>
<p>方法二： box-shadow<br>利用的是 box-shadow 的扩散半径可以设置为 0.5px 原理<br>方法三： 直接使用border属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">border</span>: <span class="number">0.</span>5px solid #f00;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul>
<li>用new关键字来调用定义的函数，称为构造函数。默认返回的是一个新对象，这个新对象具有构造函数定义的变量和函数以及方法</li>
</ul>
<h2 id="async-await"><a href="#async-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h2><p>async&#x2F;await 是ES7提出的基于Promise的解决异步的最终方案。<br>async、await使用 async&#x2F;await, 搭配promise,可以通过编写形似同步的代码来处理异步流程, 提高代码的简洁性和可读性 async用于申明一个function是异步的 而await用于等待一个异步方法执行完成</p>
<h2 id="transform的属性"><a href="#transform的属性" class="headerlink" title="transform的属性"></a>transform的属性</h2><p>none：不转换。<br>matrix(mei chui ke si)(n,n,n,n,n,n)：定义2D转换，使用六个值的矩阵。<br>matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) 定义3D转换，使用 16 个值的 4x4 矩阵。<br>translate(x,y)：定义2D转换。<br>translate3d(x,y,z)：定义3D转换。<br>translateX(x)：X轴转换<br>translateY(y)：Y轴转换<br>translateZ(z)：Z轴3D转换<br>scale(si gei o)(x,y)：定义2D缩放<br>scale3d(x,y,z)：定义3D缩放<br>scaleX(x)：X轴缩放<br>scaleY(y)：Y轴缩放<br>scaleZ(z)：Z轴3D缩放<br>rotate(angle)：定义2D旋转<br>rotate3d(x,y,z,angle)：定义3D旋转。<br>rotateX(angle)：X轴的3D旋转<br>rotateY(angle)：Y轴的3D旋转<br>rotateZ(angle)：Z轴的3D旋转<br>skew(x-angle,y-angle)：定义2D倾斜<br>skewX(angle)：X轴的2D倾斜<br>skewY(angle)：Y轴的2D倾斜</p>
<h2 id="IE盒模型和标准盒模型"><a href="#IE盒模型和标准盒模型" class="headerlink" title="IE盒模型和标准盒模型"></a>IE盒模型和标准盒模型</h2><ul>
<li>IE怪异盒子模型(怪异盒)的元素宽度width&#x3D;content+padding+border</li>
<li>标准盒模型(普通盒模型)的元素宽度width&#x3D;content+padding+border+margin</li>
</ul>
<h2 id="css实现三角形"><a href="#css实现三角形" class="headerlink" title="css实现三角形"></a>css实现三角形</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line"><span class="attribute">border-left</span>:<span class="number">100px</span> solid red;</span><br><span class="line"><span class="attribute">border-right</span>:<span class="number">100px</span> solid transparent;</span><br><span class="line"><span class="attribute">border-bottom</span>:<span class="number">100px</span> solid transparent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p>Axios是一个基于promise封装的http请求库<br>特点:<br>1、可以转换请求数据和响应数据，会把响应回来的数据转成 JSON类型的数据；<br>2、拦截请求和响应（相当于给请求加条件）；<br>3、axios.all(promises): 批量发送多个（异步）请求；<br>4、axios在浏览器端&#x2F;node 端都可以使用<br>5、安全性更高</p>
<h2 id="JQ中-符"><a href="#JQ中-符" class="headerlink" title="JQ中$()符"></a>JQ中$()符</h2><p>叫做jQuery的构造函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$()就是jQuery()，在里面可以传参数，作用就是获取元素。</span><br></pre></td></tr></table></figure>

<h2 id="普通函数和构造函数的区别"><a href="#普通函数和构造函数的区别" class="headerlink" title="普通函数和构造函数的区别"></a>普通函数和构造函数的区别</h2><p>构造函数：</p>
<ol>
<li>调用方式不一样 new Fn()</li>
<li>构造函数内部会创建一个新的对象，构造函数new出来的实例</li>
<li>函数内部的this指向 构造函数new出来的实例</li>
<li>默认的返回值是构造函数new出来的实例，return 返回基本类型无效,引用类型有效<br>普通函数：</li>
<li>fn()</li>
<li>在函数的内部不会创建新的对象</li>
<li>函数内部的this指向调用函数的对象（如果没有对象调用，默认是window）</li>
<li>返回值由return语句决定</li>
</ol>
<h2 id="浮动与定位"><a href="#浮动与定位" class="headerlink" title="浮动与定位"></a>浮动与定位</h2><p>float只是行内的 左右的改变，如果后面的元素不清除浮动(clear:both)的话 会影响后面元素的位置，<br>而positon定位的影响比较广，既能定义一个容器的定位也能定义一个容器里面的任意定位</p>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>递归就是一个函数在它的函数体内调用它自身。执行递归函数将反复调用，每调用一次就进入新的一层。递归函数必须有结束条件。<br>优点：<br>代码简洁。<br>缺点：<br>1、时间和空间的消耗比较大<br>2、重复计算<br>3、栈溢出</p>
<h2 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h2><p><label> 标签为input元素定义标注 当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。</p>
<h2 id="ajax执行步骤"><a href="#ajax执行步骤" class="headerlink" title="ajax执行步骤"></a>ajax执行步骤</h2><p>1.首先创建一个XMLHttpRequest异步对象<br>2.然后使用open设置请求方式和请求地址<br>3.用send发送请求<br>4.监听状态变化<br>5.接收返回的数据</p>
<h2 id="最后一个元素选中css"><a href="#最后一个元素选中css" class="headerlink" title="最后一个元素选中css"></a>最后一个元素选中css</h2><p>:last-child</p>
<h2 id="统计字符串中出现最多的字母"><a href="#统计字符串中出现最多的字母" class="headerlink" title="统计字符串中出现最多的字母"></a>统计字符串中出现最多的字母</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;aabbbccdd&#x27;</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">getChar</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> str !== <span class="string">&#x27;string&#x27;</span>) <span class="keyword">return</span> <span class="comment">// 判断参数是否为字符串</span></span><br><span class="line">    <span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>() <span class="comment">// 键为字母，值为次数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i ++) &#123; <span class="comment">// 遍历字符串每一个字母</span></span><br><span class="line">		<span class="keyword">let</span> char = str.<span class="title function_">charAt</span>(i) <span class="comment">// 当前字母</span></span><br><span class="line">		obj[char] = obj[char] || <span class="number">0</span> <span class="comment">// 保证初始值为0</span></span><br><span class="line">		obj[char] ++ <span class="comment">// 次数加1</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br><span class="line">	<span class="keyword">let</span> maxChar <span class="comment">// 存储字母</span></span><br><span class="line">	<span class="keyword">let</span> maxNum = <span class="number">0</span> <span class="comment">// maxChar字母对应的次数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123; <span class="comment">// 遍历obj</span></span><br><span class="line">		<span class="keyword">if</span> (obj[key] &gt; maxNum) &#123;</span><br><span class="line">            maxChar = key <span class="comment">// 比较后存储次数多的字母</span></span><br><span class="line">            maxNum = obj[key] <span class="comment">// 以及它对应的次数</span></span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxChar <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;出现次数最多的字母为：&#x27;</span> + <span class="title function_">getChar</span>(str))</span><br></pre></td></tr></table></figure>

<h2 id="自执行函数"><a href="#自执行函数" class="headerlink" title="自执行函数"></a>自执行函数</h2><ul>
<li>属于匿名函数,直接调用;</li>
<li>在初次加载的时候，会执行一次(自执行函数只能执行一次)</li>
<li>自执行函数会形成一个独立的作用域<br>优点:将全局变量写在立即执行函数里，作为局部变量，防止变量污染全局(避免多次声明造成变量覆盖)<br>缺点:不能重复调用</li>
</ul>
<h2 id="数组-对象区别"><a href="#数组-对象区别" class="headerlink" title="数组 对象区别"></a>数组 对象区别</h2><p>创建方式不同：数组表示有序数据的集合，而对象表示无序数据的集合<br>调用方法不同<br>对象键值唯一，数组可以重复<br>对象没有长度，不能用for循环</p>
<h2 id="元素绑定事件"><a href="#元素绑定事件" class="headerlink" title="元素绑定事件"></a>元素绑定事件</h2><p>1、在HTML上绑定点击事件<br>2、使用js获取元素并添加绑定事件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;click me&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&quot;hello world!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>3、事件侦听注册事件 addEventListener</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>方法监听注册事件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="number">22</span>);</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>4、jQuery 绑定事件<br>使用click 要引入jquery.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;button&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;);</span><br></pre></td></tr></table></figure>


<h2 id="数组拉平"><a href="#数组拉平" class="headerlink" title="数组拉平"></a>数组拉平</h2><ul>
<li>递归</li>
<li>原始数组.flat();</li>
</ul>
<h2 id="postion属性的值有哪些"><a href="#postion属性的值有哪些" class="headerlink" title="postion属性的值有哪些"></a>postion属性的值有哪些</h2><p>static(si da tei ke)：默认值，元素没有开启定位<br>relative:元素的相对定位,以自身为参照物<br>absolute:元素的绝对定位，以开启了定位的祖先元素为参照物<br>fixed(fei ke si te):元素的固定定位</p>
<h2 id="静态方法-实例方法和原型方法"><a href="#静态方法-实例方法和原型方法" class="headerlink" title="静态方法 实例方法和原型方法"></a>静态方法 实例方法和原型方法</h2><ul>
<li>静态方法<ul>
<li>定义在构造函数上的方法</li>
<li>只能被构造函数访问</li>
</ul>
</li>
<li>实例方法<ul>
<li>构造函数中this上添加的属性都属于实例属性</li>
<li>只能被实例对象访问</li>
</ul>
</li>
<li>原型方法 是共享的方法<ul>
<li>通过构造函数的prototype定义的方法</li>
<li>能被实例直接访问，构造函数需通过prototype才可访问</li>
</ul>
</li>
</ul>
<h2 id="documentFragment"><a href="#documentFragment" class="headerlink" title="documentFragment"></a>documentFragment</h2><p>documentFragment是一个保存多个element的容器对象（保存在内存）当更新其中的一个或者多个element时，页面不会更新。只有当documentFragment容器中保存的所有element更新后再将其插入到页面中才能更新页面。<br>documentFragment用来批量更新</p>
<h2 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">- 利用字面量创建对象</span><br><span class="line">    优点：简单方便</span><br><span class="line">	缺点：无法量产</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        <span class="attr">uname</span>: <span class="string">&#x27;张三疯&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">        <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">        <span class="attr">sayHi</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi~&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	- 使用对象。</span><br><span class="line">		调用对象的属性，我们采取对象名.属性名</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">uname</span>);</span><br><span class="line">		调用属性另一种方法 对象名[<span class="string">&#x27;属性名&#x27;</span>]</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(obj[<span class="string">&#x27;uname&#x27;</span>]);</span><br><span class="line">		调用对象的方法对象名.方法名( )</span><br><span class="line">			obj.<span class="title function_">sayHi</span>();<span class="comment">//千万别忘记加上函数的小括号</span></span><br><span class="line"></span><br><span class="line">- 利用<span class="keyword">new</span> <span class="title class_">Object</span>创建对象</span><br><span class="line">    通过这种方式，我们可以调用任意的构造函数(无参的和带参数的)</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//O要大写</span></span><br><span class="line">        obj.<span class="property">uname</span> = <span class="string">&#x27;张三疯&#x27;</span>;</span><br><span class="line">        obj.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">        obj.<span class="property">sex</span> = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">        obj.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi~&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">uname</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">age</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(obj[<span class="string">&#x27;sex&#x27;</span>]);</span><br><span class="line">        obj.<span class="title function_">sayHi</span>();</span><br><span class="line">        利用等号赋值的方法添加对象的属性和方法</span><br><span class="line">        每个属性和方法之间用分号结束</span><br><span class="line">- 利用构造函数创建对象</span><br><span class="line">	构造函数的语法格式</span><br><span class="line">    <span class="comment">//创建</span></span><br><span class="line">        <span class="keyword">function</span> 构造函数名() &#123;</span><br><span class="line">            <span class="variable language_">this</span>.属性 = 值;</span><br><span class="line">            <span class="variable language_">this</span>.方法 = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用</span></span><br><span class="line">        <span class="keyword">new</span> 构造函数名();</span><br><span class="line">        <span class="comment">// 使用</span></span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> 构造函数名().属性)</span><br><span class="line"></span><br><span class="line">- 使用<span class="title class_">Class</span>类的newInstance方法</span><br><span class="line">    这个方法调用无参的构造函数创建对象。</span><br><span class="line">- 使用<span class="title class_">Constructor</span>类的newInstance方法</span><br><span class="line">    这个方法调用有参数的和私有的构造函数。</span><br><span class="line">- 使用clone方法</span><br><span class="line">    当我们调用一个对象的clone方法，jvm就会创建一个新的对象，将前面对象的内容全部拷贝进去。用clone方法创建对象并不会调用任何构造函数。</span><br><span class="line">- 使用反序列化</span><br><span class="line">    当我们序列化和反序列化一个对象，jvm会给我们创建一个单独的对象。在反序列化时，jvm创建对象并不会调用任何构造函数。</span><br></pre></td></tr></table></figure>

<h2 id="本地对象-内置对象-宿主对象"><a href="#本地对象-内置对象-宿主对象" class="headerlink" title="本地对象 内置对象 宿主对象"></a>本地对象 内置对象 宿主对象</h2><ul>
<li>本地对象<br>与宿主无关，无论在浏览器还是服务器中都有的对象，就是ECMAScript标准中定义的类(构造函数)<br>在使用过程中需要我们手动new创建<br>  Object、Function、Array、String、Boolean、Number、Date</li>
<li>内置对象<br>与宿主无关，无论在浏览器还是服务器中都有的对象 ECMAScript已经帮我们创建好的对象 在使用过程中无需我们动手new创建<br>  Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）</li>
<li>宿主对象<br>浏览器提供的对象。所有的BOM和DOM都是宿主对象<br>什么是宿主？<br>宿主就是指JavaScript运行环境，js可以在浏览器中运行，也可以在服务器上运行(nodejs)<br>对于嵌入到网页中的js来说，其宿主对象就是浏览器，所以宿主对象就是浏览器提供的对象<br>所有的BOM和DOM都是宿主对象</li>
</ul>
<h2 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h2><p>​ SPA（Single Page Application）单页面应用程序，页面内容的变化通过ajax局部更新实现，同时支持浏览器地址栏的前进与后退操作，又称单页面多视图。其实现原理是基于url地址的hash变化，hash改变会导致浏览器访问记录的改变，但不会触发新的url请求。SPA最核心的技术点就是前端路由。<br>优点：</p>
<ul>
<li>良好的交互体验 内容的改变不会重新加载页面 页面数据通过ajax异步获取 没有页面之间的跳转 不会出现跳转白屏的现象</li>
<li>良好的前后端分离工作模式 前端只需要专注于页面的渲染 更利于前端工程化的发展 后端只需要专注于API接口的提供 更易实现API接口的复用</li>
<li>减轻服务器的压力 服务器只提供数据不负责页面的合成和逻辑的处理 吞吐能力提高几倍<br>缺点：</li>
<li>首屏加载慢 解决方案 路由懒加载 CDN加速 代码压缩 网络传输压缩</li>
<li>不利于SEO(搜索引擎优化) 解决方案：SSR服务器端渲染</li>
</ul>
<h2 id="JQ链式调用"><a href="#JQ链式调用" class="headerlink" title="JQ链式调用"></a>JQ链式调用</h2><p>.:用于链式调用  jq方法的返回值,除了获取,几乎均返回jq对象<br>链式调用是通过return this的形式来实现的；通过对象上的方法，最后加上return this，把对象再返回来，对象就可以再继续调用方法，实现链式操作了；</p>
<ul>
<li>jq中链式结构断开怎么办？用end()<br>  end() 方法结束当前链条中的最近的筛选操作，并将匹配元素集还原为之前的状态。</li>
</ul>
<p>链式调用的好处：节省代码量，代码看起来更优雅<br>链式调用的问题：所有对象的方法返回的都是对象本身，也就是说没有返回值，所以这种方法不一定在任何环境下都适合。</p>
<h2 id="网页渲染过程"><a href="#网页渲染过程" class="headerlink" title="网页渲染过程"></a>网页渲染过程</h2><p>1.解析HTML文件，构建 DOM Tree(dom树)<br>2.解析CSS，构建 CSSOM Tree(CSS规则树)<br>3.将 DOM Tree 和 CSSOM Tree合并，构建Render tree(渲染树)<br>4.reflow(重排)：根据Render tree计算节点信息（Layout）<br>5.repaint(重绘)：根据计算好的信息绘制整个页面（Painting）</p>
<h2 id="获取元素属性"><a href="#获取元素属性" class="headerlink" title="获取元素属性"></a>获取元素属性</h2><p>innerHTML、outerHTML、innerText 、outerText、value 属于原生javascript的方法。<br>  text()、html()，val()属于jQuery中的方法。</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>函数当作参数传递<br>函数当作返回值返回<br>回调函数就是一个通过函数指针调用的函数</p>
<h2 id="css权重"><a href="#css权重" class="headerlink" title="css权重"></a>css权重</h2><p>Css的权重是指样式的优先级<br>内联样式，权重值为1000<br>ID选择器，权重值为100<br>类、伪类，权重值为10<br>标签选择器，权重为1</p>
<h2 id="delete与vue-delete"><a href="#delete与vue-delete" class="headerlink" title="delete与vue.delete"></a>delete与vue.delete</h2><p>delete只是将删除的元素变成了undefined 其他的元素的键值还是不变。数组长度也不变。<br>Vue.delete是直接删除该元素，也改变了数组的键值，长度发生变化。</p>
<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>包括：外边距,边框,内边距,和实际内容。<br>Margin（外边距）<br>Border（边框）<br>Padding（内边距）<br>Content（内容）</p>
<h2 id="javaScript的组成"><a href="#javaScript的组成" class="headerlink" title="javaScript的组成"></a>javaScript的组成</h2><p>ECMAScript：描述了JS的语法和基本对象。<br>DOM：处理网页内容的方法和接口<br>BOM：与浏览器交互的方法和接口</p>
<h2 id="JSON方法"><a href="#JSON方法" class="headerlink" title="JSON方法"></a>JSON方法</h2><p>JSON 指的是 JavaScript 对象表示法<br>JSON 是轻量级的文本数据交换格式<br>JSON 具有自我描述性，更易理解<br>JSON.stringify() 我们可以使用 JSON.stringify() 方法将 JavaScript 对象转换为字符串。<br>JSON.parse() 我们可以使用 JSON.parse() 方法将数据转换为 JavaScript 对象。</p>
<h2 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h2><p>1、200 ：请求成功<br>2、204： 服务器成功处理了请求，但没有返回任何内容。<br>3、301： 请求的网页已永久移动到新位置。。<br>4、302： 请求的网页临时移动到新位置。<br>5、400： 服务器不理解请求的语法。<br>6、403： 服务器拒绝请求。<br>7、404： 服务器找不到请求的网页。<br>8、410 ：请求的资源永久删除<br>9、500 ：服务器遇到错误<br>10、503： 服务器目前无法使用</p>
<h2 id="最后一个圆角"><a href="#最后一个圆角" class="headerlink" title="最后一个圆角"></a>最后一个圆角</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span>/<span class="selector-pseudo">:nth-last-child</span>(<span class="number">1</span>)||(正数)<span class="selector-pseudo">:first</span>-child/:<span class="built_in">nth-first-child</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="attribute">border-radius</span>:<span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="document-reday与window-onload的区别"><a href="#document-reday与window-onload的区别" class="headerlink" title="document.reday与window.onload的区别"></a>document.reday与window.onload的区别</h2><p>document.reday表示文档结构已经加载完成 不包含图片等非文字媒体文件<br>window.onload表示包含图片等文件的所有元素都加载完成。</p>
<h2 id="if有作用域吗"><a href="#if有作用域吗" class="headerlink" title="if有作用域吗"></a>if有作用域吗</h2><ul>
<li>只有函数有作用域，if是没有作用域的。<ul>
<li>但是有一种情况会让if看上去有作用域，就是在if {}语句中，使用const、let，他们会有块级作用域。(因为const、let才拥有块级作用域 )</li>
</ul>
</li>
</ul>
<h2 id="ajax生命周期-状态"><a href="#ajax生命周期-状态" class="headerlink" title="ajax生命周期&#x2F;状态"></a>ajax生命周期&#x2F;状态</h2><p>0 初始化xhr 请求对象<br>1 与服务器建立链接并开始向服务器发送请求<br>2 服务器已经接受请求<br>3 处理请求<br>4 请求已处理完成,响应就绪,js可以在此阶段获取数据</p>
<h2 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h2><p>同步，执行完函数或方法后，需要等待系统返回值或消息，这时程序是阻塞的，必须接收到返回的值或消息后才往下执行其他的命令。<br>异步，执行完函数或方法后，不必等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。</p>
<h2 id="会话cookie和持久cookie"><a href="#会话cookie和持久cookie" class="headerlink" title="会话cookie和持久cookie"></a>会话cookie和持久cookie</h2><p>如果 cookie 不包含到期日期，则可视为会话 cookie。 会话 cookie 存储在内存中，决不会写入磁盘。 当浏览器关闭时，cookie 将从此永久丢失。<br>如果 cookie 包含到期日期，则可视为持久性 cookie。 在指定的到期日期，cookie 将从磁盘中删除。</p>
<ul>
<li>cookie过期时间设置方式：<br> -  cookie.setMaxAge(0);&#x2F;&#x2F;不记录cookie<br> -  cookie.setMaxAge(-1);&#x2F;&#x2F;会话级cookie，关闭浏览器失效  –会话cookie<br> -  cookie.setMaxAge(60*60);&#x2F;&#x2F;过期时间为1小时 –持久cookie</li>
</ul>
<h2 id="typeof返回值"><a href="#typeof返回值" class="headerlink" title="typeof返回值"></a>typeof返回值</h2><p>是以字符串的形式返回你查看的这个值是什么类型的<br>typeof可以判断类型也有六种，分别是：<br>    number<br>    string<br>    Boolean<br>    object<br>    undefined<br>    function<br>检测array返回object<br>检测null返回object<br>检测NaN返回number</p>
<h2 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a>获取时间</h2><p>1、获取当前的日期和时间<br>方法：new Date()<br>2、获取当前日期<br>new Date().toLocaleDateString()<br>3、返回当前时间<br>new Date().toLocaleTimeString()<br>4、从Date()对象返回当前 年份<br>new Date().getFullYear()<br>5、从Date()对象返回当前 月份<br>new Date().getMonth()+1<br>6、从Date()对象返回月份的当前 日<br>new Date().getDate()<br>7、从Date()对象返回星期几<br>new Date().getDay()<br>8、从Date()对象的 当前 小时<br>new Date().getHours()</p>
<h2 id="url请求过程"><a href="#url请求过程" class="headerlink" title="url请求过程"></a>url请求过程</h2><p>十步版  请求报文   响应报文<br>1.在浏览器地址栏中输入网址。<br>2.浏览器通过用户输入的URL构建HTTP请求报文。<br>3.浏览器发起DNS（寻址）解析，将域名转换为IP地址。<br>4.浏览器将请求报文发送给服务器。<br>5.服务器接收请求报文（request），并解析。<br>6.服务器处理用户请求，并将处理结果封装成HTTP响应报文（response）。<br>7.服务器将HTTP响应报文发送给浏览器。<br>8.浏览器接收服务器响应的HTTP响应报文，并解析。<br>9.浏览器解析 HTML 页面并展示<br>10.最终浏览器展示出了页面。<br>完整版：<br>    1.DNS 解析：将域名地址解析成 IP 地址<br>    按照以下顺序进行 DNS 解析：<br>        Browser DNS cache（浏览器 DNS 缓存）<br>        OS DNS cache（系统 DNS 缓存）<br>        Router DNS cache（路由器 DNS 缓存）<br>        ISP DNS cache（网络运营商 DNS 缓存）<br>        Recursive search（递归搜索）（若以上 4 种都未找到，则会进行 Recursive search）<br>    2. TCP 连接：TCP 三次握手<br>        第一次握手：由浏览器发起，告诉服务器我要请求数据<br>        第二次握手：由服务器发出，告诉浏览器我准备好接受数据了，你可以发送请求了<br>        第三次握手：由浏览器发出，告诉服务器我马上就发，你准备接受<br>    3. 发送 HTTP 请求&#x2F;处理请求：请求报文<br>    4.  接受响应：响应报文<br>    5.  浏览器解析、渲染页面<br>    6.  断开连接：TCP 四次挥手<br>        第一次挥手：由浏览器发器，发送给服务器，我东西发完了（请求报文），你准备关闭吧<br>        第二次挥手：由服务器发器，告诉浏览器，我东西接受完了（请求报文），我准备关闭了，你也准备好<br>        第三次挥手：由服务器发器，告诉浏览器，我东西发送完了（响应报文），你准备关吧<br>        第四次挥手：由浏览器发器，告诉服务器，我东西接受完了，我准备关了，你也准备好吧</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>基本数据类型-&gt;string、number、Boolean、null、undefined、symbol<br>引用数据类型-&gt;array、object、function<br>基本数据类型是保存在栈内存中，操作的是值，改变源数据不会影响新的变量<br>引用数据类型保存在堆内存中，操作的是地址，改变其中一个会影响另一个</p>
<h2 id="回流和重绘"><a href="#回流和重绘" class="headerlink" title="回流和重绘"></a>回流和重绘</h2><p>改变某个元素的结构之后，会重新绘制元素的样式(重绘)，此时会引起浏览器重绘</p>
<ul>
<li>改变页面布局之后，会发生回流布局重新排列，(回流会引起重绘，但是重绘不会引起回流)</li>
</ul>
<h2 id="如何减少回流和重绘"><a href="#如何减少回流和重绘" class="headerlink" title="如何减少回流和重绘"></a>如何减少回流和重绘</h2><ul>
<li><p>1.浏览器中的优化机制<br>浏览器会维护一个队列，队列中存放的是会触发回流和重绘的操作，当队列中的操作达到一定阀值或者到了一定的时间间隔时，浏览器就会清空队列，进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。</p>
</li>
<li><p>2.自己进行优化<br>使用className。集中修改样式<br>使用定位让元素脱离文档流。<br>在设置display:none;的元素上操作，最后显示出来<br>使用文档片段(document fragment)，在当前DOM外构建一个子树，在它上面操作所有DOM，再把它拷贝回文档。</p>
</li>
</ul>
<h2 id="GET-和-POST"><a href="#GET-和-POST" class="headerlink" title="GET 和 POST"></a>GET 和 POST</h2><p>GET把参数包含在URL中，POST通过request body传递参数。<br>GET在浏览器回退时是无害的，而POST会再次提交请求。<br>GET请求只能进行url编码，而POST支持多种编码方式。<br>GET请求参数会被保留在浏览器历史记录里，而POST中的参数不会被保留。<br>GET请求在URL中传送的参数是有长度限制的，而POST没有。<br>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。<br>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>1）意外的全局变量引起的内存泄漏<br>原因：<br>解决：可以使用严格模式避免全局变量，不会被回收</p>
<p>2）闭包引起的内存泄漏<br>原因：闭包可以维持函数内局部变量，使其得不到释放<br>解决：将事件处理函数定义在外部，解除闭包，或者在定义事件处理函数的外部函数中，删除对dom的引用</p>
<p>3）没有清理的DOM元素引用<br>原因：对象中还存在对dom的引用<br>解决：手动删除即可</p>
<p>4） 忘记的定时器或者回调<br>原因：定时器中有dom的引用，即使dom删除了，但是定时器还在<br>解决：手动清除定时器和dom</p>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><ul>
<li>深拷贝拷贝的是键和值<br>深拷贝会开辟一个新的栈，新对象跟原对象不共享内存，修改新对象不影响原对象<br>深拷贝实现方式：<br>JSON.parse(JSON.stringify())、手写递归、jquery的$.extend</li>
</ul>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>拷贝出来的目标对象的指针和源对象的指针指向的是同一块内存空间，<br>Object.assign(目标对象，源对象)</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>原型链继承(通过改变原型的指向实现继承)<br>    - 缺点：<br>        1、不能传递参数，<br>        2、如果父类的属性是引用类型，子类实列修改了该属性，其他的子类实列会共享该属性。<br>借用父级构造函数实现继承(通过call修改this指向)(不会继承prototype)<br>    - 缺点：<br>        1、子类无法继承父类在原型链上的属性和方法。<br>        2，每个实例都拷贝一份，占用内存大，尤其是方法过多的时候 (函数复用又无从谈起了，本来我们用prototype就是解决复用问题的)<br>    - 优点：<br>    1、解决了子类实列修改了父类属性，其他的子类实列会共享该属性的问题<br>组合继承(原型链继承+借用构造函数继承)<br>    组合继承是js最常用的继承模式，<br>    - 缺点：<br>        1、组合继承最大的问题就是无论在什么情况下，都会调用两次构造函数：一次是在创建子类型原型时，另一次是在子类构造函数内部。<br>寄生组合继承(常用)<br>    - 寄生组合继承就是避免两次调用父类构造函数，通过赋值直接继承父类的原型</p>
<h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>事件冒泡：当某个元素的某类型事件被触发时（如 onclick），它父级的同类型事件也会被触发，它的父级的父级同类型事件也会被触发，以此类推，一直触发到根元素。途中如果有节点绑定了相应的事件处理函数，这些函数都会被一次触发。</p>
<h2 id="H5新标签"><a href="#H5新标签" class="headerlink" title="H5新标签"></a>H5新标签</h2><p>新增的语义化布局标签</p>
<ol>
<li>header和footer(fu te)标签：页面中一个内容区块的头部和尾部布局；</li>
<li>nav：导航区域；</li>
<li>article(a ti ke)标签：页面中独立的内容部分布局；</li>
<li>aside(e sai de)标签：在独立内容之外，但是又与article有关联的部分布局；<br>新增媒体标签</li>
<li>audio(o diu)（音频）；</li>
<li>video(v diu)（视频）；<br>新增canvas和svg绘画元素</li>
<li>canvas表示位图区域；</li>
<li>svg定义矢量图；<br>新增表单增强元素<br>表单元素 input 的 type 属性扩充：(下面都属于type的类型)<br>date（输入日期）；<br>email（输入邮件）；<br>url（输入url地址）；<br>search（呈现搜索常规的文本域）；<br>range（输入一定范围内的数值）；<br>month（输入月份）；<br>color（颜色）；<br>number（输入数值）；<br>以及表单元素 input 通过属性进行表单验证：required（必填项）、pattern（验证表单输入）。</li>
</ol>
<h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><p>浏览器内核又可以分成两部分：渲染引擎和JS引擎<br>渲染引擎：负责获取网页的内容并显示<br>JS引擎：负责解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果</p>
<ul>
<li>常用内核(内核种类很多) (怎么分析内核)<br>  常见浏览器内核可以分这四种：Trident(拆呢te(IE内核))、Gecko(带构(火狐))、Blink(be(四声)琳ke(谷歌))、Webkit(web凯te(谷歌))<br>1、IE浏览器内核：               Trident内核，也是俗称的IE内核；<br>2、Chrome浏览器内核：           是Blink内核；<br>3、苹果Safari浏览器内核：       Webkit内核，<br>5、搜狗、QQ浏览器内核：         Trident（兼容模式）+Webkit（高速模式）；<br>6、百度浏览器：                 IE内核</li>
</ul>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>为什么有跨域，因为有同源策略<br>      同源策略：同源策略是一种约定，它是浏览器最核心也最基本的安全功能<br>当一个请求 url 的协议、域名、端口三者之间任意一个与当前页面 url 不同即为跨域</p>
<h2 id="异步加载js"><a href="#异步加载js" class="headerlink" title="异步加载js"></a>异步加载js</h2><p>defer(script标签中增加defer属性，异步加载)：<br>    但要等dom文档全部解析完（dom树生成）才会被执行。<br>    只有IE能用；<br>async(script标签中增加async属性，异步加载):<br>    加载完就执行;async只能加载外部脚本<br>    不能把js写在script标签里。<br>    .w3c标准，IE9以下不支持<br>封装一个函数兼容性的异步加载js文件并且可以按需执行该文件里面的函数（按需加载）</p>
<h2 id="px，em和rem的区别"><a href="#px，em和rem的区别" class="headerlink" title="px，em和rem的区别"></a>px，em和rem的区别</h2><p>1、px代表像素，呈现的大小和屏幕分辨率有关系，分辨率越高元素尺寸越小，分辨率越低尺寸约大；<br>2、em是相对于父元素大小的相对尺寸；<br>3、rem是元素相对于根元素html的相对尺寸；<br>4、所有浏览器默认的字体大小是16px；</p>
<h2 id="link和-import的区别"><a href="#link和-import的区别" class="headerlink" title="link和@import的区别"></a>link和@import的区别</h2><p>1、link属于XHTML标签，而@import完全是CSS提供的一种方式。<br>2、加载顺序的差别。当一个页面被加载的时候（就是被浏览者浏览的时候），link引用的CSS会同时被加载，而@import引用的CSS会等到页面全部被下载完再被加载。<br>3、兼容性的差别。由于@import是CSS2.1提出的所以老的浏览器不支持，@import只有在IE5以上的才能识别，而link标签无此问题。</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>1.1.1 雪碧图<br>雪碧图是根据css sprite(si bai te)音译过来的，就是将很多小图标放在一张图片上就称之为雪碧图，可以减少网站http请求数量，不过随着字体图片、svg图片的流行该技术慢慢退出了舞台</p>
<p>1.1.2 Base64<br>将图片的内容以Base64格式内嵌到HTML中，可以减少http请求数量，但是编码之后的大小比图片大了</p>
<p>1.1.3 使用字体图标来代替图片<br>1.2 减少重定向<br>尽量避免使用重定向，当页面发生了重定向，就会延迟整个HTML文档的传输。在HTML文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载，降低了用户体验<br>如果一定要使用重定向的话，如http重定向到https，要使用301永久重定向，而不是302临时重定向，因为如果使用302则每一次访问http都会重定向到https页面，而永久重定向在第一次从http重定向到https之后，每次访问http，会直接返回https的页面</p>
<p>1.3 使用缓存<br>使用cache-control或expires这类强缓存的时候，缓存不过期的情况下不会向服务器发起请求。强缓存过期的时候，会使用last-modified或etag这类协商缓存向服务器发起请求，如果资源没有变化，则服务器返回304响应，浏览器继续从本地缓存加载资源，如果资源更新了，则服务器将更新后的资源发送到浏览器，并返回200</p>
<p>1.4 不使用css@import<br>使用css@import会造成额外的请求</p>
<p>1.5 避免使用空的src和href<br>a标签设置空的href，会重定向到当前页面的地址<br>form设置空的method，会提交表单到当前页面的地址</p>
<p>2.1 html压缩<br>html代码压缩就是压缩在文本文件中有意义，但是在html中不显示的字符，包括空格，制表符</p>
<p>2.2 css压缩<br>css压缩包括无效代码删除与css语义合并</p>
<p>2.3 js压缩与混乱<br>js压缩与混乱包括无效字符及注释的删除、代码语义的缩减和优化、降低代码的可读性、实现代码的保护</p>
<p>2.4 图片压缩</p>
<p>3.1 使用CDN<br>CDN是内容分发网络，它能够实时地根据网络流量和各个节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上，其目的是使用户可以就近的取得所需内容，解决网络拥挤的状况，提高网站的响应速度</p>
<p>3.2 使用DNS预解析<br>当浏览器访问一个域名的时候，需要解析一次DNS,获得对应域名的ip地址，在解析过程中，按照浏览器缓存、系统缓存、路由器换算、DNS缓存、域名服务器的顺序，逐步读取缓存，直到拿到ip地址</p>
<p>3.3 持久连接<br>使用keep-alive或者persistent来建立持久连接，降低了延时和连接建立的开销</p>
<p>4、优化资源加载<br>4.1 资源加载位置<br>通过优化资源加载位置，更改资源加载时机，使尽可能快地展示出页面内容，尽可能快地使用功能可用<br>1、css文件放在head中，先外链，后本页<br>2、js文件放在body底部，先外连，后本页<br>3、处理页面、处理页面布局的js文件放在head中，如babel-polyfill.js文件、flexible.js文件<br>4、body中尽量不写style标签和script标签</p>
<p>4.2 资源加载时机<br>1、异步script标签<br>defer：异步加载，在html解析完成后执行。defer的实际效果与将代码放在body底部类似<br>async：异步加载，加载完成后立即执行<br>2、模块按需加载<br>在SPA等业务比较复杂的系统中，需要根据路由来加载当前页面所需要的业务模块<br>按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积</p>
<p>webpack提供了两类技术，优先选择的方式是使用符合ECMAScript提案的import语法，第二种就是使用webpack特定的require.ensure</p>
<p>3、使用资源预加载preload和资源预读取prefetch<br>preload让浏览器提前加载指定资源，需要执行时候再执行，可以加快当前页面的加载速度<br>prefetch告诉浏览器加载下一个页面可能会用到的资源，可以加速下一个页面的加载速度<br>4、资源懒加载与资源预加载<br>资源延迟加载也称为资源懒加载，延迟加载资源或符合某些条件的时候才加载某些资源<br>资源预加载是提前加载用户所需的资源，保证良好的用户体验<br>资源懒加载和资源预加载都是一种错峰操作，在浏览器忙碌的时候不能操作，浏览器空闲的时候再加载资源，优化了网络性能</p>
<h2 id="img-中-title和alt区别"><a href="#img-中-title和alt区别" class="headerlink" title="img 中 title和alt区别"></a>img 中 title和alt区别</h2><p>图片中的 alt属性是在图片不能显示时出现的文本提示。alt有利于SEO优化<br>图片中的 title属性是在鼠标在移动到图片上的文本提示。</p>
<h2 id="DOM与BOM分别是什么？"><a href="#DOM与BOM分别是什么？" class="headerlink" title="DOM与BOM分别是什么？"></a>DOM与BOM分别是什么？</h2><p>DOM是文档对象模型<br>    它指的是把文档当作一个对象来对待，提供访问和操作网页内容的方法和接口<br>    - 方法：<br>    document.head  获取一个html的head部分<br>    document.body  获取一个html的body部分<br>    document.innerHTML 获取标签<br>    document.innerText 获取文本<br>    document.querySelector 获取元素<br>    document.getElementById 根据id获取元素<br>    onclick 点击事件<br>    addEventListener 点击事件<br>BOM是浏览器对象模型<br>    它指的是将浏览器当作一个对象来对待，提供与浏览器交互的方法和接口<br>    - 方法<br>    prompt  显示可提示用户输入的对话框<br>    alert  显示带有一个提示信息和一个确定按钮的警示框<br>    confirm  显示一个带有提示信息、确定和取消按钮的对话框<br>    close  关闭浏览器窗口<br>    open  根据给定的url打开一个新的浏览器窗口<br>    setTimeout  在指定的毫秒数后调用函数或计算表达式<br>    setInterval  按照指定的周期（以毫秒计）来调用函数或表达式</p>
<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><p>一、利用ES6 Set去重（ES6中最常用）<br>二、利用for嵌套for，然后splice去重（ES5中最常用）<br>三、利用filter配合indexOf去重<br>四、利用sort()<br>五、利用includes<br>六、利用递归去重</p>
<h2 id="区分数组对象"><a href="#区分数组对象" class="headerlink" title="区分数组对象"></a>区分数组对象</h2><p>1.通过constructor<br>2.通过Object.prototype.toString.call()<br>3.通过instanceof<br>4.ES5特地新增isArray()检测变量是否是数组</p>
<h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><p>第一种：<br>字符串转数组，反转数组，数组转字符串。<br>split(“”)：根据空字符串拆分数组<br>reverse()：数组反转元素位置<br>join(“”)：数组转回字符串,且不带分隔符</p>
<p>第二种：<br>定义新的空字符串，遍历str，通过charAt()是取字符串的最后一个字符，再取倒数第二个…以此类推。都放到新的字符串前面。这样就是倒序的了</p>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>事件委托，又称事件代理，不是直接给标签添加事件 是给标签的父级添加事件 通过事件对象判断触发事件的标签是谁 执行不同的事件处理函数</p>
<h2 id="原型对象和对象的原型"><a href="#原型对象和对象的原型" class="headerlink" title="原型对象和对象的原型"></a>原型对象和对象的原型</h2><p>原型对象prototype 是创建函数 js引擎自动创建的对象<br>对象的原型__proto__ 是实例化对象的原型 会自动继承原型对象中的属性</p>
<h2 id="形参和实参是什么？"><a href="#形参和实参是什么？" class="headerlink" title="形参和实参是什么？"></a>形参和实参是什么？</h2><p>实参可以是常量、变量、表达式、函数等，在进行函数调用时，它们都必须有确定的值。<br>通常将函数处理的数据，影响函数功能的因素或者函数处理的结果作为形参。<br>实参是用来填充形参的<br>funcation a(b){<br>var x&#x3D;b;<br>}<br>a(‘zs’)<br>b是形参，’zs’为实参</p>
<h2 id="arguments是什么？"><a href="#arguments是什么？" class="headerlink" title="arguments是什么？"></a>arguments是什么？</h2><p>arguments是一个对应于传递给函数的参数的类数组对象。<br>类数组：是数组的形式，有length，但不具有数组的一切方法。<br>作用：<br>可以用arguments 对象判断传递给函数的参数个数并获取参数</p>
<!-- 比如，你给函数传了一个叫a的参数，并且只有这一个参数，那么a与arguments[0]都是对这个参数值的引用 -->

<h2 id="解决跨域的方法"><a href="#解决跨域的方法" class="headerlink" title="解决跨域的方法"></a>解决跨域的方法</h2><p>第一种方法<br>    在后端服务器设置 请求头 res.setHeader(“Access-Control-Allow-Origin”,”*”)<br>第二种方法<br>    允许指定源访问<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> arr=[<span class="string">&quot;浏览器请求路径&quot;</span>]</span><br><span class="line">    <span class="keyword">if</span>(arr.<span class="title function_">includes</span>(req.<span class="property">headers</span>.<span class="property">origin</span>))&#123;</span><br><span class="line">        res.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>,req.<span class="property">headers</span>.<span class="property">origin</span>)</span><br><span class="line">    &#125;</span><br><span class="line">注意:谷歌浏览器不允许本地file文件load 右键谷歌浏览器--设置--目标：加上<span class="string">&quot;--allow-file-access-from-files&quot;</span>注意前面有空格</span><br></pre></td></tr></table></figure><br>第三种方法<br>    后端中下载插件 npm i cors<br>    然后引入<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cors=<span class="built_in">require</span>(<span class="string">&quot;cors&quot;</span>)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cors</span>())</span><br></pre></td></tr></table></figure><br>第四种方法<br>    在前端通过script标签解决跨域问题<br>    Script src link 都不受同源策略的影响<br>    可以直接<sceript src="服务器路径"><br>    缺点：<br>    1、不能接收JSON数据 只能接收js代码 前端通过变量或者是函数名来接收<br>    2、无法携带拼接的参数 只能携带固定字符串 不能携带拼接在?后面的内容<br>    3、script标签是同步操作 第一个script执行完才能执行第二个script<br>第五种方法<br>    通过jsonp动态创建script<br>        jsonp的本质<br>        前端发起请求 发起请求前声明一个函数 function fn(data){console.log(data)}<br>        后端返回一个函数调用 res.send(fn(333))后端返回的函数名和前端声明的函数名要一致<br>        前端的函数中的参数也就是data接受的就是后端返回的数据 333<br>        动态scipt标签是可以传递拼接在?后边的参数的</p>
<pre><code>    动态创建script标签的三个步骤
    创建一个空标签 let s=docoument.createElement(&quot;script&quot;)
    给标签添加属性 s.src=&quot;http://localhost:3000/getData&quot;
    将创建好的标签追加到尾部 document.documentElement.appendChild(s)
</code></pre>
<p>第六种方法<br>    nginx(代理)<br>      总的结论：<br>          正向代理隐藏用户<br>          反向代理隐藏服务器<br>          正向代理：<br>              1.用户发送请求到自己的代理服务器<br>              2.自己的代理服务器发送请求到服务器<br>              3.服务器将数据返回到自己的代理服务器<br>              4.自己的代理服务器再将数据返回给用户<br>          反向代理：<br>              1.用户发送请求到反向代理服务器(访问的其实是反向代理服务器，但用户不知道)<br>              2.反向代理服务器发送请求到真正的服务器<br>              3.真正的服务器将数据返回给反向代理服务器<br>              4.反向代理服务器将数据返回给用户</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul>
<li>在js中对象是一个无序的数据集合或者也可以说是属性和方法的集合，可以动态的添加属性和方法</li>
<li>面向对象是一种软件开发的思想和面向过程是相对应的，就是把程序看做一个对象，将属性和方法封装其中，以提高代码的灵活性、复用性、可扩展性</li>
<li>面向过程是按需求一步一步的用代码从上往下实现，这样做代码不易维护、复用、扩展</li>
<li>所以大型项目中我们需要以面向对象的方式去开发这样就体现了用面向对象的方法写出来的代码易维护、易复用、易扩展。</li>
</ul>
<h6 id="面向对象的特征：封装、继承、多态、抽象。"><a href="#面向对象的特征：封装、继承、多态、抽象。" class="headerlink" title="面向对象的特征：封装、继承、多态、抽象。"></a>面向对象的特征：封装、继承、多态、抽象。</h6><ul>
<li>封装<br>  我对封装的理解就是把属性和方法封装其中，将不需要对外公开的内容隐藏起来提供接口让用户访问属性和方法。</li>
<li>继承<br>  继承就好比我继承了我爸部分的相貌特征但我和我爸又不完全长一个样子，而且我自己没有钱但我爸有钱，我爸的钱可以给我花。<br>  就是指子类构造函数继承父类构造函数的一些属性和方法，但其本身也有一些自己的方法和属性</li>
<li>多态<br>  多态性是指相同的操作或函数、过程可作用于多种类型的对象上并获得不同的结果<br>  比如一个我养了条狗和一个猫，我对它们发出“叫”的指令时它们一个是“汪汪汪”的叫一个是“喵喵喵”的叫，我给的指令是一样的它们发出来的声音却不一样。</li>
<li>抽象<br>  先不去考虑细节的东西，从大的方向开始。比如学生就是一个抽象实体，他的属性并不足以描述出一个人，需要更多的细节才能描述一个人的方方面面。使用抽象可以尽可能避免过早考虑一些细节</li>
</ul>
<h2 id="原型-原型链"><a href="#原型-原型链" class="headerlink" title="原型 原型链"></a>原型 原型链</h2><p>原型：<br>    所有的函数默认都有一个“prototype”这样公有且不可枚举的属性，它会指向另一个对象，这个对象就是原型。<br>原型链：<br>    当访问对象的属性或者方法时，首先对象从自身去找，找不到就会往原型中去找，也就是他构造函数的prototype中，如果原型中找不到，即构造函数中也没有该属性，就会往原型后面的原型上去找，这样就形成了链式的结构，称为原型链</p>
<h2 id="this指向的情况有哪些"><a href="#this指向的情况有哪些" class="headerlink" title="this指向的情况有哪些"></a>this指向的情况有哪些</h2><p>事件绑定中的 this<br>普通函数执行中的 this<br>箭头函数执行中的 this<br>构造函数中的 this<br>基于 call&#x2F;apply&#x2F;bind 强制改变中的 this</p>
<h2 id="Null和undefined的区别？"><a href="#Null和undefined的区别？" class="headerlink" title="Null和undefined的区别？"></a>Null和undefined的区别？</h2><p>1、null是JavaScript的关键字，而undefined是JavaScript的一个全局变量，也就是挂载在window对象上的一个变量，并不是关键字。<br>2、在使用typeof运算符进行检测时，Undefined类型的值会返回undefined.而Null类型的值返回为object<br>3、在需要进行字符串类型的转换时，null会转换成字符串null,而undefined会转换字符串undefined.<br>4、在进行数值类型的转换时，undefined会转换为NaN,无法参与计算，而null会转换为0,可以参与计算。<br>undefined +0;&#x2F;&#x2F; NaN<br>null+0 ;&#x2F;&#x2F; 0<br>5、建议：无论在什么情况下都没有必要将一个变量显示的赋值为undefined。如果需要定义某个变量来保存将来要使用的对象，应该将其初始化为null.</p>
<h2 id="Call、apply、bind的区别？"><a href="#Call、apply、bind的区别？" class="headerlink" title="Call、apply、bind的区别？"></a>Call、apply、bind的区别？</h2><p>call是一个方法,是函数的方法<br>call可以调用函数,call可以改变函数中this的指向</p>
<p>call和apply<br>相同点:都会调用函数<br>不同点:传参的方式不同,call传参时一直往后加参数,apply传参数是以数组的形式传参</p>
<p>call和bind<br>相同点:传参的方式一样<br>不同点:call会调用函数,bind不会调用函数,它会作为一个返回值返回一个函数,然后才可以调用</p>
<h2 id="DOCtype-document-type-的作用"><a href="#DOCtype-document-type-的作用" class="headerlink" title="DOCtype(document type)的作用"></a>DOCtype(document type)的作用</h2><ul>
<li>DOCTYPE是document type (文档类型) 的缩写。</li>
<li><strong>用于告诉浏览器该以什么文档标准去解析这个文档</strong></li>
<li>主要作用是告诉浏览器的解析器使用哪种HTML规范或者XHTML规范来解析页面。</li>
</ul>
<h2 id="JS语言主要分哪几部分-三部分"><a href="#JS语言主要分哪几部分-三部分" class="headerlink" title="JS语言主要分哪几部分 三部分"></a>JS语言主要分哪几部分 三部分</h2><ul>
<li>ECMAscript 提供核心语言功能</li>
<li>Dom 文档对象模型，提供访问和操作网页内容的方法和接口</li>
<li>Bom 浏览器对象模型，提供与浏览器交互的方法和接口</li>
</ul>
<h2 id="原型对象、实例对象、构造函数三者之间的关系"><a href="#原型对象、实例对象、构造函数三者之间的关系" class="headerlink" title="原型对象、实例对象、构造函数三者之间的关系"></a>原型对象、实例对象、构造函数三者之间的关系</h2><pre><code>  实例是由new构造函数生成;
  原型是构造函数的prototype,构造函数原型上的constructor属性,是构造函数本身;
实例的_proto_属性,指向构造函数原型
</code></pre>
<h2 id="判断对象自身是否包含此属性"><a href="#判断对象自身是否包含此属性" class="headerlink" title="判断对象自身是否包含此属性"></a>判断对象自身是否包含此属性</h2><ul>
<li>console.log(boj1.hasOwnProperty(‘age’))</li>
</ul>
<h2 id="认识函数"><a href="#认识函数" class="headerlink" title="认识函数"></a>认识函数</h2><ul>
<li>函数内部定义函数：闭包</li>
<li>函数内部调用其他函数：函数调用</li>
<li>函数内部调用参数传过来的函数：回调函数</li>
<li>函数内部调用自己这个函数：递归</li>
</ul>
<h2 id="JavaScript数组常用方法有哪些？"><a href="#JavaScript数组常用方法有哪些？" class="headerlink" title="JavaScript数组常用方法有哪些？"></a>JavaScript数组常用方法有哪些？</h2><p>1、push：在数组末尾添加一个或者多个元素 返回新数组的长度<br>2、pop：移除并返回数组末尾的元素<br>3、unShift：在数组头部添加一个或多个元素 返回新数组的长度<br>4、shift：移除并返回数组头部的元素<br>5、concat：合并两个或者多个数组 并返回合并后的新数组 该方法不会影响原数组<br>6、slice：从数组的指定位置截取元素，返回一个新数组，不会影响原始数组<br>7、splice：从数组指定位置删除或替换元素，可修改原始数组<br>8、indexOf：查找指定元素在数组的索引位置，如果没找到返回-1<br>9、lastIndexOf：从数组尾部查找指定元素的索引位置，如果没找到返回-1<br>10、includes：查找数组中是否有指定元素，返回布尔值<br>11、json：数组转字符串，并用指定分隔符连接它们<br>12、reverse：反转数组，影响原始数组<br>13、sort：数组排序，默认根据字母顺序排列，会修改原始数组<br>14、forEach：对数组每一个元素执行提供的函数<br>15、filter：遍历数组 返回所有符合条件的元素<br>16、map：创建一个新数组，其中包含对数组中的每一个元素操作后的结果<br>17、reduce：将数组中的元素进行累积操作，返回一个单一值<br>18、some：遍历数组 判断数组中是否有符合条件的元素 返回布尔值<br>19、every：遍历数组，判断数组中元素是否都符合条件 返回布尔值<br>20、find：遍历数组，返回第一个符合条件的元素本身</p>
<h2 id="导致JavaScript中this指向混乱的原因是什么"><a href="#导致JavaScript中this指向混乱的原因是什么" class="headerlink" title="导致JavaScript中this指向混乱的原因是什么"></a>导致JavaScript中this指向混乱的原因是什么</h2><p>在js中this的指向是动态的 也就是this指向会根据上下文的环境变化而发生变化 导致他的指向变得混乱或难以预测。常用的导致this指向混乱的原因包括一下几个方面：</p>
<h6 id="1、函数调用方式不同："><a href="#1、函数调用方式不同：" class="headerlink" title="1、函数调用方式不同："></a>1、函数调用方式不同：</h6><ul>
<li>当一个函数被调用时，它的this指向取决于调用方式，如果使用普通函数调用方式（如fn()），则this会指向全局对象window，如果是方法调用（如obj.fn()）则this指向调用该方法的对象</li>
</ul>
<h6 id="2、箭头函数的使用："><a href="#2、箭头函数的使用：" class="headerlink" title="2、箭头函数的使用："></a>2、箭头函数的使用：</h6><ul>
<li>箭头函数不具有自己的this值，他会捕获上下文中的this值，因此，如果在箭头函数中访问this，它会指向外层作用域中的this值</li>
</ul>
<h6 id="3、使用apply、call、bind方法"><a href="#3、使用apply、call、bind方法" class="headerlink" title="3、使用apply、call、bind方法"></a>3、使用apply、call、bind方法</h6><ul>
<li>apply、call、bind方法都可以改变this指向，其中apply、call方法可以立即执行函数并传入参数，而bind方法可以返回一个新函数，该函数的this值被绑定到指定对象上</li>
</ul>
<h6 id="4、对象的嵌套和继承："><a href="#4、对象的嵌套和继承：" class="headerlink" title="4、对象的嵌套和继承："></a>4、对象的嵌套和继承：</h6><ul>
<li>当一个对象被嵌套在另一个对象中或者使用继承时，this的指向可能变得混乱。这是因为this的指向取决于函数被调用时的上下文环境，而不是对象本身，因此，在嵌套对象或继承类中使用this时需要特别注意他的指向</li>
</ul>
<h2 id="怎么实现虚拟列表"><a href="#怎么实现虚拟列表" class="headerlink" title="怎么实现虚拟列表"></a>怎么实现虚拟列表</h2><ul>
<li>虚拟列表是一种优化长列表渲染性能的技术，他只渲染可视化区域内的内容，从而降低了页面渲染的复杂度</li>
<li>具体而言，实现虚拟列表需要以下几个步骤<br>1、计算可视化区域：首先计算出可见区域内的列表数量和位置<br>2、渲染可见区域：只渲染可见区域内的内容，而不是整个列表<br>3、动态调整列表高度：由于只渲染了部分列表项，因此需要动态调整列表容器的高度，确保滚动条可以正确显示并且用户可以滚动整个列表<br>4、延迟加载非可见区域：当用户滚动列表的时，需要根据当前滚动条0位置动态加载，非可见区域的列表项，以便在用户滚动到该区域是能够及时显示.</li>
</ul>
<h2 id="说说对轮询的理解"><a href="#说说对轮询的理解" class="headerlink" title="说说对轮询的理解"></a>说说对轮询的理解</h2><h6 id="什么是轮询"><a href="#什么是轮询" class="headerlink" title="什么是轮询"></a>什么是轮询</h6><ul>
<li>轮询是指在一定时间内，定时向服务器发送请求，获取最新数据的过程</li>
<li>轮询通常用于从服务器获取实时更新的数据</li>
</ul>
<h6 id="轮询和长轮询有什么区别"><a href="#轮询和长轮询有什么区别" class="headerlink" title="轮询和长轮询有什么区别"></a>轮询和长轮询有什么区别</h6><ul>
<li>轮询是在固定的时间间隔内向服务器发送请求，既是服务器没有数据更新，也会继续发送请求，而长轮询则是发送一个请求，服务器如果没有数据更新，则不会返回，而是一直挂着，直到有数据更新再返回结果</li>
</ul>
<h6 id="前端轮询的实现方法有什么"><a href="#前端轮询的实现方法有什么" class="headerlink" title="前端轮询的实现方法有什么"></a>前端轮询的实现方法有什么</h6><p>有两种：基于定时器的轮询和基于递归的轮询。基于定时器的轮询使用setInterval方法来定时发送请求，基于递归的轮询则使用setTimeout方法来控制下一次请求的时间</p>
<h6 id="轮询有什么缺点"><a href="#轮询有什么缺点" class="headerlink" title="轮询有什么缺点"></a>轮询有什么缺点</h6><ul>
<li>轮询会产生大量的无效请求，浪费宽带和服务器资源，并且对服务器压力比较大，同时在短时间内频繁对服务器发起请求，可能会被服务器视为恶意行为，导致IP被封禁等问题</li>
</ul>
<h6 id="如何避免轮询的缺点"><a href="#如何避免轮询的缺点" class="headerlink" title="如何避免轮询的缺点"></a>如何避免轮询的缺点</h6><ul>
<li>可以使用webSocket和SSE等技术来实现实时数据更新<br>  WebSocket是一种双向通信协议，能够实现服务器与客户端之间的实时通信。<br>  而SSE是一种基于HTTP的单向通信协议，可以实现服务器向客户端推送实时数据。</li>
<li>这些技术都能够减少无效请求，提高数据传输效率，并且对服务器资源的消耗也比较小</li>
</ul>
<h2 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul>
<li><p>作用域，即变量（变量作用域又称上下文）和函数生效（能被访问）的区域或集合</p>
</li>
<li><p>换句话说：作用域决定了代码区块中变量和其他资源的可见性</p>
</li>
<li><p>我们一般将作用域分为：<br>  全局作用域<br>  局部作用域<br>  块级作用域</p>
</li>
</ul>
<h6 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h6><ul>
<li>不在任何函数中和大括号中的变量 我们都视为全局作用域，全局作用域下的变量可以在任意位置访问到</li>
</ul>
<h6 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h6><p>函数作用域也称局部作用域 如果一个变量在函数内部声明，那么这个变量只能在这个函数体内部才能被访问到，函数外是访问不到的</p>
<h6 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h6><p>ES6中引入let和const关键字，和var关键字不同的是，在大括号中使用let和const声明的变量存在于块级作用域，在大括号外是访问不到的</p>
<h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><ul>
<li>又叫静态作用域，变量被创建时就确定好了，JavaScript就是遵循的词法作用域</li>
<li>相同层级的两个函数没有办法访问打彼此作用域中的变量</li>
</ul>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><ul>
<li>当js中使用一个变量时，首先js引擎会在当前作用域下去查找，如果没找到，则会去它的上层作用域查找，依次类推直到找到该变量或者找到了全局作用域</li>
<li>如果在全局作用域找不到，在非严格模式下回隐式声明该变量，严格模式直接报错</li>
</ul>
<h2 id="ES6有哪些新特性"><a href="#ES6有哪些新特性" class="headerlink" title="ES6有哪些新特性"></a>ES6有哪些新特性</h2><h3 id="1、let、const-块级作用域以及和-var-的区别"><a href="#1、let、const-块级作用域以及和-var-的区别" class="headerlink" title="1、let、const 块级作用域以及和 var 的区别"></a>1、let、const 块级作用域以及和 var 的区别</h3><p>声明方式	变量提升	作用域	初始值	重复定义<br>var			  是	   函数级  不需要	允许<br>let			  否	    块级   不需要  不允许<br>const		  否		块级	必需   不允许</p>
<h3 id="2、解构-快速提取数组-对象中的元素"><a href="#2、解构-快速提取数组-对象中的元素" class="headerlink" title="2、解构-快速提取数组&#x2F;对象中的元素"></a>2、解构-快速提取数组&#x2F;对象中的元素</h3><h6 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h6><ul>
<li><p>单独解构-根据数组索引，将数组解构成单独的元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> [a, b, c] = arr</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c) <span class="comment">//1,2,3</span></span><br><span class="line"><span class="keyword">const</span> [, , d] = arr</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d) <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>默认值，解构时可以给变量设置默认值，数组没有这个元素的话</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> [, , , defaultVal = <span class="string">&#x27;4&#x27;</span>] = arr</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;设置默认值&#x27;</span>, defaultVal)</span><br></pre></td></tr></table></figure>
</li>
<li><p>剩余解构用 “…+变量名” 解构剩余参数到新数组，只能用一次</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> [e, ...rest] = arr</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rest) <span class="comment">//[2, 3]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h6><ul>
<li><p>单个&#x2F;多个解构-跟数组解构差不多</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;zzm&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">height</span>: <span class="literal">undefined</span> &#125;</span><br><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = obj</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name, age) <span class="comment">// &#x27;zzm&#x27;, 18</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解构+重命名-给解构出来的变量重命名</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;zzm&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">height</span>: <span class="literal">undefined</span> &#125;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">name</span>: objName &#125; = obj</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objName)</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认值-给解构变量设置默认值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;zzm&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">height</span>: <span class="literal">undefined</span> &#125;</span><br><span class="line"><span class="keyword">const</span> &#123; next = <span class="string">&#x27;default&#x27;</span> &#125; = obj</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(next)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3、模板字符串"><a href="#3、模板字符串" class="headerlink" title="3、模板字符串"></a>3、模板字符串</h3><p>用法：使用&#96;&#96;将字符串包裹起来<br>功能：可以换行、插值、使用标签函数进行字符串操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//换行</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">`fdsjak</span></span><br><span class="line"><span class="string">    fdsa`</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str)</span><br><span class="line"><span class="comment">// 插值</span></span><br><span class="line"><span class="keyword">const</span> strs = <span class="string">`random: <span class="subst">$&#123;<span class="built_in">Math</span>.random()&#125;</span>`</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(strs)</span><br></pre></td></tr></table></figure>

<h3 id="4、字符串扩展方法"><a href="#4、字符串扩展方法" class="headerlink" title="4、字符串扩展方法"></a>4、字符串扩展方法</h3><ul>
<li>includes-是否包含</li>
<li>startsWith-是否以什么开始</li>
<li>endsWith-是否以什么结束</li>
</ul>
<h3 id="5、参数默认值-剩余参数"><a href="#5、参数默认值-剩余参数" class="headerlink" title="5、参数默认值&amp;剩余参数"></a>5、参数默认值&amp;剩余参数</h3><ul>
<li>给函数形参设置默认值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带默认参数的形参一般放在后面，减少传参导致的错误几率</span></span><br><span class="line"><span class="keyword">const</span> defaultParams = <span class="keyword">function</span> (<span class="params">name, age = <span class="number">0</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [age, name]</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">defaultParams</span>(<span class="number">1</span>))</span><br></pre></td></tr></table></figure></li>
<li>使用…rest 形式设置剩余形参，支持无限参数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 剩余参数，转化成数组</span></span><br><span class="line"><span class="keyword">const</span> restParams = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(args.<span class="title function_">toString</span>()) <span class="comment">//1, 2, 3, 4, 5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">restParams</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6、展开数组"><a href="#6、展开数组" class="headerlink" title="6、展开数组"></a>6、展开数组</h3><ul>
<li>使用…将数组展开<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...arr)</span><br><span class="line"><span class="comment">// 等价于es5中以下写法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="property">log</span>.<span class="title function_">apply</span>(<span class="variable language_">console</span>, arr)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7、箭头函数"><a href="#7、箭头函数" class="headerlink" title="7、箭头函数"></a>7、箭头函数</h3><h6 id="特性-优势："><a href="#特性-优势：" class="headerlink" title="特性&amp;优势："></a>特性&amp;优势：</h6><ul>
<li>1、简化了函数的写法</li>
<li>2、没有 this 机制，this 继承自上一个函数的上下文，如果上一层没有函数，则指向 window</li>
<li>3、作为异步回调函数时，可解决 this 指向问题</li>
</ul>
<h3 id="8、对象字面量增强"><a href="#8、对象字面量增强" class="headerlink" title="8、对象字面量增强"></a>8、对象字面量增强</h3><ul>
<li>同名属性可以省略 key:value 形式，直接 key，</li>
<li>函数可以省略 key：value 形式</li>
<li>可以直接 func(),</li>
<li>可以使用计算属性，比如：{[Math.random()]: value}</li>
</ul>
<h3 id="9、Object-assign-target1-target2-targetN-复制-合并对象"><a href="#9、Object-assign-target1-target2-targetN-复制-合并对象" class="headerlink" title="9、Object.assign(target1, target2, targetN)-复制&#x2F;合并对象"></a>9、Object.assign(target1, target2, targetN)-复制&#x2F;合并对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Object.assign(target1, target2, ...targetn)</span></span><br><span class="line"><span class="comment"> * 后面的属性向前面的属性合并</span></span><br><span class="line"><span class="comment"> * 如果target1是空对象，可以创建一个全新对象，而不是对象引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj3 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj1)</span><br><span class="line">obj3.<span class="property">a</span> = <span class="number">5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj3, obj2, obj1)</span><br></pre></td></tr></table></figure>

<h3 id="10、Object-is-value1-value2"><a href="#10、Object-is-value1-value2" class="headerlink" title="10、Object.is(value1, value2)"></a>10、Object.is(value1, value2)</h3><ul>
<li>作用：比较两个值是否相等</li>
<li>特性：<br>  没有隐式转换<br>  可以比较+0,-0、NaN<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> === <span class="title class_">NaN</span>) <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>)) <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span> === -<span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="number">0</span>, -<span class="number">0</span>)) <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="number">1</span>, <span class="number">1</span>)) <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="11、Proxy-object-handler"><a href="#11、Proxy-object-handler" class="headerlink" title="11、Proxy(object, handler)"></a>11、Proxy(object, handler)</h3><ul>
<li>作用：<br>  代理一个对象的所有，包括读写操作和各种操作的监听</li>
<li>用法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> P = &#123;</span><br><span class="line">  <span class="attr">n</span>: <span class="string">&#x27;p&#x27;</span>,</span><br><span class="line">  <span class="attr">a</span>: <span class="number">19</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(P, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(target, property)</span><br><span class="line">    <span class="keyword">return</span> property <span class="keyword">in</span> target ? target[property] : <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">defineProperty</span>(<span class="params">target, property, attrs</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(target, property, attrs)</span><br><span class="line">    <span class="comment">//   throw new Error(&#x27;不允许修改&#x27;)</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">deleteProperty</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(target, property)</span><br><span class="line">    <span class="keyword">delete</span> target[property]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, property, value</span>) &#123;</span><br><span class="line">    target[property] = value</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">c</span> = <span class="number">100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;pp&#x27;</span>, P)</span><br></pre></td></tr></table></figure></li>
<li>与 Object.defineProperty  对比</li>
<li>优势：<br>  拥有很多 defineProperty 没有的属性方法<br>  对数组的监视更方便<br>  以非侵入的访视监管对象的读写</li>
</ul>
<h3 id="12-Reflect"><a href="#12-Reflect" class="headerlink" title="12.Reflect"></a>12.Reflect</h3><ul>
<li>作用：<br>  用于对对象的统一操作，集成 Object 相关的所有方法</li>
</ul>
<h3 id="13-Promise"><a href="#13-Promise" class="headerlink" title="13.Promise"></a>13.Promise</h3><ul>
<li>作用：解决异步编程中回调嵌套过深问题</li>
</ul>
<h3 id="14-class-静态方法-继承"><a href="#14-class-静态方法-继承" class="headerlink" title="14.class&amp;静态方法&amp;继承"></a>14.class&amp;静态方法&amp;继承</h3><h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6><ul>
<li>使用 class 关键字定义类<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    	<span class="variable language_">this</span>.<span class="property">props</span> = props</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h6><ul>
<li>实例方法，需要实例化之后才能调用，this 指向实例</li>
<li>静态方法，用 static 修饰符修饰，可以直接通过类名调用，不需要实例化，this 不指向实例，而是指向当前类<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span> = props</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实例方法</span></span><br><span class="line">	<span class="title function_">eat</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="comment">// 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">run</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用静态方法</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">run</span>()</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;props&#x27;</span>)</span><br><span class="line"><span class="comment">// 调用实例方法</span></span><br><span class="line">person.<span class="title function_">eat</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="继承：子类使用-extends-关键字实现继承，可以继承父类所有属性"><a href="#继承：子类使用-extends-关键字实现继承，可以继承父类所有属性" class="headerlink" title="继承：子类使用 extends 关键字实现继承，可以继承父类所有属性"></a>继承：子类使用 extends 关键字实现继承，可以继承父类所有属性</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">printProps</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">props</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> student = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;student&#x27;</span>)</span><br><span class="line">student.<span class="title function_">printProps</span>()</span><br></pre></td></tr></table></figure>

<h3 id="15-Set"><a href="#15-Set" class="headerlink" title="15.Set"></a>15.Set</h3><h6 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h6><ul>
<li>Set 是一种类似于数组的数据结构</li>
</ul>
<h6 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h6><ul>
<li>元素唯一性，不允许重复元素</li>
<li>使用 add 增加重复元素，将会被忽略</li>
</ul>
<h6 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h6><ul>
<li>数组去重</li>
<li>数据存储<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>(arr)</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">1</span>).<span class="title function_">add</span>(<span class="number">1</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="property">size</span>) <span class="comment">//2</span></span><br><span class="line"><span class="keyword">const</span> newArr = <span class="title class_">Array</span>.<span class="title function_">from</span>(set)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr) <span class="comment">//[ 1, 3 ]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="16-Map"><a href="#16-Map" class="headerlink" title="16.Map"></a>16.Map</h3><h6 id="说明：-1"><a href="#说明：-1" class="headerlink" title="说明："></a>说明：</h6><ul>
<li>类似 Object，以 key、value 形式存储数据</li>
</ul>
<h6 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h6><ul>
<li>Map 键不会隐式转换成字符串，而是保持原有类型</li>
</ul>
<h6 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;map&#x27;</span>)</span><br><span class="line">map.<span class="title function_">set</span>(obj, obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(<span class="number">1</span>)) <span class="comment">//1</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    1 1</span></span><br><span class="line"><span class="comment">    name map</span></span><br><span class="line"><span class="comment">    &#123; &#x27;1&#x27;: 1, true: true, a: &#x27;a&#x27; &#125; &#123; &#x27;1&#x27;: 1, true: true, a: &#x27;a&#x27; &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">map.<span class="title function_">forEach</span>(<span class="function">(<span class="params">val, key</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(key, val)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="17-Symbol"><a href="#17-Symbol" class="headerlink" title="17.Symbol"></a>17.Symbol</h3><h6 id="说明：-2"><a href="#说明：-2" class="headerlink" title="说明："></a>说明：</h6><ul>
<li>JavaScript 第六种原始数据类型，用来定义一个唯一的变量</li>
</ul>
<h6 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h6><ul>
<li><p>创建唯一的变量，解决对象键名重复问题</p>
</li>
<li><p>为对象、类、函数等创建私有属性</p>
</li>
<li><p>修改对象的 toString 标签</p>
</li>
<li><p>为对象添加迭代器属性</p>
</li>
<li><p>如何获取对象的 symbol 属性？<br>  Object.getOwnPropertySymbols(object)</p>
</li>
<li><p>实例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象属性重名问题；</span></span><br><span class="line"><span class="keyword">const</span> objSymbol = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>()]: <span class="number">1</span>,</span><br><span class="line">  [<span class="title class_">Symbol</span>()]: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objSymbol)</span><br><span class="line"><span class="comment">// 2、为对象、类、函数等创建私有属性</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  [name]: <span class="string">&#x27;symbol&#x27;</span>,</span><br><span class="line">  <span class="title function_">testPrivate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>[name])</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj2.<span class="title function_">testPrivate</span>()</span><br><span class="line"><span class="comment">// 定义toString标签；</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="title function_">toString</span>())</span><br><span class="line">obj2[<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>] = <span class="string">&#x27;xx&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="title function_">toString</span>()) <span class="comment">//[object xx]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="18-for…of…"><a href="#18-for…of…" class="headerlink" title="18.for…of…"></a>18.for…of…</h3><h6 id="用途：-1"><a href="#用途：-1" class="headerlink" title="用途："></a>用途：</h6><ul>
<li>已统一的方式，遍历所有引用数据类型</li>
</ul>
<h6 id="特性：-1"><a href="#特性：-1" class="headerlink" title="特性："></a>特性：</h6><ul>
<li>可以随时使用 break 终止遍历，而 forEach 不行</li>
</ul>
<h6 id="实例：-1"><a href="#实例：-1" class="headerlink" title="实例："></a>实例：</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本用法</span></span><br><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="keyword">if</span> (item &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (item &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历set</span></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">set.<span class="title function_">add</span>(<span class="string">&#x27;foo&#x27;</span>).<span class="title function_">add</span>(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> set) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set for of&#x27;</span>, item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历map</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;one&#x27;</span>).<span class="title function_">set</span>(<span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;two&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, val] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;for of map&#x27;</span>, key, val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代对象</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xiaohui&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="string">&#x27;10&#x27;</span>,</span><br><span class="line">  <span class="attr">store</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  <span class="comment">// 实现可迭代的接口</span></span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> params = [<span class="variable language_">this</span>.<span class="property">name</span>, <span class="variable language_">this</span>.<span class="property">age</span>, <span class="variable language_">this</span>.<span class="property">store</span>]</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> ret = &#123;</span><br><span class="line">          <span class="attr">value</span>: params[index],</span><br><span class="line">          <span class="attr">done</span>: index &gt;= params.<span class="property">length</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        index++</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> obj) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj for of&#x27;</span>, item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-迭代器模式"><a href="#19-迭代器模式" class="headerlink" title="19. 迭代器模式"></a>19. 迭代器模式</h3><h6 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a>作用：</h6><ul>
<li>通过 Symbol.interator 对外提供统一的接口，获取内部的数据</li>
</ul>
<h6 id="外部可以通过-for…of…去迭代内部的数据"><a href="#外部可以通过-for…of…去迭代内部的数据" class="headerlink" title="外部可以通过 for…of…去迭代内部的数据"></a>外部可以通过 for…of…去迭代内部的数据</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tods = &#123;</span><br><span class="line">  <span class="attr">life</span>: [<span class="string">&#x27;eat&#x27;</span>, <span class="string">&#x27;sleep&#x27;</span>],</span><br><span class="line">  <span class="attr">learn</span>: [<span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;dart&#x27;</span>],</span><br><span class="line">  <span class="comment">// 增加的任务</span></span><br><span class="line">  <span class="attr">work</span>: [<span class="string">&#x27;sale&#x27;</span>, <span class="string">&#x27;customer&#x27;</span>],</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> all = []</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">      all.<span class="title function_">push</span>(...<span class="variable language_">this</span>[key])</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> ret = &#123;</span><br><span class="line">          <span class="attr">value</span>: all[index],</span><br><span class="line">          <span class="attr">done</span>: index &gt;= all.<span class="property">length</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        index++</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> tods) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20、Generator函数"><a href="#20、Generator函数" class="headerlink" title="20、Generator函数"></a>20、Generator函数</h3><ul>
<li>函数前添加 *，生成一个生成器</li>
<li>一般配合 yield 关键字使用</li>
<li>最大特点，惰性执行，调 next 才会往下执行</li>
<li>主要用来解决异步回调过深的问题<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">yield</span> <span class="number">2</span>); <span class="comment">// undefined</span></span><br><span class="line">		<span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">let</span> ge=<span class="title function_">gen</span>() <span class="comment">//返回一个遍历器对象</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(ge.<span class="title function_">next</span>()) <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(ge.<span class="title function_">next</span>()) <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(ge.<span class="title function_">next</span>()) <span class="comment">//  &#123;value: 3, done: false&#125;</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(ge.<span class="title function_">next</span>()) <span class="comment">//  &#123;value: 4, done: true&#125;</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(ge.<span class="title function_">next</span>()) <span class="comment">// &#123;value: undefined , done: true&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="21-includes-函数-es2016"><a href="#21-includes-函数-es2016" class="headerlink" title="21.includes 函数-es2016"></a>21.includes 函数-es2016</h3><ul>
<li>判断数组是否包含某个元素，包含 NaN，解决 indexOf 无法查找 NaN 问题<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  includes函数</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>, <span class="title class_">NaN</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">includes</span>(<span class="title class_">NaN</span>)) <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">indexOf</span>(<span class="title class_">NaN</span>)) <span class="comment">//-1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="22-运算符-es2016"><a href="#22-运算符-es2016" class="headerlink" title="22. 运算符-es2016"></a>22. 运算符-es2016</h3><ul>
<li>指数运算<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指数运算符 **</span></span><br><span class="line"><span class="comment">// es5中2十次方</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>, <span class="number">10</span>))</span><br><span class="line"><span class="comment">// es6中2十次方</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span> ** <span class="number">10</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="23-values-函数-es2017"><a href="#23-values-函数-es2017" class="headerlink" title="23.values 函数-es2017"></a>23.values 函数-es2017</h3><ul>
<li>将对象的值以数组的形式返回<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	<span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">	<span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">	<span class="attr">baz</span>: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(obj)) <span class="comment">//[ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="24-entries-函数-es2017"><a href="#24-entries-函数-es2017" class="headerlink" title="24.entries 函数-es2017"></a>24.entries 函数-es2017</h3><ul>
<li>将对象以键值对二维数组返回，使之可以使用 for…of…遍历<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	<span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">	<span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">	<span class="attr">baz</span>: <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj))</span><br><span class="line"><span class="keyword">const</span> entry = <span class="title class_">Object</span>.<span class="title function_">entries</span>(obj)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> entry) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="25-Object-getOwnPropertyDescriptors-obj-es2017"><a href="#25-Object-getOwnPropertyDescriptors-obj-es2017" class="headerlink" title="25.Object.getOwnPropertyDescriptors(obj)-es2017"></a>25.Object.getOwnPropertyDescriptors(obj)-es2017</h3><ul>
<li>获取对象的描述信息</li>
<li>可以通过获得的描述信息，配合 Object.defineProperties 来完整复制对象，包含 get，set 方法<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getOwnPropertyDescriptors</span></span><br><span class="line"><span class="comment">// 普通get方法</span></span><br><span class="line"><span class="keyword">const</span> objGet = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">getCount</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">foo</span> + <span class="variable language_">this</span>.<span class="property">bar</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// assign方法会把getCount当做普通属性复制，从而getCount为3，修改bar不管用</span></span><br><span class="line"><span class="keyword">const</span> objGet1 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, objGet)</span><br><span class="line">objGet1.<span class="property">bar</span> = <span class="number">3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objGet1.<span class="property">getCount</span>) <span class="comment">//3</span></span><br><span class="line"><span class="comment">// descriptors</span></span><br><span class="line"><span class="keyword">const</span> descriptors = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(objGet)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;des&#x27;</span>, descriptors)</span><br><span class="line"><span class="comment">// 通过descriptors来复制对象，可以完整复制对象，包含get，set</span></span><br><span class="line"><span class="keyword">const</span> objGet2 = <span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(&#123;&#125;, descriptors)</span><br><span class="line">objGet2.<span class="property">bar</span> = <span class="number">3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objGet2.<span class="property">getCount</span>) <span class="comment">//4</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="26-padStart-padEnd-函数-es2017"><a href="#26-padStart-padEnd-函数-es2017" class="headerlink" title="26.padStart, padEnd 函数-es2017"></a>26.padStart, padEnd 函数-es2017</h3><ul>
<li>在字符串前，或者后面追加指定字符串</li>
</ul>
<h6 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h6><ul>
<li>targetLenght: 填充后的目标长度</li>
<li>padString:填充的字符串</li>
</ul>
<h6 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h6><p>1、填充的字符串超过目标长度，会在规定长度时被截断<br>2、填充字符串太短会以空格填充<br>3、padString 未传值，以空格填充</p>
<h6 id="作用：-2"><a href="#作用：-2" class="headerlink" title="作用："></a>作用：</h6><ul>
<li>一般用来对齐字符串输出<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	foo.................|1</span></span><br><span class="line"><span class="comment">	barbar..............|2</span></span><br><span class="line"><span class="comment">	bazbazbaz...........|3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key.padEnd(<span class="number">20</span>, <span class="string">&#x27;.&#x27;</span>)&#125;</span><span class="subst">$&#123;value.toString().padStart(<span class="number">2</span>, <span class="string">&#x27;|&#x27;</span>)&#125;</span>`</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>主要编程范式有三种：命令式编程、声明式编程、函数式编程</p>
<ul>
<li>简单来说，函数式编程就是把过程逻辑写成函数，定义好输入参数，只关心他的输出结果</li>
</ul>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>纯函数  就是一个函数的返回结果只依赖于它的参数，并且在执行过程中没有副作用，我们就把这个函数叫做纯函数。</li>
<li>高阶函数 就是以函数作为输入或者输出的函数被称为高阶函数</li>
<li>柯里化函数 柯里化是把一个多参数函数转化成一个嵌套的一元函数的过程</li>
<li>组合与管道 组合函数，目的是将多个函数组合成一个函数</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ul>
<li>更好的管理状态：因为他的宗旨是无状态，或者说更少的状态，能最大化的减少这些未知、优化代码、减少出错情况</li>
<li>更简单的复用：固定输入-&gt;固定输出，没有其他外部变量影响，并且无副作用，这样的代码复用时，完全不需要考虑他的内部实现和外部影响</li>
<li>更优雅的组合：往大了说，网页是由各个组件组成的。往小了说，一个函数也可能由多个小函数组成的。更强的复用性，带来更强大的组合</li>
<li>隐性好处。减少代码量，提高维护性</li>
</ul>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><ul>
<li>性能：函数式编程相对于指令式编程，性能绝对是一个短板，因为他往往对一个方法过度包装，从而产生上下文切换的性能开销</li>
<li>资源占用：在js中为了实现对象状态不可变，往往会创建新的对象，因此，他对垃圾回收所产生的压力远远超过其他编程方式</li>
<li>递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作</li>
</ul>
<h2 id="cookie、localStorage和sessionStorage-三者之间有什么区别"><a href="#cookie、localStorage和sessionStorage-三者之间有什么区别" class="headerlink" title="cookie、localStorage和sessionStorage 三者之间有什么区别"></a>cookie、localStorage和sessionStorage 三者之间有什么区别</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li>cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效</li>
<li>localStorage：除非手动删除，否则将会永久保存</li>
<li>sessionStorage：仅在当前网页会话下有效，关闭页面或浏览器后就会被清除</li>
</ul>
<h3 id="存放数据大小"><a href="#存放数据大小" class="headerlink" title="存放数据大小"></a>存放数据大小</h3><ul>
<li>cookie：4KB左右</li>
<li>localStorage和sessionStorage：可以保存5MB的信息</li>
</ul>
<h3 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h3><ul>
<li>cookie：需要程序员自己封装，原生的cookieAPI不友好</li>
<li>localStorage和sessionStorage：原生的API可以接受，亦可再次封装来对object和array有更好的支持</li>
</ul>
<h2 id="浏览器有哪几种缓存，各种缓存的优先级是什么样的？"><a href="#浏览器有哪几种缓存，各种缓存的优先级是什么样的？" class="headerlink" title="浏览器有哪几种缓存，各种缓存的优先级是什么样的？"></a>浏览器有哪几种缓存，各种缓存的优先级是什么样的？</h2><h3 id="强制缓存："><a href="#强制缓存：" class="headerlink" title="强制缓存："></a>强制缓存：</h3><p>1、浏览器发送HTTP请求<br>2、服务器返回HTTP响应（响应头中的缓存标识：cache-Control(http1.1)、Expires(http1.0)）<br>    - Cache-Control：max-age&#x3D;300，响应内容浏览器本地缓存300秒，缓存时间内再次加载资源，就会命中强缓存<br>    - Expires：Wed,26 Jul 2023 15:50:40 GMT，失效具体时间（2023年7月26日星期三15:50:40 GMT）,缓存时间内再次加载资源，就会命中强缓存<br>    - 同时设置Cache-Control和Expires，Cache-Control优先级更高<br>3、浏览器再次发送相同HTTP请求<br>4、不会再进过服务器，直接从浏览器本地缓存拿出进行返回</p>
<h3 id="协商缓存："><a href="#协商缓存：" class="headerlink" title="协商缓存："></a>协商缓存：</h3><p>协商缓存步骤如下：（缓存标识对：Etag&#x2F;If-None-Match(http1.1)、Last-Modified&#x2F;If-Modified-Since(http1.0)）<br>1、浏览器发起HTTP请求<br>2、服务器返回HTTP响应（响应头中的缓存标识：Etag、Last-Modified）<br>    - Etag：”64d452af-70b8”,内容的hash值，只有内容改变了，hash才会变化<br>    - Last-Modified:Thu, 10 Aug 2023 02:59:59 GMT，修改时间，哪怕内容没有变化，重新保存可能都会导致修改时间变化<br>    - 同时设置Etag和Last-Modified，Etag优先级更高<br>3、浏览器再次发送相同的HTTP请求（请求头中的缓存标识If-None-Match(http1.1)、If-Modified-Since(http1.0)）<br>4、服务器会检查Etag &#x3D;&#x3D;&#x3D; If-None-Match或者Last-Modified &#x3D;&#x3D;&#x3D; If-Modified-Since是否相等，相等就命中缓存，服务端返回304，从本地缓存中取即可，否则未命中缓存，返回最新的数据和响应头中的缓存标识</p>
<h3 id="Service-Worker-缓存："><a href="#Service-Worker-缓存：" class="headerlink" title="Service Worker 缓存："></a>Service Worker 缓存：</h3><p>Service Worker 是一种特殊的 JS 脚本，可以拦截网络请求并返回缓存的响应，以实现离线访问和更快的加载速度等功能。</p>
<h3 id="Web-Storage-缓存："><a href="#Web-Storage-缓存：" class="headerlink" title="Web Storage 缓存："></a>Web Storage 缓存：</h3><p>包括 localStorage 和 sessionStorage。localStorage 用于存储用户在网站上的永久性数据，而 sessionStorage 则用于存储用户会话过程中的临时数据。</p>
<h3 id="这些缓存的优先级如下："><a href="#这些缓存的优先级如下：" class="headerlink" title="这些缓存的优先级如下："></a>这些缓存的优先级如下：</h3><p>Service Worker 缓存：由于其可以完全控制网络请求，因此具有最高的优先级，即使是强制缓存也可以被它所覆盖。<br>强制缓存：如果存在强制缓存，并且缓存没有过期，则直接使用缓存，不需要向服务器发送请求。<br>协商缓存：如果强制缓存未命中，但协商缓存可用，则会向服务器发送条件请求，询问资源是否更新。如果服务器返回 304 Not Modified 响应，则直接使用缓存。<br>Web Storage 缓存：Web Storage 缓存的优先级最低，只有在网络不可用或者其他缓存都未命中时才会生效。</p>
<h2 id="项目首屏提速"><a href="#项目首屏提速" class="headerlink" title="项目首屏提速"></a>项目首屏提速</h2><ul>
<li>大致可以分两种</li>
</ul>
<h3 id="用户感知提速"><a href="#用户感知提速" class="headerlink" title="用户感知提速"></a>用户感知提速</h3><ul>
<li>因为用户 在很多情况下对于速度的感知是非常主观的，所以说呢，我们可以通过一些加载动画来拖慢用户的这种感知</li>
</ul>
<h3 id="技术加载提速"><a href="#技术加载提速" class="headerlink" title="技术加载提速"></a>技术加载提速</h3><ul>
<li><p>我们可以在服务端通过prerender进行一个预渲染，然后以SSR的形式，完成首页的一个服务端渲染，然后把我们后续的渲染交给CSR客户端去进行渲染，这样的话我们就组成了一种同构渲染的方式，来完成一个渲染的提速</p>
</li>
<li><p>还有一些静态资源的渲染，比如说图片的加载，比如说数据的加载，我们可以借助intersectionObserver来完成一些懒加载的处理</p>
</li>
</ul>
<h2 id="css元素隐藏"><a href="#css元素隐藏" class="headerlink" title="css元素隐藏"></a>css元素隐藏</h2><ul>
<li>1、display:none 渲染树不会渲染对象</li>
<li>2、visibility(v 死 biu 了 踢):hidden 元素在页面内仍占据空间，但是不会响应绑定的监听事件</li>
<li>3、opacity(哦 怕 死 踢):0 元素在页面中仍占据空间 并且能够响应元素绑定的监听事件</li>
<li>4、position:absolute 通过使用绝对定位将元素移除到可视化区域外，来隐藏元素</li>
<li>5、z-index:-9999 使其他元素覆盖给元素</li>
<li>6、transform:scale(si 给 o)(0,0) 将元素缩放为0 元素仍在页面中占据位置 但是不会响应绑定的监听事件</li>
</ul>
<h2 id="css元素居中"><a href="#css元素居中" class="headerlink" title="css元素居中"></a>css元素居中</h2><ul>
<li><p>flex布局设置居中<br>  给容器设置：<br>  display: flex;写在父元素上这就是定义了一个伸缩容器<br>  justify-content 主轴对齐方式，默认是横轴<br>  align-items 纵轴对齐方式，默认是纵轴</p>
</li>
<li><p>绝对定位设置居中<br>  使用绝对定位的方式实现水平垂直居中。<br>  容器设置position: relative。<br>  子元素设置<br>      position:absolute;<br>      left:50%;<br>      top:50%;<br>      transform:translate(-50%,-50%);</p>
</li>
<li><p>绝对定位设置居中<br>  使用绝对定位的方式实现水平垂直居中。<br>  容器设置position: relative。<br>  子元素设置<br>      position:absolute;<br>      width:300px;<br>      height:300px;<br>      margin-left:-150px &#x2F;&#x2F; 盒子宽的一半<br>      margin-top:-150px &#x2F;&#x2F; 盒子高的一半</p>
</li>
<li><p>还有一种奇葩的方法<br>  这个奇葩方式和使用绝对定位相似，<br>  容器设置position: relative。<br>  子元素设置<br>      position: absolute;<br>      设置固定宽度和高度<br>      top、left、bottom、right都设置为0;<br>      margin设置为auto；<br>      也能实现垂直水平居中。</p>
</li>
</ul>
<h2 id="em和rem的区别"><a href="#em和rem的区别" class="headerlink" title="em和rem的区别"></a>em和rem的区别</h2><h6 id="em"><a href="#em" class="headerlink" title="em"></a>em</h6><ul>
<li>是一个相对单位，相对于当前父级文本的font-size，如果当前文字的字体尺寸没有设置，则相对于浏览器的默认字体尺寸，即1em&#x3D;16px<br>  特点：<br>  1、em的值并不是固定的<br>  2、em会继承父元素的字体大小</li>
</ul>
<h6 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h6><ul>
<li>是相对单位，是相对HTML根元素，比如HTML标签设置font-size：100px；那么1rem就相当于100px<br>  特点：<br>  1、rem为元素设定字体大小的时候，是相对于根元素进行计算的<br>  2、当我改变根元素下的字体大小时，下面的大小都会改变<br>  3、通过rem既可以做的只修改根元素就可以成比例的调整所以字体，又可以避免字体大小逐层复合的连锁反应</li>
</ul>
<h2 id="HTTP1-0和HTTP2-0的区别"><a href="#HTTP1-0和HTTP2-0的区别" class="headerlink" title="HTTP1.0和HTTP2.0的区别"></a>HTTP1.0和HTTP2.0的区别</h2><h6 id="1、连接复用"><a href="#1、连接复用" class="headerlink" title="1、连接复用"></a>1、连接复用</h6><ul>
<li>HTTP1.0：每个HTTP请求都需要建立一个新的TCP连接，请求结束后立即关闭连接，这样的方式会导致每个请求都需要重新建立连接，增加了延迟和开销</li>
<li>HTTP2.0：引入了多路复用技术，允许在同一个TCP连接上发送多个请求和响应，避免了建立和关闭多个连接的开销，提高了性能和效率</li>
</ul>
<h6 id="2、请求-响应方式"><a href="#2、请求-响应方式" class="headerlink" title="2、请求-响应方式"></a>2、请求-响应方式</h6><ul>
<li>HTTP1.0：采用的是单向请求-响应模式，即每个请求只能对应一个响应，请求和响应是一一对应的</li>
<li>HTTP2.0：引入了Server Push机制，服务器可以在客户端请求之前主动推送相关资源，避免了客户端重复请求的等待事件，提高了页面加载速度</li>
</ul>
<h6 id="3、头部压缩"><a href="#3、头部压缩" class="headerlink" title="3、头部压缩"></a>3、头部压缩</h6><ul>
<li>HTTP1.0：每个请求和响应的头部都包含大量的重复信息，造成了较大的网络传输开销</li>
<li>HTTP2.0：使用HPACK算法对头部进行压缩，减少了头部的大小，降低了网络传输开销</li>
</ul>
<h6 id="4、二进制协议"><a href="#4、二进制协议" class="headerlink" title="4、二进制协议"></a>4、二进制协议</h6><ul>
<li>HTTP1.0：采用文本形式进行数据传输，易于阅读和调试，但是传输效率较低</li>
<li>HTTP2.0：采用二进制格式传输数据，减少了解析的复杂性，提高了传输效率</li>
</ul>
<h6 id="5、流控制和优先级"><a href="#5、流控制和优先级" class="headerlink" title="5、流控制和优先级"></a>5、流控制和优先级</h6><ul>
<li>HTTP1.0：没有流控制和优先级的概念，所有请求头都是按照发生的顺序进行处理</li>
<li>HTTP2.0：引入了流控制和优先级的机制，可以根据需求对请求进行优先级排序和流量控制，确保重要请求的及时处理</li>
</ul>
<h6 id="6、长连接支持"><a href="#6、长连接支持" class="headerlink" title="6、长连接支持"></a>6、长连接支持</h6><ul>
<li>HTTP1.0：基本都是短连接，每个请求响应完成之后立即关闭连接</li>
<li>HTTP2.0：支持长连接，即一个TCP连接可以承载多个请求和响应，减少连接的建立和关闭次数，提高了性能</li>
</ul>
<h2 id="（DFS）深度优先搜索算法"><a href="#（DFS）深度优先搜索算法" class="headerlink" title="（DFS）深度优先搜索算法"></a>（DFS）深度优先搜索算法</h2><ul>
<li>其过程为沿着每一个可能的路径向下进行搜索，直到不能再深入为止，并且每一个节点只能访问一次。</li>
</ul>
<h2 id="BFS（宽度优先算法）"><a href="#BFS（宽度优先算法）" class="headerlink" title="BFS（宽度优先算法）"></a>BFS（宽度优先算法）</h2><ul>
<li>它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。简单来说，bfs好像是一个耳听六路眼观八方的人</li>
</ul>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul>
<li>原理：<br>  相邻的数据进行两两比较，小数放在前面，大数放在后面，这样一趟下来，最小的数就被排在了第一位，第二趟也是如此，如此类推，直到所有的数据排序完成。</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul>
<li>原理：<br>  选择数组中的一个值作为基准，将数组中小于该值的数置于该数之前，大于该值的数置于该数之后，接着对该数前后的两个数组进行重复操作直至排序完成。</li>
</ul>
<h2 id="JavaScript中常见的数据结构"><a href="#JavaScript中常见的数据结构" class="headerlink" title="JavaScript中常见的数据结构"></a>JavaScript中常见的数据结构</h2><h6 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue 队列"></a>Queue 队列</h6><ul>
<li>队列是一个先进先出的数据结构，一般JavaScript中采用队列解决问题时会用到<br>  入队push ()：在数组的尾部添加元素<br>  出队shift ()：移除数组中第一个元素<br>  queue (0) ：取数组的第一个元素<br>  isEmpty ()：确定队列是否为空<br>  size ()：获取队列中元素的数量</li>
</ul>
<h6 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack 栈"></a>Stack 栈</h6><ul>
<li>栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进⬇后出⬆的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。</li>
</ul>
<p>JavaScript中没有栈，但是可以用Array实现栈的功能。<br>栈中数组长度减一即为栈尾元素，也就是最后进入的那个元素，最先出去的那个元素<br>JavaScript中对栈的操作一般会使用到<br>    push()方法，将元素压入栈顶<br>    pop()方法，从栈顶弹出（删除）元素，并返回该元素<br>    peek()方法，返回栈顶元素，不删除<br>    clear()方法，清空栈<br>    length拿到栈中元素数量</p>
<h6 id="Linked-List-链表"><a href="#Linked-List-链表" class="headerlink" title="Linked List 链表"></a>Linked List 链表</h6><ul>
<li>链表是由多个元素组成的列表，链表中的元素储存不连续，用next指针连接在一起。</li>
<li>数组：增删非数组元素需要移动元素</li>
<li>链表：增删非首尾元素不需要移动元素只需要更改next的指向即可</li>
<li>链表是一个链式数据结构，每个节点由两个信息组成：节点的数据和指向下一个节点的指针。链表和传统数组都是线性数据结构，具有序列化的存储方式。</li>
<li>JavaScript中没有链表，但是可以用object来模拟链表</li>
</ul>
<h6 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h6><ul>
<li>集合：一种无序且唯一的数据结构，集合区别队列、栈、链表最大的区别就是元素不能重复</li>
<li>JavaScript中ES6中新增了集合这种数据结构，可以通过实例化Set对象来创建集合const set &#x3D; new Set()</li>
</ul>
<h6 id="树"><a href="#树" class="headerlink" title="树"></a>树</h6><p>前端🎄树结构还是比较常见的，例如级联选择、层级目录等都是树形结构。<br>javascript中没有树这个数据结构，但是一般用object和array来模拟树。</p>
<ul>
<li>树的常用遍历方式<br>  1、深度优先遍历<br>  2、广度优先遍历</li>
</ul>
<h6 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h6><ul>
<li><p>叉树是n(n&gt;&#x3D;0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树组成</p>
</li>
<li><p>树的每个节点最多只能有两个子节点</p>
</li>
<li><p>js中自然也没有二叉树这个数据结构，一般还是用object对象来模拟二叉树</p>
</li>
<li><p>二叉树遍历（递归）<br>  （1）前序遍历<br>  DLR：根节点——左子树——右子树<br>  每次遍历到一个节点都重复一次前序遍历<br>  （2）中序遍历<br>  LDR：左子树——根节点——右子树<br>  每次遍历到一个节点都重复一次中序遍历<br>  （3）后序遍历<br>  LRD：左子树——右子树——根节点<br>  每次遍历到一个节点都重复一次后序遍历<br>  注意：<br>  前序遍历第一个为根节点<br>  中序遍历根节点左边为左子树，右边为右子树<br>  后序遍历最后一个为根节点</p>
</li>
</ul>
<h6 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h6><ul>
<li>堆是一种特殊的完全二叉树</li>
<li>所有的节点都大于等于（最大堆）或者小于等于（最小堆）他的子节点</li>
</ul>
<h2 id="es6中map和object的区别是什么"><a href="#es6中map和object的区别是什么" class="headerlink" title="es6中map和object的区别是什么"></a>es6中map和object的区别是什么</h2><ul>
<li>1、Map的键可以是任意值，而Object的键必须是一个String或是Symbol。</li>
<li>2、Map中的key是有序的，而Object的键是无序的。</li>
<li>3、Map的键值对个数可以轻易地通过size属性获取，而Object的键值对个数只能手动计算。</li>
<li>4、Map可以直接被迭代，而Object不可以直接被迭代。</li>
<li>5、Map在频繁增删键值对的场景下表现更好，而Object的效率比较差。</li>
</ul>
<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="Vue的最大优势是什么"><a href="#Vue的最大优势是什么" class="headerlink" title="Vue的最大优势是什么?"></a>Vue的最大优势是什么?</h2><ul>
<li>比较轻量，中国人自己写的框架，文档易读（这里比较轻松，拿出平时和朋友聊天的语气）<ul>
<li>双向数据绑定,</li>
<li>数据驱动视图,</li>
<li>组件化开发</li>
<li>数据和视图分离</li>
<li>单页面应用可以实现页面数据局部刷新</li>
</ul>
</li>
</ul>
<h2 id="MVVM和MVC区别是什么"><a href="#MVVM和MVC区别是什么" class="headerlink" title="MVVM和MVC区别是什么?"></a>MVVM和MVC区别是什么?</h2><h3 id="MVC-：-传统的设计模式。"><a href="#MVC-：-传统的设计模式。" class="headerlink" title="MVC ： 传统的设计模式。"></a>MVC ： 传统的设计模式。</h3><ul>
<li>设计模式： 一套广泛被使用的开发方式<br>  M： model 模型<br>  模型：就是数据的意思<br>  V ： view视图<br>  视图：就是页面的意思<br>  C：controller控制器<br>  控制器：在这里写js业务逻辑，把数据M 渲染到 视图 V （有点类似于我们之前学习的，把数据渲染到页面）</li>
</ul>
<h3 id="MVVM：-vue所使用的设计模式"><a href="#MVVM：-vue所使用的设计模式" class="headerlink" title="MVVM： vue所使用的设计模式"></a>MVVM： vue所使用的设计模式</h3><pre><code>M： model数据模型 (data里定义)
V： view视图 （页面标签）
VM： ViewModel视图模型 (vue.js源码)
</code></pre>
<ul>
<li><p>MVVM通过数据双向绑定让数据自动地双向同步 不再需要操作DOM<br>  V （修改视图） -&gt; M（数据自动同步）<br>  M（修改数据） -&gt; V （视图自动同步）</p>
</li>
<li><p>设计模式: 是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。(代码分层, 架构设计)</p>
</li>
</ul>
<h6 id="1-在vue中，不推荐直接手动操作DOM！！！"><a href="#1-在vue中，不推荐直接手动操作DOM！！！" class="headerlink" title="1. 在vue中，不推荐直接手动操作DOM！！！"></a>1. 在vue中，不推荐直接手动操作DOM！！！</h6><h6 id="2-在vue中，通过数据驱动视图，不要在想着怎么操作DOM，而是想着如何操作数据！！-思想转变"><a href="#2-在vue中，通过数据驱动视图，不要在想着怎么操作DOM，而是想着如何操作数据！！-思想转变" class="headerlink" title="2. 在vue中，通过数据驱动视图，不要在想着怎么操作DOM，而是想着如何操作数据！！(思想转变)"></a>2. 在vue中，通过数据驱动视图，不要在想着怎么操作DOM，而是想着如何操作数据！！(思想转变)</h6><h2 id="vue第一次加载页面"><a href="#vue第一次加载页面" class="headerlink" title="vue第一次加载页面"></a>vue第一次加载页面</h2><p>1、创建vue实例<br>2、在创建Vue实例的时候，执行了init()初始化，在init过程中先调用了beforeCreate钩子函数；<br>3、同时监听data数据，初始化vue内部事件，进行属性和方法的计算<br>4、模板开始编译，把vue里面的数据和语法编译成HTML</p>
<p>当页面第一次加载时会触发 beforeCreate, created, beforeMount, mounted</p>
<h2 id="Vue常用修饰符有哪些"><a href="#Vue常用修饰符有哪些" class="headerlink" title="Vue常用修饰符有哪些?"></a>Vue常用修饰符有哪些?</h2><p>.prevent: 提交事件不再重载页面；<br>.stop: 阻止单击事件冒泡；<br>.once: 只执行一次这个事件<br>.enter:监听键盘enter键</p>
<h2 id="对Vue渐进式的理解"><a href="#对Vue渐进式的理解" class="headerlink" title="对Vue渐进式的理解"></a>对Vue渐进式的理解</h2><pre><code>- 主张最少,
- 自底向上,
- 增量开发,
- 组件集合,
- 便于复用
</code></pre>
<ul>
<li>个人见解<br>  使用模块化规范，实现自助餐式开发，用什么导什么。 最大程度上节省资源。</li>
</ul>
<h2 id="vue-生命周期"><a href="#vue-生命周期" class="headerlink" title="vue 生命周期"></a>vue 生命周期</h2><p>什么是vue生命周期和生命周期钩子函数？<br>beforeCreated：在实例初始化之后，el 和 data 并未初始化<br>（这个时期，this变量还不能使用，在data下的数据，和methods下的方法，watcher中的事件都不能获得到）<br>created:完成了 data 数据的初始化，el没有<br>（这个时候可以操作vue实例中的数据和各种方法，但是还不能对”dom”节点进行操作）<br>beforeMount：完成了 el 和 data 初始化 &#x2F;&#x2F;这里的el是虚拟的dom；<br>mounted ：完成挂载，在这发起后端请求，拿回数据，配合路由钩子做一些事情<br>（挂载完毕，这时dom节点被渲染到文档内，一些需要dom的操作在此时才能正常进行）<br>beforeUpdate：是指view层数据变化前，不是data中的数据改变前触发；<br>update：是指view层的数据变化之后，<br>beforeDestroy： 你确认删除XX吗？<br>destroyed ：当前组件已被删除，清空相关内容<br>A、什么是vue生命周期？<br>Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程。<br>B、vue生命周期的作用是什么？<br>它的生命周期有多个事件钩子,让我们在控制整个Vue实例的过程时更容易形成好的逻辑。<br>C、vue生命周期总共有几个阶段？<br>它可以总共分为8个阶段：创建前&#x2F;后, 载入前&#x2F;后,更新前&#x2F;后,销毁前&#x2F;销毁后<br>D、第一次页面加载会触发哪几个钩子？<br>第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子<br>E、DOM 渲染在 哪个周期中就已经完成？<br>DOM 渲染在 mounted 中就已经完成了。<br>F、简单描述每个周期具体适合哪些场景？<br>生命周期钩子的一些使用方法： beforeCreate : 可以在这加个loading事件，<br>在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束loading事件，<br>异步请求也适宜在这里调用 mounted : 挂载元素，获取到DOM节点 updated : 如果对数据统一处理，</p>
<h2 id="说出至少4个Vue指令及作用"><a href="#说出至少4个Vue指令及作用" class="headerlink" title="说出至少4个Vue指令及作用"></a>说出至少4个Vue指令及作用</h2><ul>
<li>v-on 给标签绑定函数，可以缩写为@，例如绑定一个点击函数 函数必须写在methods里面</li>
<li>v-bind 动态绑定 作用： 及时对页面的数据进行更改, 可以简写成:分号</li>
<li>v-slot: 缩写为#, 组件插槽</li>
<li>v-for 根据数组的个数, 循环数组元素的同时还生成所在的标签</li>
<li>v-show 显示内容</li>
<li>v-if 显示与隐藏</li>
<li>v-else 必须和v-if连用 不能单独使用 否则报错</li>
<li>v-text 解析文本</li>
<li>v-html 解析html标签</li>
</ul>
<h2 id="为什么避免v-for和v-if在一起使用"><a href="#为什么避免v-for和v-if在一起使用" class="headerlink" title="为什么避免v-for和v-if在一起使用"></a>为什么避免v-for和v-if在一起使用</h2><p>Vue 处理指令时，v-for 比 v-if 具有更高的优先级, 虽然用起来也没报错好使, 但是性能不高, 如果你有5个元素被v-for循环, v-if也会分别执行5次.</p>
<h2 id="v-if与v-show区别逐字稿"><a href="#v-if与v-show区别逐字稿" class="headerlink" title="v-if与v-show区别逐字稿"></a>v-if与v-show区别逐字稿</h2><p>面试官你好，我是这么理解v-if和v-show的。 v-if本质其实是动态的创建 或者 删除元素节点。一般不用频繁切换, 要么显示, 要么隐藏的情况, 我都会用 v-if。因为v-if 是惰性的, 如果初始值为 false, 那么这些元素就直接不创建了, 这样就可以节省一些初始渲染开销。v-show本质是在控制元素的 css 样式,display: none;，一般元素需要频繁的切换显示隐藏, 用 v-show。因为v-if在频繁切换会大量的创建和删除元素, 消耗性能。</p>
<h2 id="Vue中key值作用"><a href="#Vue中key值作用" class="headerlink" title="Vue中key值作用"></a>Vue中key值作用</h2><ul>
<li>1.vue在渲染的时候,会 先把 新DOM 与 旧DOM 进行对比， 如果dom结构一致，则vue会复用旧的dom。 （此时可能造成数据渲染异常）</li>
<li>2.使用key可以给dom添加一个 唯一标识符，让vue强制更新dom</li>
</ul>
<h6 id="面试官你好-我是这么理解key值的-key值的主要作用是给元素添加一个唯一标识符-用于提高vue渲染性能-当data发生变化的时候-vue会使用diff算法来对比新旧虚拟DOM-如果key值相同-才会考虑复用元素-如果key值不同-则会强制更新元素-一般通过给元素key设置为id-来保证vue更新数据的时候可以最大限度复用相同的key值的元素"><a href="#面试官你好-我是这么理解key值的-key值的主要作用是给元素添加一个唯一标识符-用于提高vue渲染性能-当data发生变化的时候-vue会使用diff算法来对比新旧虚拟DOM-如果key值相同-才会考虑复用元素-如果key值不同-则会强制更新元素-一般通过给元素key设置为id-来保证vue更新数据的时候可以最大限度复用相同的key值的元素" class="headerlink" title="面试官你好,我是这么理解key值的,key值的主要作用是给元素添加一个唯一标识符,用于提高vue渲染性能,当data发生变化的时候,vue会使用diff算法来对比新旧虚拟DOM.如果key值相同,才会考虑复用元素.如果key值不同,则会强制更新元素.一般通过给元素key设置为id,来保证vue更新数据的时候可以最大限度复用相同的key值的元素."></a>面试官你好,我是这么理解key值的,key值的主要作用是给元素添加一个唯一标识符,用于提高vue渲染性能,当data发生变化的时候,vue会使用diff算法来对比新旧虚拟DOM.如果key值相同,才会考虑复用元素.如果key值不同,则会强制更新元素.一般通过给元素key设置为id,来保证vue更新数据的时候可以最大限度复用相同的key值的元素.</h6><h2 id="v-for指令使用key值几种情况"><a href="#v-for指令使用key值几种情况" class="headerlink" title="v-for指令使用key值几种情况"></a>v-for指令使用key值几种情况</h2><p>[v-for指令使用key值几种情况逐字稿]</p>
<ol>
<li>没有key值(默认是下标) :   不复用，就地更新</li>
<li>key值为下标(相当于没设置) :  不复用，就地更新</li>
<li>key值是id   :  复用相同的key，更新不同的key<br>总结 ： key值优先设置id, 没有id就用下标</li>
</ol>
<h2 id="Vue中-key作用-为什么不能用索引"><a href="#Vue中-key作用-为什么不能用索引" class="headerlink" title="Vue中:key作用, 为什么不能用索引"></a>Vue中:key作用, 为什么不能用索引</h2><ul>
<li>:key是给v-for循环生成标签颁发唯一标识的, 用于性能的优化</li>
<li>因为v-for数据项的顺序改变，Vue 也不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素</li>
</ul>
<h2 id="v-model的作用及原理"><a href="#v-model的作用及原理" class="headerlink" title="v-model的作用及原理"></a>v-model的作用及原理</h2><ul>
<li>作用<ul>
<li>数据双向绑定指令，专门给表单元素</li>
</ul>
</li>
<li>原理<ul>
<li>v-model是一个语法糖，他背后本质上是包含两个操作<ul>
<li>v-bind绑定一个value属性</li>
<li>v-on指令给当前元素绑定input事件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v-model实现原理的例子</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;message&quot;</span>&gt;</span><br><span class="line"><span class="comment">// 等于</span></span><br><span class="line"><span class="comment">// @input input框的事件</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;message&quot;</span>  @<span class="attr">input</span>=<span class="string">&quot;message = $event.target.value&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Vue中有时候数组会更新页面，有时候不更新，这是为什么"><a href="#Vue中有时候数组会更新页面，有时候不更新，这是为什么" class="headerlink" title="Vue中有时候数组会更新页面，有时候不更新，这是为什么?"></a>Vue中有时候数组会更新页面，有时候不更新，这是为什么?</h2><ul>
<li>因为vue内部只能监测到数组顺序&#x2F;位置的改变&#x2F;数量的改变, 但是值被重新赋予监测不到变更, 可以用 Vue.set() &#x2F; vm.$set()</li>
</ul>
<h2 id="请说下封装-vue-组件的过程"><a href="#请说下封装-vue-组件的过程" class="headerlink" title="请说下封装 vue 组件的过程"></a>请说下封装 vue 组件的过程</h2><ul>
<li>有复用的地方就有封装<br>1.先分析需求：确定业务需求，把页面中可以复用的结构，样式以及功能<br>2.具体步骤：Vue.component 或者在new Vue配置项components中, 定义组件名, 可以在props中接受给组件传的参数和值，子组件修改好数据后，想把数据传递给父组件。可以采用$emit方法</li>
</ul>
<h2 id="vue组件传值"><a href="#vue组件传值" class="headerlink" title="vue组件传值"></a>vue组件传值</h2><ul>
<li>父传子<br>  1.子组件props定义变量<br>  2.父组件在使用子组件时通过行内属性给props变量传值<br>  特点：单向数据流</li>
<li>子传父<br>  1.子组件：$emit触发父的事件<br>  2.父在使用组件用@自定义事件名&#x3D;父的方法 (子把值带出来)<br>  特点：事件监听</li>
<li>非父子组件<br>  vuex<br>  事件总线(Event Bus)<br>  事件总线是一种通过中央事件管理器来实现组件通信的方式。在Vue中，可以使用Vue实例作为事件总线来发送和接收事件。</li>
</ul>
<h2 id="Vue-组件-data-为什么必须是函数"><a href="#Vue-组件-data-为什么必须是函数" class="headerlink" title="Vue 组件 data 为什么必须是函数"></a>Vue 组件 data 为什么必须是函数</h2><pre><code>因为组件是需要在多个地方使用的
    如果data是一个对象，对象是引用类型。 一旦某一个地方修改，就会全部修改
    data是一个函数，每一次复用组件的时候就会从这个函数返回一个新的对象。 这样组件在复用的时候就可以做到数据互不干扰。
</code></pre>
<h2 id="讲一下组件的命名规范"><a href="#讲一下组件的命名规范" class="headerlink" title="讲一下组件的命名规范"></a>讲一下组件的命名规范</h2><ul>
<li>一种是使用链式命名”my-component”，一种是使用大驼峰命名”MyComponent”，</li>
<li>因为要遵循W3C规范中的自定义组件名 (字母全小写且必须包含一个连字符)，避免和当前以及未来的 HTML 元素相冲突</li>
</ul>
<h2 id="scoped作用与原理"><a href="#scoped作用与原理" class="headerlink" title="scoped作用与原理"></a>scoped作用与原理</h2><p>作用：组件css作用域，避免子组件内部的css样式被父组件覆盖<br>默认情况下，如果子组件和父组件css选择器权重相同，优先加载父组件css样式<br>原理：给元素添加一个自定义属性 v-data-xxxxx</p>
<p>一针见血答案： 通过属性选择题来提高css权重值</p>
<h2 id="Vue-的-nextTick-的原理是什么"><a href="#Vue-的-nextTick-的原理是什么" class="headerlink" title="Vue 的 nextTick 的原理是什么?"></a>Vue 的 nextTick 的原理是什么?</h2><p>为什么需要 nextTick<br>    Vue 是异步修改 DOM 的并且不鼓励开发者直接接触 DOM，但有时候业务需要必须对数据更改–刷新后的 DOM 做相应的处理，这时候就可以使用 Vue.nextTick(callback)这个 api 了。<br>最终答案：<br>    nextTick 的原理是 vue 通过异步队列控制 DOM 更新<br>    nextTick底层是promise，所以是微任务。这个一定要知道</p>
<h2 id="子组件修改父组件的数据"><a href="#子组件修改父组件的数据" class="headerlink" title="子组件修改父组件的数据"></a>子组件修改父组件的数据</h2><p>子组件通过this.$emit(“自定义事件名称a”,传递的参数)<br>父组件通过子组件标签接收<br>&lt;组件标签 @自定义事件名称a&#x3D;”自定义名称b”&#x2F;&gt;<br>methods：{<br>    自定义名称b(v){<br>        console.log(v)<br>    }<br>}</p>
<ul>
<li>$eventBus 灵活<ul>
<li>this.$emit(‘事件名’,传递的参数)</li>
<li>this.$on(‘事件名’,接收的回调)</li>
</ul>
</li>
<li>vuex 也算是一种</li>
</ul>
<h2 id="vue事件冒泡"><a href="#vue事件冒泡" class="headerlink" title="vue事件冒泡"></a>vue事件冒泡</h2><p>当一个父元素div1 包裹着一个子元素div2 同时都有点击事件，我们点击子元素，不想触发父元素的事件，我们可以采用阻止事件冒泡解决<br>.stop 清除事件冒泡<br>.prevent 阻止默认行为<br>.once 只触发一次<br>.self 只允许元素自己触发</p>
<h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><p> 简单说就是用户更改数据(Data)时，视图可以自动刷新，页面UI能够响应数据变化。<br>原理：在生成vue实例时，为对传入的data进行遍历，使用Object.defineProperty把这些属性转为getter&#x2F;setter<br>每个vue实例都有一个watcher实例，它会在实例渲染时记录这些属性，并在setter触发时通知render重新渲染。</p>
<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">更高级的组件复用方式。 接收dom片段或内容，加工处理后返回显示。</span><br><span class="line">	匿名插槽(默认插槽)</span><br><span class="line">		写在插槽组件中的内容或者template没有命名都会视为匿名插槽，相当于#default</span><br><span class="line">		<span class="tag">&lt;<span class="name">b</span>&gt;</span>我是匿名插槽接收的数据<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">		b组件<span class="tag">&lt;<span class="name">template</span>&gt;</span><span class="tag">&lt;<span class="name">solt</span>&gt;</span>我要接收匿名插槽数据的<span class="tag">&lt;/<span class="name">solt</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">	具名插槽</span><br><span class="line">		插槽组件中在template模板上使用v-slot命令绑定一个名称</span><br><span class="line">		插槽组件使用内置组件slot，用name属性去匹配v-slot名称</span><br><span class="line">		<span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&#x27;aa&#x27;</span>&gt;</span>要传的内容<span class="tag">&lt;/<span class="name">template</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">		b插槽组件内：<span class="tag">&lt;<span class="name">template</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&#x27;aa&#x27;</span>&gt;</span>要传的内容会在这里显示<span class="tag">&lt;/<span class="name">slot</span>&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">	作用域插槽</span><br><span class="line">		父组件中的插槽模板template里， 其作用域属于插槽组件。</span><br><span class="line">			父传子：父组件使用v-bind向插槽组件进行传参</span><br><span class="line">			子传父：插槽组件在slot组件上使用v-bind反向传参， 父组件使用v-slot=&#x27;参数&#x27;接收数据</span><br><span class="line">			子集<span class="tag">&lt;<span class="name">slot</span> <span class="attr">:data</span>=<span class="string">&quot;data&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">			父级：<span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;user&quot;</span>&gt;</span>&#123;&#123;user.data.name&#125;&#125;<span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>什么时候使用插槽<br>当子组件被复用时，需要在特定的区域展示不同的定制化的内容。</li>
<li>插槽的使用场景</li>
</ul>
<h2 id="v-show-v-if"><a href="#v-show-v-if" class="headerlink" title="v-show  v-if"></a>v-show  v-if</h2><p>共同点: v-if 和 v-show 都是动态显示DOM元素。<br>区别<br>编译过程：<br>v-if 是真正的条件渲染，因为它会在切换过程对元素和组件适当的销毁和重建 。<br>v-show的元素始终会被渲染。只是基于CSS属性display的切换<br>编译条件：<br>v-if 是惰性的：如果在初始渲染时条件为假，则什么也不做。直到条件第一次变为真时，才会开始渲染。<br>v-show 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于CSS进行切换<br>性能消耗：<br>v-if有更高的切换消耗。<br>v-show有更高的 初始渲染消耗&#96;。<br>应用场景：<br>v-if适合条件很少改变时使用。<br>v-show适合频繁切换</p>
<h2 id="自定义指令的方法有哪些-它有哪些钩子函数-还有哪些钩子函数参数-（必会）"><a href="#自定义指令的方法有哪些-它有哪些钩子函数-还有哪些钩子函数参数-（必会）" class="headerlink" title="自定义指令的方法有哪些?它有哪些钩子函数?还有哪些钩子函数参数?（必会）"></a>自定义指令的方法有哪些?它有哪些钩子函数?还有哪些钩子函数参数?（必会）</h2><p>全局定义指令：在vue对象的directive方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令：directives<br>钩子函数：bind(绑定事件触发)、inserted(节点插入的时候触发)、update(组件内相关更新)<br>钩子函数参数：el、binding</p>
<h2 id="vue路由作用与原理"><a href="#vue路由作用与原理" class="headerlink" title="vue路由作用与原理"></a>vue路由作用与原理</h2><p>路由作用： 实现单页面应用<br>原理：监听location的hash值</p>
<h2 id="路由之间是怎么跳转的？有哪些方式"><a href="#路由之间是怎么跳转的？有哪些方式" class="headerlink" title="路由之间是怎么跳转的？有哪些方式?"></a>路由之间是怎么跳转的？有哪些方式?</h2><p>1、<router-link to="需要跳转到页面的路径"><br>2、this.$router.push()跳转到指定的url，并在history中添加记录，点击回退返回到上一个页面<br>3、this.$router.replace()跳转到指定的url，但是history中不会添加记录，点击回退到上上个页面<br>4、this.$touter.go(n)向前或者后跳转n个页面，n可以是正数也可以是负数</p>
<h2 id="再用动态路由的时候防止刷新白屏"><a href="#再用动态路由的时候防止刷新白屏" class="headerlink" title="再用动态路由的时候防止刷新白屏"></a>再用动态路由的时候防止刷新白屏</h2><p>router.addRoutes(routes) routes新的路由<br>next({…to,replace:true})</p>
<h2 id="vue-router怎么配置路由（路由配置六个流程）"><a href="#vue-router怎么配置路由（路由配置六个流程）" class="headerlink" title="vue-router怎么配置路由（路由配置六个流程）"></a>vue-router怎么配置路由（路由配置六个流程）</h2><p>1.引入组件<br>2.配置路由path和组件, 和生成路由对象routes<br>3.创建路由对象router<br>4.把路由对象挂载到new Vue()<br>5.页面使用<router-view></router-view> 承载路由<br>6.<router-link to="要跳转的路径"></router-link> 设置路由导航(声明式导航方式&#x2F;编程式跳转)</p>
<h2 id="vue-router的钩子函数都有哪些（导航守卫）"><a href="#vue-router的钩子函数都有哪些（导航守卫）" class="headerlink" title="vue-router的钩子函数都有哪些（导航守卫）"></a>vue-router的钩子函数都有哪些（导航守卫）</h2><p>关于vue-router中的钩子函数主要分为3类<br>    1.全局钩子函数beforeEach（全局前置守卫，所有路由生效）<br>        beforeEach函数有三个参数,分别是:<br>            to:router即将进入的路由对象<br>            from:当前导航即将离开的路由<br>            next:function,进行管道中的一个钩子，如果执行完了,则导航的状态就是 confirmed （确认的）否则为false,终止导航。<br>    2.单独路由独享组件（只对这个路由生效）<br>        beforeEnter,<br>    3 组件内钩子<br>        beforeRouterEnter，（渲染路由组件前）<br>        beforeRouterUpdate,（路由改变）<br>        beforeRouterLeave（路由离开）</p>
<h2 id="完整的导航解析流程"><a href="#完整的导航解析流程" class="headerlink" title="完整的导航解析流程"></a>完整的导航解析流程</h2><ul>
<li>1.导航被触发。</li>
<li>2.在失活的组件里调用 beforeRouteLeave 守卫。</li>
<li>3.调用全局的 beforeEach 守卫。</li>
<li>4.在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。</li>
<li>5.在路由配置里调用 beforeEnter。</li>
<li>6.解析异步路由组件。</li>
<li>7.在被激活的组件里调用 beforeRouteEnter。</li>
<li>8.调用全局的 beforeResolve 守卫(2.5+)。</li>
<li>9.导航被确认。</li>
<li>10.调用全局的 afterEach 钩子。</li>
<li>11.触发 DOM 更新。</li>
<li>12.调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li>
</ul>
<h2 id="什么是路由守卫？"><a href="#什么是路由守卫？" class="headerlink" title="什么是路由守卫？"></a>什么是路由守卫？</h2><p>路由守卫又叫导航守卫，就是路由跳转 前，中，后过程中的一些钩子函数，这个函数能够让你操作一些其他的事。</p>
<h2 id="路由传值的方式有哪几种"><a href="#路由传值的方式有哪几种" class="headerlink" title="路由传值的方式有哪几种"></a>路由传值的方式有哪几种</h2><p>Vue-router传参可以分为两大类，分别是编程式的导航和声明式的导航<br>    1.编程式导航：router.push<br>        字符串：直接传递路由地址，但是不能传递参数<br>            this.$router.push(“home”)<br>        对象：<br>            命名路由 这种方式传递参数，目标页面刷新会报错 name+params<br>            this.$router.push({name:”news”,params:{userId:123}})<br>            查询参数 和path配对的是query<br>            this.$router.push({path:”&#x2F;news’,query:{usersId:123}})<br>        接收参数 this.$route.query<br>    2.声明式导航<br>        字符串 &lt;router-link to:”news”&gt;</router-link><br>        命名路由 &lt;router-link :to:”{name:’news’,params:{userId:1111}}”&gt;</route-link><br>        还可以to&#x3D;”&#x2F;path&#x2F;值” - 需要提前在路由 规则里值 &#x2F;path&#x2F;:key<br>        查询参数 <router-link :to="{path:'/news',query:{userId:1111}}"></router-link><br>        还可以to&#x3D;”&#x2F;path?key&#x3D;value</p>
<h2 id="Vue路由传参方式，如何接收对应的值？"><a href="#Vue路由传参方式，如何接收对应的值？" class="headerlink" title="Vue路由传参方式，如何接收对应的值？"></a>Vue路由传参方式，如何接收对应的值？</h2><p>三种： 分别是query，params，动态路由传参<br>接收：<br>通过query方式传递过来的参数一般是通过this.$route.query接收<br>通过params方式传递过来的参数一般是通过this.$route.params接收<br>通过动态路由传参方式传递过来的参数一般是通过this.$route.params接收</p>
<h2 id="Vue的路由实现模式：hash模式和history模式"><a href="#Vue的路由实现模式：hash模式和history模式" class="headerlink" title="Vue的路由实现模式：hash模式和history模式"></a>Vue的路由实现模式：hash模式和history模式</h2><p>1.路径不同<br>    hash有#, history没有#<br>2.工作模式不同<br>    hash : 修改当前页面hash,不需要服务器额外配<br>    history: 会给服务器发送请求，需要服务器配置</p>
<p>1.hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用 window.location.hash 读取。特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。</p>
<p>2.history模式：history采用HTML5的新特性；且提供了两个新方法： pushState()， replaceState()可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更</p>
<h2 id="请说出路由配置项常用的属性及作用"><a href="#请说出路由配置项常用的属性及作用" class="headerlink" title="请说出路由配置项常用的属性及作用"></a>请说出路由配置项常用的属性及作用</h2><p>路由配置参数：<br>    path : 跳转路径<br>    component : 路径相对于的组件<br>    name:命名路由<br>    children:子路由的配置参数(路由嵌套)<br>    props:路由解耦<br>    redirect : 重定向路由</p>
<h2 id="route和-router的区别"><a href="#route和-router的区别" class="headerlink" title="$route和$router的区别?"></a>$route和$router的区别?</h2><p>$router 对象。用于跳转路由和传递参数<br>$route 对象。用于接收路由跳转参数</p>
<h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><p>keep-alive组件 作用就是保持一个组件活着</p>
<ul>
<li>缓存状态组件，他不会渲染成真实dom，只是将被包裹的自定义组件的状态缓存到内存中</li>
<li>多用于缓存 表单填写的组件</li>
<li>它不能缓存v-for循环渲染出来的组件<br> include属性,表示在被keep-alive管理的组件中,哪些需要保持活跃,有多个需要保持的,以逗号隔开<br> exclude属性,表示在被keep-alive管理的组件中,哪些不需要保持活跃,</li>
</ul>
<h2 id="跟keep-alive有关的生命周期是哪些？"><a href="#跟keep-alive有关的生命周期是哪些？" class="headerlink" title="跟keep-alive有关的生命周期是哪些？"></a>跟keep-alive有关的生命周期是哪些？</h2><p>1.前言：在开发Vue项目的时候，大部分组件是没必要多次渲染的，所以Vue提供了一个内置组件keep-alive来缓存组件内部状态，避免重新渲染<br>2.生命周期函数：在被keep-alive包含的组件&#x2F;路由中，会多出两个生命周期的钩子:activated 与 deactivated。<br>    activated钩子：在组件第一次渲染时会被调用，之后在每次缓存组件被激活时调用。<br>    deactivated钩子：组件被停用（离开路由）时调用</p>
<h2 id="vuex作用及五大组成部分"><a href="#vuex作用及五大组成部分" class="headerlink" title="vuex作用及五大组成部分"></a>vuex作用及五大组成部分</h2><pre><code>vuex作用： 全局数据管理 解决复杂的父子组件传值
state作用：存储数据
getter作用：派生数据。相当于state计算属性
mutations作用：修改state中的数据
actions作用： 异步更新数据
module作用：模块化处理vuex数据
</code></pre>
<h2 id="vuex中action工作流程"><a href="#vuex中action工作流程" class="headerlink" title="vuex中action工作流程"></a>vuex中action工作流程</h2><p>1.组件给actions发送消息<br>2.actions异步请求数据<br>3.actions将请求到的数据提交给mutations<br>4.mutations同步更新state中的数据</p>
<h2 id="vuex刷新页面丢失数据原因和解决方法？"><a href="#vuex刷新页面丢失数据原因和解决方法？" class="headerlink" title="vuex刷新页面丢失数据原因和解决方法？"></a>vuex刷新页面丢失数据原因和解决方法？</h2><p>原因：- 因为js的数据都是保存在浏览器的堆和栈内的，刷新浏览器页面，以前堆栈申请的内存被释放(这就是浏览器的运行机制),那么堆栈里的数据自然就被清空了</p>
<ul>
<li>解决方法<ul>
<li>使用cookie或localstorage</li>
<li>第二种方法是 vuex-along<ul>
<li>安装 vuex-along -  npm install vuex-along –save</li>
</ul>
</li>
<li>第三种方法是 vuex-persistedstate po si te si de te<ul>
<li>安装 vuex-persistedstate -  npm install –save vuex-persistedstate</li>
</ul>
</li>
<li>第四种方法是 vuex-persist<ul>
<li>安装 vuex-persist - npm install –save vuex-persistor</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="说一下你在vue中踩过的坑"><a href="#说一下你在vue中踩过的坑" class="headerlink" title="说一下你在vue中踩过的坑"></a>说一下你在vue中踩过的坑</h2><p>1、操作data中的数据，发现没有响应式<br>    原因： 数组中有很多方法，有的会改变数组（例如pop push）,有的不会改变数组（例如slice, filter）<br>    解决方案：通过Vue.set(对象，属性，值)这种方式就可以达到，对象新添加的属性是响应式的<br>2、在created操作dom的时候，是报错的，获取不到dom，这个时候实例vue实例没有挂载<br>    解决方案：Vue.nextTick(回调函数进行获取)</p>
<h1 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h1><h2 id="小程序的登录流程是什么"><a href="#小程序的登录流程是什么" class="headerlink" title="小程序的登录流程是什么"></a>小程序的登录流程是什么</h2><ol>
<li>用户点击登录按钮 通过wx.login() 获取用户的code码</li>
<li>通过wx.request() 网络请求将code码发送给开发者服务器</li>
<li>后端开发者拿到code码后需要通过appid+appsecret+code向微信接口服务器请求当前用户的session_key和openid</li>
<li>后端得到session_key 和openid后 会自定义一个登录态(token)和session_key及openid进行绑定</li>
<li>后端会将token返回给小程序端&#x2F;&#x2F;tao kin</li>
<li>将小程序端得到token后 要将token存到本地</li>
</ol>
<h2 id="小程序项目允许的最大体积是多少"><a href="#小程序项目允许的最大体积是多少" class="headerlink" title="小程序项目允许的最大体积是多少"></a>小程序项目允许的最大体积是多少</h2><p>不适用分包的情况下 小程序总体积不能超过2MB<br>如果使用分包的情况下 总体积不能超过20MB 单个包体积不能超过2MB</p>
<h2 id="小程序和普通网页区别"><a href="#小程序和普通网页区别" class="headerlink" title="小程序和普通网页区别"></a>小程序和普通网页区别</h2><p>运行环境不同：网页在浏览器运行，小程序在微信环境运行</p>
<p>开发模式不同： 网页开发用浏览器+代码编辑器 小程序有自己的一套标准开发模式，使<br>用小程序开发工具</p>
<p>api不同 运行环境不同所以小程序没有办法调用bom和dom的api 小程序可以调用微信环境<br>提供的各种api 比如扫码，支付，地理定位，摇一摇，附近的人等等…</p>
<h2 id="小程序的项目构成"><a href="#小程序的项目构成" class="headerlink" title="小程序的项目构成"></a>小程序的项目构成</h2><p>pages 用来存放所有小程序页面<br>utils 用来存放工具性质模块，比如格式化时间.wxs文件，封装请求数据组件.js文件<br>​<br>app.js 小程序项目的入口文件  类似vue的 app.vue<br>app.json 小程序项目的全局配置文件<br>app.wxss 小程序项目的全局样式文件<br>project.config.json 项目的配置文件<br>sitemap.json 用来配置小程序是否允许被微信搜索引擎搜索到，比如：在微信小程序搜<br>京东，会弹出京东小程序，<br>如果关闭，搭建的项目，微信是无法搜索到的。</p>
<h2 id="小程序页面的组成部分"><a href="#小程序页面的组成部分" class="headerlink" title="小程序页面的组成部分**"></a>小程序页面的组成部分**</h2><p>每个页面由四个基本文件组成，在app.json文件中配置好pages后小程序会自动生成文件</p>
<ol>
<li>.js文件 存放页面脚本文件，存放页面的数据，事件处理函数等 （写逻辑代码）</li>
<li>.json文件 当前页面配置文件，配置窗口的外观，表现等</li>
<li>.wxml文件 存放页面布局，类似html但不同，div&#x3D;view span&#x3D;text img&#x3D;image</li>
<li>.wxss文件 存放样式类似css但是和css不同，.wxss新增了rpx像素单位，只能引入外<br>链文件和样式背景图等都必须外链文件。</li>
</ol>
<h2 id="app-json中的配置有哪些"><a href="#app-json中的配置有哪些" class="headerlink" title="## app.json中的配置有哪些"></a>## app.json中的配置有哪些</h2><p>1、pages 用于保存页面的路径<br>2、window 配置页面头部的导航栏<br>3、tabBar 配置页面底部菜单栏<br>4、entryPagePath 页面加载时初始化的页面<br>5、networkTimeout 配置网络超时时间<br>6、subpackage 配置小程序的分包功能</p>
<h2 id="window配置中的配置项有哪些"><a href="#window配置中的配置项有哪些" class="headerlink" title="window配置中的配置项有哪些"></a>window配置中的配置项有哪些</h2><ul>
<li>navigationBarBackgroundColor：导航栏背景色 只支持十六进制的颜色表示法 &#x2F;&#x2F;nav一给身霸拜克哥软的卡乐</li>
<li>navigationBarTextStyle：导航栏的文本样式，只支持两个值 block white</li>
<li>navigationBarTitleText：导航栏的标题文本</li>
<li>backgroundColor：设置下拉刷新的背景色</li>
<li>backgroundTextStyle：下拉刷新界面的文本样式 只支持两个值 dark light</li>
<li>enablePullDownRefresh：是否启用下拉刷新功能 &#x2F;&#x2F;以内bo pou当瑞服瑞吃</li>
<li>navigationStyle:导航栏的样式 只支持两个值 default与custom default表示默认显示导航栏，custom表示隐藏导航栏 只保留右侧胶囊按钮 可以自己定义</li>
</ul>
<h2 id="tabBar配置中的配置项有哪些"><a href="#tabBar配置中的配置项有哪些" class="headerlink" title="tabBar配置中的配置项有哪些"></a>tabBar配置中的配置项有哪些</h2><ul>
<li>list 配置底部的菜单栏列表项</li>
<li>color 设置默认状态的文本颜色</li>
<li>selectedColor 设置激活状态的文本颜色</li>
<li>backgroundColor 设置菜单栏的背景色</li>
<li>borderStyle 设置菜单栏的上边框样式 支持white和black </li>
<li>position 菜单栏的位置 只支持top和bottom</li>
<li>custom 自定义菜单栏 true  或者  false</li>
</ul>
<h2 id="如何自定义tabBar"><a href="#如何自定义tabBar" class="headerlink" title="如何自定义tabBar"></a>如何自定义tabBar</h2><p>首先在app.json中 配置“tabBar”，对象然后创建list数组，写实际的路径，最少两个，最多五个。</p>
<h2 id="networkTimeout配置中的配置项有哪些"><a href="#networkTimeout配置中的配置项有哪些" class="headerlink" title="networkTimeout配置中的配置项有哪些"></a>networkTimeout配置中的配置项有哪些</h2><ul>
<li>request：配置网络请求的超时时间</li>
<li>connectSocket：配置既时通讯的超时时间</li>
<li>uploadFile：配置上传内容的超时时间</li>
<li>downloadFile：配置下载文件的超时时间</li>
</ul>
<h2 id="小程序渲染数据如何渲染"><a href="#小程序渲染数据如何渲染" class="headerlink" title="小程序渲染数据如何渲染"></a>小程序渲染数据如何渲染</h2><p>使用插值表达式渲染数据</p>
<h2 id="列表渲染的指令是什么"><a href="#列表渲染的指令是什么" class="headerlink" title="列表渲染的指令是什么"></a>列表渲染的指令是什么</h2><pre><code>wx:for
</code></pre>
<h2 id="列表渲染如何修改item和index的名字"><a href="#列表渲染如何修改item和index的名字" class="headerlink" title="列表渲染如何修改item和index的名字"></a>列表渲染如何修改item和index的名字</h2><pre><code>wx:for-item   wx:for-index
</code></pre>
<h2 id="列表渲染可以渲染的数据类型有哪些"><a href="#列表渲染可以渲染的数据类型有哪些" class="headerlink" title="列表渲染可以渲染的数据类型有哪些"></a>列表渲染可以渲染的数据类型有哪些</h2><pre><code>Array  Object  String  Number
</code></pre>
<h2 id="block标签的作用是什么"><a href="#block标签的作用是什么" class="headerlink" title="block标签的作用是什么"></a>block标签的作用是什么</h2><pre><code>专门用于条件渲染和列表渲染使用的,block标签不会渲染到页面视图中
</code></pre>
<h2 id="小程序中如何实现响应式的数据修改"><a href="#小程序中如何实现响应式的数据修改" class="headerlink" title="小程序中如何实现响应式的数据修改"></a>小程序中如何实现响应式的数据修改</h2><pre><code>获取数据使用this.data.变量名
通过this.setData() 方法来修改数据
</code></pre>
<h2 id="小程序生命周期函数有哪些"><a href="#小程序生命周期函数有哪些" class="headerlink" title="小程序生命周期函数有哪些"></a>小程序生命周期函数有哪些</h2><pre><code>onLaunch:整个小程序初始化完成
onShow:小程序加载完成或者当小程序切回前台时触发
onHide:小程序切换到后台时触发
</code></pre>
<h2 id="页面级生命周期函数有哪些"><a href="#页面级生命周期函数有哪些" class="headerlink" title="页面级生命周期函数有哪些"></a>页面级生命周期函数有哪些</h2><pre><code>onLoad:当前页面加载时触发的时间
onShow:当前页面在前台显示时触发
onReady:当前页面初次渲染完成后触发
onHide:当前页面隐藏是触发
onUnload:当前页面卸载是触发
</code></pre>
<h2 id="组件级生命周期函数有哪些"><a href="#组件级生命周期函数有哪些" class="headerlink" title="组件级生命周期函数有哪些"></a>组件级生命周期函数有哪些</h2><pre><code>created:当前组件初始化完成时触发,无法调用setData方法
attached:当前组件在页面中挂载是会触发
ready:当前组件已经全部渲染完成后触发
moved:当前组件从节点树中的一个位置移动到另一个位置时触发
detached:当前组件被移除是触发--*
</code></pre>
<h2 id="组件的主要生命周期"><a href="#组件的主要生命周期" class="headerlink" title="组件的主要生命周期"></a>组件的主要生命周期</h2><p>在小程序中，最重要的生命周期函数有三个分别是，<br>    created，attached，detached<br>    1.组件实例刚刚被创建好触发created，不能调用setData<br>    用来给组件的this添加一些自定义属性<br>    2.组件完全初始化完毕，进入页面节点树后，触发<br>    attached。this.data已经被初始化完毕，初始化工作比如发送请求。<br>    3.组件离开页面节点树，触发detached生命周期函数，清理性质工作</p>
<h2 id="input组件如何实现双线数据绑定"><a href="#input组件如何实现双线数据绑定" class="headerlink" title="input组件如何实现双线数据绑定"></a>input组件如何实现双线数据绑定</h2><p>需要通过 value&#x3D;’‘ 将数据渲染到输入框中  再通过bind:input 事件 获取用户输入的内容，来修改数据的值</p>
<h2 id="input组件用户输入内容时，如果修改键盘右下角文字提示，可以修改成哪些值"><a href="#input组件用户输入内容时，如果修改键盘右下角文字提示，可以修改成哪些值" class="headerlink" title="input组件用户输入内容时，如果修改键盘右下角文字提示，可以修改成哪些值"></a>input组件用户输入内容时，如果修改键盘右下角文字提示，可以修改成哪些值</h2><pre><code>send	   发送
search	 搜索
next	   下一个
go	     前往
done	   完成
</code></pre>
<h2 id="input组件中有几种键盘类型，分别是什么"><a href="#input组件中有几种键盘类型，分别是什么" class="headerlink" title="input组件中有几种键盘类型，分别是什么"></a>input组件中有几种键盘类型，分别是什么</h2><pre><code>input 键盘类型
text              文本输入键盘  
number            数字输入键盘  
idcard            身份证输入键盘 
digit             带小数点的数字键盘 
safe-password     密码安全输入键盘 指引 
nickname          昵称输入键盘
</code></pre>
<h2 id="scroll-view组件想要纵向滚动时，必须要设置的内容有哪些"><a href="#scroll-view组件想要纵向滚动时，必须要设置的内容有哪些" class="headerlink" title="scroll-view组件想要纵向滚动时，必须要设置的内容有哪些"></a>scroll-view组件想要纵向滚动时，必须要设置的内容有哪些</h2><pre><code>scroll-y 必须设置高
</code></pre>
<h2 id="navigator组件的跳转方式有哪些"><a href="#navigator组件的跳转方式有哪些" class="headerlink" title="navigator组件的跳转方式有哪些"></a>navigator组件的跳转方式有哪些</h2><pre><code>navigate  redirect  switchTab reLaunch  navigateBack  exit
</code></pre>
<h2 id="navigate和-redirect方式有什么区别，共同点"><a href="#navigate和-redirect方式有什么区别，共同点" class="headerlink" title="navigate和 redirect方式有什么区别，共同点"></a>navigate和 redirect方式有什么区别，共同点</h2><pre><code>navigate:保留当前页面
redirect:关闭当前页面
共同点：不能跳到tabBar页面 可以携带参数
</code></pre>
<h2 id="navigate和-switchTab-方式有什么区别，共同点"><a href="#navigate和-switchTab-方式有什么区别，共同点" class="headerlink" title="navigate和 switchTab 方式有什么区别，共同点"></a>navigate和 switchTab 方式有什么区别，共同点</h2><pre><code>navigate:保留当前页面 不可以跳转tabBar 可以携带参数
switchTab:跳转到tabBar页面 并关闭其他所有非tabBar页面 不可以传参
没有共同点
</code></pre>
<h2 id="navigate和-reLaunch-方式有什么区别，共同点"><a href="#navigate和-reLaunch-方式有什么区别，共同点" class="headerlink" title="navigate和 reLaunch 方式有什么区别，共同点"></a>navigate和 reLaunch 方式有什么区别，共同点</h2><pre><code>navigate:保留当前页面 不可以跳转tabBar
reLaunch:关闭所有页面 允许跳转任意页面
共同点：可以传递参数
</code></pre>
<h2 id="图片组件是否有默认宽高，默认宽高是多少"><a href="#图片组件是否有默认宽高，默认宽高是多少" class="headerlink" title="图片组件是否有默认宽高，默认宽高是多少?"></a>图片组件是否有默认宽高，默认宽高是多少?</h2><pre><code>宽：320px 高240px
</code></pre>
<h2 id="wxss和css的不同之处有哪些"><a href="#wxss和css的不同之处有哪些" class="headerlink" title="wxss和css的不同之处有哪些"></a>wxss和css的不同之处有哪些</h2><pre><code>wxss文件
在小程序中,不能使用通配符选择器(*)
新增了尺寸单位 rpx
新增样式导入   使用@import语句可以导入外联样式表  该语句后面必须要以分号结尾,不然会报错
可以配置全局样式与局部样式,全局样式直接写在app.wxss中
</code></pre>
<h2 id="小程序有几种绑定事件的方式，有什么区别"><a href="#小程序有几种绑定事件的方式，有什么区别" class="headerlink" title="小程序有几种绑定事件的方式，有什么区别"></a>小程序有几种绑定事件的方式，有什么区别</h2><pre><code>小程序的事件系统
两种绑定事件的语法 bind 与catch
通过bind绑定通用事件,会产生事件流,如果祖级元素有相同类型的事件,会同时触发
catch绑定通用事件,不会产生事件流,
bind与catch绑定时,语法为bind:事件名,但是中间的:可以省略
</code></pre>
<h2 id="常见移动端事件有哪，说出5个以上"><a href="#常见移动端事件有哪，说出5个以上" class="headerlink" title="常见移动端事件有哪，说出5个以上"></a>常见移动端事件有哪，说出5个以上</h2><p>移动端事件:<br>    tap 触摸事件<br>    longtap 长按事件(被longpress代替)<br>    touchstart 手指触摸动作开始事件<br>    touchend 手指触摸动作结束事件<br>    touchmove 手指触摸后移动事件<br>    touchcancel 手指触摸动作被打断，如来电提醒，弹窗<br>    longpress 手指触摸后,超过350ms再离开,如果指定了事件回调函数并触发了这个事件,tap事件将不被触发<br>    touchforcechange  在支持 3D Touch 的 iPhone 设备，重按时会触发</p>
<h2 id="触摸事件的事件对象中有哪些常见属性，作用是什么"><a href="#触摸事件的事件对象中有哪些常见属性，作用是什么" class="headerlink" title="触摸事件的事件对象中有哪些常见属性，作用是什么"></a>触摸事件的事件对象中有哪些常见属性，作用是什么</h2><p>事件对象<br>在小程序的事件绑定函数上,不允许加括号调用<br>触摸事件的事件对象<br>     changedTouches:[] 记录发生改变的手指的数量<br>     currentTarget: 表示真正触发事件的元素<br>     offsetLeft: 元素与设备左侧的距离<br>     offsetTop: 元素与设备上方的距离<br>     detail: 记录参数信息,手指触摸的坐标,<br>     target: 手指触摸的元素<br>     touches:[] 记录手指触摸的个数<br>     type: 事件类型</p>
<h2 id="target-和currentTarget两者的区别是什么"><a href="#target-和currentTarget两者的区别是什么" class="headerlink" title="target 和currentTarget两者的区别是什么"></a>target 和currentTarget两者的区别是什么</h2><pre><code>target表示的是手指触摸的元素,而currentTarget表示响应事件的元素

我们可以通过target中的内容来进行判断,实现事件委托的操作
我们可以通过target中的id属性来进行判断触发的是哪一个组件,实现事件委托的操作
</code></pre>
<h2 id="小程序中的事件如何传递数据"><a href="#小程序中的事件如何传递数据" class="headerlink" title="小程序中的事件如何传递数据"></a>小程序中的事件如何传递数据</h2><pre><code>通过data-属性来传递数据  例 data-变量名=&quot;传递的数据&quot;  通过e.currentTarget.dataset.变量名接收数据
</code></pre>
<h2 id="小程序中全局数据如何使用，有什么特点"><a href="#小程序中全局数据如何使用，有什么特点" class="headerlink" title="小程序中全局数据如何使用，有什么特点"></a>小程序中全局数据如何使用，有什么特点</h2><pre><code>在app.js中,配置一个globalData属性,在这个属性中保存的内容就是全局数据
在其他页面中使用时,通过getApp()方法,可以获取到app实例,从而使用app.globalData就可以拿到数据
在globalData中的数据不能通过setData()方法来更新
</code></pre>
<h2 id="如何自定义一个组件"><a href="#如何自定义一个组件" class="headerlink" title="如何自定义一个组件"></a>如何自定义一个组件</h2><pre><code>在项目中新建一个components 目录 该目录用于保存自定义组件 在页面的json文件中的usingComponents字段中 引入对应的组件路径 之后就可以在对应页面的wxml中使用该组件
</code></pre>
<h2 id="关于父子组件之间样式是如何影响的"><a href="#关于父子组件之间样式是如何影响的" class="headerlink" title="关于父子组件之间样式是如何影响的"></a>关于父子组件之间样式是如何影响的</h2><pre><code>在组件的js文件中可以添加一个options，该选项是一个对象，对象中可以添加一个styleIsolation属性用于控制父子组件之间的样式隔离问题
styleIsolation属性有3个可选值：
    isolated ：默认不会相互影响
    apply-shared 父影响子
    shared:相互影响
</code></pre>
<h2 id="组件的外部样式类如何设置"><a href="#组件的外部样式类如何设置" class="headerlink" title="组件的外部样式类如何设置"></a>组件的外部样式类如何设置</h2><pre><code>- 在子组件希望有样式的标签上添加一个类名
- 在子组件的component构造器中添加externalclasses:[]添加上的类名 
- 在父组件的子组件标签上 添加对应的class的属性名 值是一个父组件的类名
- 在父组件的wxss中设置对应的class的样式即可生效
</code></pre>
<h2 id="小程序想要实现多个插槽使用如何设置"><a href="#小程序想要实现多个插槽使用如何设置" class="headerlink" title="小程序想要实现多个插槽使用如何设置"></a>小程序想要实现多个插槽使用如何设置</h2><pre><code>如果想要同时使用多个 需要在组件的js文件的options选项内开启配置multipleSlots:true 才会生效
</code></pre>
<h2 id="父组件如何传值给子组件"><a href="#父组件如何传值给子组件" class="headerlink" title="父组件如何传值给子组件"></a>父组件如何传值给子组件</h2><pre><code>1. 在父组件的子组件标签上动态绑定一个自定义属性，将要需要传递的数据放到属性值中
2. 在子组件的js文件中 通过properties属性来接收父组件传递的数据
</code></pre>
<h2 id="子组件如何传值给父组件"><a href="#子组件如何传值给父组件" class="headerlink" title="子组件如何传值给父组件"></a>子组件如何传值给父组件</h2><pre><code>1. 在子组件的事件函数中 通过this.triggerEvent()向父组件发出一个自定义事件 该方法有两个参数 第一个是自定义事件名 第二个是传递的参数
2. 在父组件的子组件标签上 通过bind监听子组件发出的自定义事件 在事件对象event的detail属性中可以接收到子组件传递过来的数据
</code></pre>
<h2 id="组件如何监听页面级生命周期"><a href="#组件如何监听页面级生命周期" class="headerlink" title="组件如何监听页面级生命周期"></a>组件如何监听页面级生命周期</h2><pre><code>通过pageLifetimes属性来监听
该属性对象中有三个响应函数 show hide resize
    1. show 表示组件所在页面被展示时的函数
    2. hide 表示组件所在页面被隐藏时的函数
    3. resize 表示组件所在页面尺寸发生变化时的函数
</code></pre>
<h2 id="小程序中的交互API有哪些"><a href="#小程序中的交互API有哪些" class="headerlink" title="小程序中的交互API有哪些"></a>小程序中的交互API有哪些</h2><pre><code>wx.showToast：消息提示框
wx.showModal：显示模态对话框
wx.showLoading 显示 loading 提示框。需主动调用 wx.hideLoading 才能关闭提示框
wx.showActionSheet 显示操作菜单
wx.hideToast 隐藏消息提示框
wx.hideLoading 隐藏loading提示框
</code></pre>
<h2 id="小程序中域名无法识别如何处理"><a href="#小程序中域名无法识别如何处理" class="headerlink" title="小程序中域名无法识别如何处理"></a>小程序中域名无法识别如何处理</h2><pre><code>在小程序本地设置中勾选不校验合法域名选项即可请求
在发布阶段，如果希望能够请求服务器资源，那么我们必须为这个服务器配置白名单
</code></pre>
<h2 id="网络请求限制，如何配置合法域名？"><a href="#网络请求限制，如何配置合法域名？" class="headerlink" title="网络请求限制，如何配置合法域名？"></a>网络请求限制，如何配置合法域名？</h2><pre><code>1.出于安全考虑，小程序对数据接口的请求有限制要求，小程序只能请求https类型接口，
必须将接口的域名添加到信任列表中否则控制台会提示（警告）
2.登录小程序公众平台---&gt;开发管理----&gt;开发设置---&gt;服务器域名---&gt;修改合法域名
</code></pre>
<h2 id="小程序中base64与二进制数据流之间的转换如何转换"><a href="#小程序中base64与二进制数据流之间的转换如何转换" class="headerlink" title="小程序中base64与二进制数据流之间的转换如何转换"></a>小程序中base64与二进制数据流之间的转换如何转换</h2><pre><code>wx.base64ToArrayBuffer
wx.arrayBufferToBase64
</code></pre>
<h2 id="你是怎么封装微信小程序的数据请求的？"><a href="#你是怎么封装微信小程序的数据请求的？" class="headerlink" title="你是怎么封装微信小程序的数据请求的？"></a>你是怎么封装微信小程序的数据请求的？</h2><pre><code>在根目录下创建util目录及api.js文件和apiConfig.js文件
在apiConfig.js封装基础的get，post和put，upload等请求方法，设置请求体，带上token和异常处理等
在api中引入apiConfig.js封装好的请求方法.根据页面数据请求的urls，设置对应的方法并导出
在具体的页面中导入或将所有的接口放在统一的js文件中并导出
在app.js中创建封装请求数据的方法
</code></pre>
<h2 id="小程序支付如何实现？"><a href="#小程序支付如何实现？" class="headerlink" title="小程序支付如何实现？"></a>小程序支付如何实现？</h2><p>小程序注册，要以公司的身份去注册一个小程序，才有微信支付权限</p>
<p>绑定商户号</p>
<p>在小程序填写合法域</p>
<p>调用wx.login()获取appid</p>
<p>调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">requestPayment</span>(</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&#x27;timeStamp&#x27;</span>: <span class="string">&#x27;&#x27;</span>,<span class="comment">//时间戳从1970年1月1日00:00:00至今的秒数,即当前的时间</span></span><br><span class="line">    <span class="string">&#x27;nonceStr&#x27;</span>: <span class="string">&#x27;&#x27;</span>,<span class="comment">//随机字符串，长度为32个字符以下。</span></span><br><span class="line">    <span class="string">&#x27;package&#x27;</span>: <span class="string">&#x27;&#x27;</span>,<span class="comment">//统一下单接口返回的 prepay_id 参数值，提交格式如：prepay_id=*</span></span><br><span class="line">    <span class="string">&#x27;signType&#x27;</span>: <span class="string">&#x27;MD5&#x27;</span>,<span class="comment">//签名类型，默认为MD5，支持HMAC-SHA256和MD5。注意此处需与统一下单的签名类型一致</span></span><br><span class="line">    <span class="string">&#x27;paySign&#x27;</span>: <span class="string">&#x27;&#x27;</span>,<span class="comment">//签名,具体签名方案参见微信公众号支付帮助文档;</span></span><br><span class="line">    <span class="string">&#x27;success&#x27;</span>:<span class="keyword">function</span>(<span class="params">res</span>)&#123;&#125;,<span class="comment">//成功回调</span></span><br><span class="line">    <span class="string">&#x27;fail&#x27;</span>:<span class="keyword">function</span>(<span class="params">res</span>)&#123;&#125;,<span class="comment">//失败</span></span><br><span class="line">    <span class="string">&#x27;complete&#x27;</span>:<span class="keyword">function</span>(<span class="params">res</span>)&#123;&#125;<span class="comment">//接口调用结束的回调函数（调用成功、失败都会执行）</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="小程序如何进行分包"><a href="#小程序如何进行分包" class="headerlink" title="小程序如何进行分包"></a>小程序如何进行分包</h2><pre><code>在subpackages字段里面的页面都是分包内容
root 分包根目录
name 分包别名
pages 分包页面路径
</code></pre>
<h2 id="普通分包和独立分包有什么不同"><a href="#普通分包和独立分包有什么不同" class="headerlink" title="普通分包和独立分包有什么不同"></a>普通分包和独立分包有什么不同</h2><pre><code>普通分包 那么该包必须依赖主包才能加载 不允许单独加载
独立分包 独立运行 不需要先加载主包
</code></pre>
<h2 id="分包有哪些注意事项"><a href="#分包有哪些注意事项" class="headerlink" title="分包有哪些注意事项"></a>分包有哪些注意事项</h2><pre><code>tabBar页面不允许放在分包中 只能放在主包
一个分包的根目录不能是另一个分包的子目录
一个分包不能require导入另一个分包的js文件 但是可以使用主包的js文件
一个分包不能使用另一个分包中的资源 但是可以使用主包资源
</code></pre>
<h1 id="uni-app"><a href="#uni-app" class="headerlink" title="uni-app"></a>uni-app</h1><h2 id="uni-app有哪些优势"><a href="#uni-app有哪些优势" class="headerlink" title="uni-app有哪些优势?"></a>uni-app有哪些优势?</h2><ul>
<li>开发者&#x2F;案例的数量最多</li>
<li>平台能力不受限制</li>
<li>性能体验优秀</li>
<li>周边生态丰富</li>
<li>学习成本低</li>
<li>开发成本低</li>
</ul>
<h2 id="uni-app语法、组件-及-生命周期-的-相同之处？"><a href="#uni-app语法、组件-及-生命周期-的-相同之处？" class="headerlink" title="uni-app语法、组件 及 生命周期 的 相同之处？"></a>uni-app语法、组件 及 生命周期 的 相同之处？</h2><ul>
<li>所有的语法接近与vue 可以使用vue的所有的指令，以及vue中的语法</li>
<li>所有的组件接近与微信小程序</li>
<li>所有的生命周期接近于小程序</li>
</ul>
<h4 id="uni-app的不同之处？"><a href="#uni-app的不同之处？" class="headerlink" title="uni-app的不同之处？"></a>uni-app的不同之处？</h4><ul>
<li>条件编译 可以在任意位置出现<br>是以注释的形式来添加条件编译</li>
</ul>
<p>#ifdef 表示包含那些端渲染，起始位置<br>#idndef 表示排除那些端渲染，起始位置<br>#endif 表示结束位置<br>各端的条件：<br>H5 表示移动端<br>MP 表示所有小程序<br>MP-WEIXIN 表示微信小程序<br>APP-PLUS 表示APP端</p>
<ul>
<li>APP端的Nvue开发<br>如果你不开发APP，那么是不需要使用Nvue的</li>
<li>HTML5+引擎<br>APP内置了HTML5+引擎，可以让js具有直接调用原生能力，在H5和小程序端没有HTML5+引擎的，因此如果需要使用这个引擎，还是需要加条件编译</li>
</ul>
<h2 id="网络封装"><a href="#网络封装" class="headerlink" title="网络封装"></a>网络封装</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> baseUrl=<span class="string">&quot;网址&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">request</span>(<span class="params">confing</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res,rej</span>)=&gt;</span>&#123;</span><br><span class="line">    wx.<span class="title function_">request</span>(&#123;</span><br><span class="line">      <span class="attr">url</span>:baseUrl+confing.<span class="property">url</span>,</span><br><span class="line">      <span class="attr">method</span>:confing.<span class="property">method</span>||<span class="string">&quot;GET&quot;</span>,</span><br><span class="line">      <span class="attr">data</span>:confing.<span class="property">data</span>,</span><br><span class="line">      <span class="attr">header</span>:&#123;</span><br><span class="line">        <span class="string">&quot;content-type&quot;</span>:<span class="string">&quot;application/x-www-form-urlencoded&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">success</span>:<span class="function">(<span class="params">r</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">res</span>(r)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><h2 id="vue2和Vue3的区别"><a href="#vue2和Vue3的区别" class="headerlink" title="vue2和Vue3的区别"></a>vue2和Vue3的区别</h2><h6 id="一-根节点不同"><a href="#一-根节点不同" class="headerlink" title="一. 根节点不同"></a>一. 根节点不同</h6><pre><code>vue2中必须要有根标签
vue3中可以没有根标签，会默认将多个根标签包裹在一个fragement虚拟标签中，有利于减少内存。
</code></pre>
<h6 id="二-组合式API和选项式API"><a href="#二-组合式API和选项式API" class="headerlink" title="二. 组合式API和选项式API"></a>二. 组合式API和选项式API</h6><pre><code>在vue2中采用选项式API，将数据和函数集中起来处理，将功能点切割了当逻辑复杂的时候不利于代码阅读。
在vue3中采用组合式API，将同一个功能的代码集中起来处理，使得代码更加有序，有利于代码的书写和维护。
</code></pre>
<h6 id="三-生命周期的变化"><a href="#三-生命周期的变化" class="headerlink" title="三. 生命周期的变化"></a>三. 生命周期的变化</h6><pre><code>创建前：beforeCreate -&gt; 使用setup()
创建后：created -&gt; 使用setup()
挂载前：beforeMount -&gt; onBeforeMount
挂载后：mounted -&gt; onMounted
更新前：beforeUpdate -&gt; onBeforeUpdate
更新后：updated -&gt; onUpdated
销毁前：beforeDestroy -&gt; onBeforeUnmount
销毁后：destroyed -&gt; onUnmounted
异常捕获：errorCaptured -&gt; onErrorCaptured
被激活：onActivated 被包含在&lt;keep-alive&gt;中的组件，会多出两个生命周期钩子函数。被激活时执行。
切换：onDeactivated 比如从 A 组件，切换到 B 组件，A 组件消失时执行
</code></pre>
<h6 id="四-v-if和v-for的优先级"><a href="#四-v-if和v-for的优先级" class="headerlink" title="四. v-if和v-for的优先级"></a>四. v-if和v-for的优先级</h6><pre><code>在vue2中v-for的优先级高于v-if，可以放在一起使用，但是不建议这么做，会带来性能上的浪费
在vue3中v-if的优先级高于v-for，一起使用会报错。可以通过在外部添加一个标签，将v-for移到外层
</code></pre>
<h6 id="五-diff算法不同"><a href="#五-diff算法不同" class="headerlink" title="五. diff算法不同"></a>五. diff算法不同</h6><ul>
<li><p>vue2中的diff算法<br>  遍历每一个虚拟节点，进行虚拟节点对比，并返回一个patch对象，用来存储两个节点不同的地方。<br>  用patch记录的消息去更新dom<br>  缺点：比较每一个节点，而对于一些不参与更新的元素，进行比较是有点消耗性能的。<br>  特点：特别要提一下Vue的patch是即时的，并不是打包所有修改最后一起操作DOM，也就是在vue中边记录变更新。（React则是将更新放入队列后集中处理）。</p>
</li>
<li><p>vue3中的diff算法<br>  在初始化的时候会给每一个虚拟节点添加一个patchFlags，是一种优化的标识。<br>  只会比较patchFlags发生变化的节点，进行识图更新。而对于patchFlags没有变化的元素作静态标记，在渲染的时候直接复用。</p>
</li>
</ul>
<h6 id="六-响应式原理不同"><a href="#六-响应式原理不同" class="headerlink" title="六. 响应式原理不同"></a>六. 响应式原理不同</h6><ul>
<li><p>vue2通过Object.definedProperty()的get()和set()来做数据劫持、结合和发布订阅者模式来实现，Object.definedProperty()会遍历每一个属性。</p>
</li>
<li><p>vue3通过proxy代理的方式实现。<br>  proxy的优势：不需要像Object.definedProperty()的那样遍历每一个属性，有一定的性能提升proxy可以理解为在目标对象之前架设一层“拦截”，外界对该对象的访问都必须通过这一层拦截。这个拦截可以对外界的访问进行过滤和改写。<br>  当属性过多的时候利用Object.definedProperty()要通过遍历的方式监听每一个属性。利用proxy则不需要遍历，会自动监听所有属性，有利于性能的提升</p>
</li>
</ul>
<h2 id="更多vue3请看我的vue3-ts-哦！"><a href="#更多vue3请看我的vue3-ts-哦！" class="headerlink" title="更多vue3请看我的vue3 + ts 哦！"></a>更多vue3请看我的vue3 + ts 哦！</h2></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/userimg.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/userimg.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">苏惜</div><div class="post-copyright__author_desc">生活明朗，万物可爱，美好生活，就是现在！</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2023/08/20/%E9%9D%A2%E8%AF%95%E9%A2%98/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2023/08/20/%E9%9D%A2%E8%AF%95%E9%A2%98/')">web前端面试题</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/img/wxewm.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/wxewm.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/zfbewm.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/zfbewm.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2023/08/20/%E9%9D%A2%E8%AF%95%E9%A2%98/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=web前端面试题&amp;url=http://example.com/2023/08/20/%E9%9D%A2%E8%AF%95%E9%A2%98/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">苏惜的小世界</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div></div><div class="post_share"><div class="social-share" data-image="/img/userimg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/08/15/Vue3+TS%E7%AC%AC%E4%BA%8C%E7%AB%A0/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Vue3+TypeScript (第二章：Vue3篇)</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/userimg.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/states.png" ait="status"/></div></div><div class="author-info__description"></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">苏惜</h1><div class="author-info__desc">生活明朗，万物可爱，美好生活，就是现在！</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/anzhiyu-c" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript"><span class="toc-number">1.</span> <span class="toc-text">JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.</span> <span class="toc-text">普通函数与箭头函数的区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generator%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">Generator函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFPromise"><span class="toc-number">1.3.</span> <span class="toc-text">什么是Promise?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.4.</span> <span class="toc-text">promise的使用场景?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">什么是回调地狱？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9this%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">对this的理解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.7.</span> <span class="toc-text">什么是事件循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.8.</span> <span class="toc-text">事件循环机制的组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2%E7%9A%84%E6%9C%BA%E5%88%B6-%E4%B9%9F%E5%8F%AB%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%9C%BA%E5%88%B6%EF%BC%88eventLoop%EF%BC%89"><span class="toc-number">1.9.</span> <span class="toc-text">事件轮询的机制 也叫事件循环的机制（eventLoop）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-in%E5%92%8Cfor-of%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">for in和for of区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">new一个对象的过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%9F"><span class="toc-number">1.12.</span> <span class="toc-text">什么是闭包？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86%E5%86%85%E5%AD%98%E5%92%8C%E6%A0%88%E5%86%85%E5%AD%98%EF%BC%9F"><span class="toc-number">1.13.</span> <span class="toc-text">什么是堆内存和栈内存？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96%EF%BC%9F"><span class="toc-number">1.14.</span> <span class="toc-text">节流和防抖？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E5%8E%9F%E6%95%B0%E7%BB%84%EF%BC%9F"><span class="toc-number">1.15.</span> <span class="toc-text">哪些数组方法可以改变原数组？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDOM"><span class="toc-number">1.16.</span> <span class="toc-text">虚拟DOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E4%B8%80%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.17.</span> <span class="toc-text">谈一谈垃圾回收机制?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#less-%E5%92%8C-sass-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.18.</span> <span class="toc-text">less 和 sass 的区别 ?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.19.</span> <span class="toc-text">CSS预处理器是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%AF%E5%87%BD%E6%95%B0"><span class="toc-number">1.20.</span> <span class="toc-text">纯函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.21.</span> <span class="toc-text">浏览器的同源策略机制?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#token%E4%B8%80%E8%88%AC%E5%AD%98%E6%94%BE%E5%9C%A8%E5%93%AA%E9%87%8C-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AD%98%E6%94%BE%E5%9C%A8cookie%E5%86%85"><span class="toc-number">1.22.</span> <span class="toc-text">token一般存放在哪里?为什么不存放在cookie内?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#token%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.23.</span> <span class="toc-text">token是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E6%9D%A10-5%E5%83%8F%E7%B4%A0%E7%9A%84%E7%BA%BF"><span class="toc-number">1.24.</span> <span class="toc-text">如何实现一条0.5像素的线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.25.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async-await"><span class="toc-number">1.26.</span> <span class="toc-text">async&#x2F;await</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#transform%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">1.27.</span> <span class="toc-text">transform的属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IE%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%A0%87%E5%87%86%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.28.</span> <span class="toc-text">IE盒模型和标准盒模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css%E5%AE%9E%E7%8E%B0%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-number">1.29.</span> <span class="toc-text">css实现三角形</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#axios"><span class="toc-number">1.30.</span> <span class="toc-text">axios</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JQ%E4%B8%AD-%E7%AC%A6"><span class="toc-number">1.31.</span> <span class="toc-text">JQ中$()符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.32.</span> <span class="toc-text">普通函数和构造函数的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%AE%E5%8A%A8%E4%B8%8E%E5%AE%9A%E4%BD%8D"><span class="toc-number">1.33.</span> <span class="toc-text">浮动与定位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="toc-number">1.34.</span> <span class="toc-text">递归函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#label%E6%A0%87%E7%AD%BE"><span class="toc-number">1.35.</span> <span class="toc-text">label标签</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ajax%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.36.</span> <span class="toc-text">ajax执行步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E9%80%89%E4%B8%ADcss"><span class="toc-number">1.37.</span> <span class="toc-text">最后一个元素选中css</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%97%E6%AF%8D"><span class="toc-number">1.38.</span> <span class="toc-text">统计字符串中出现最多的字母</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0"><span class="toc-number">1.39.</span> <span class="toc-text">自执行函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-%E5%AF%B9%E8%B1%A1%E5%8C%BA%E5%88%AB"><span class="toc-number">1.40.</span> <span class="toc-text">数组 对象区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.41.</span> <span class="toc-text">元素绑定事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%8B%89%E5%B9%B3"><span class="toc-number">1.42.</span> <span class="toc-text">数组拉平</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#postion%E5%B1%9E%E6%80%A7%E7%9A%84%E5%80%BC%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.43.</span> <span class="toc-text">postion属性的值有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%92%8C%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.44.</span> <span class="toc-text">静态方法 实例方法和原型方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#documentFragment"><span class="toc-number">1.45.</span> <span class="toc-text">documentFragment</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.46.</span> <span class="toc-text">创建对象的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%AF%B9%E8%B1%A1-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1-%E5%AE%BF%E4%B8%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.47.</span> <span class="toc-text">本地对象 内置对象 宿主对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPA"><span class="toc-number">1.48.</span> <span class="toc-text">SPA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JQ%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8"><span class="toc-number">1.49.</span> <span class="toc-text">JQ链式调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E9%A1%B5%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B"><span class="toc-number">1.50.</span> <span class="toc-text">网页渲染过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%B1%9E%E6%80%A7"><span class="toc-number">1.51.</span> <span class="toc-text">获取元素属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">1.52.</span> <span class="toc-text">回调函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css%E6%9D%83%E9%87%8D"><span class="toc-number">1.53.</span> <span class="toc-text">css权重</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#delete%E4%B8%8Evue-delete"><span class="toc-number">1.54.</span> <span class="toc-text">delete与vue.delete</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.55.</span> <span class="toc-text">盒子模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#javaScript%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.56.</span> <span class="toc-text">javaScript的组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSON%E6%96%B9%E6%B3%95"><span class="toc-number">1.57.</span> <span class="toc-text">JSON方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">1.58.</span> <span class="toc-text">http状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%9C%86%E8%A7%92"><span class="toc-number">1.59.</span> <span class="toc-text">最后一个圆角</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#document-reday%E4%B8%8Ewindow-onload%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.60.</span> <span class="toc-text">document.reday与window.onload的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#if%E6%9C%89%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%90%97"><span class="toc-number">1.61.</span> <span class="toc-text">if有作用域吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ajax%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E7%8A%B6%E6%80%81"><span class="toc-number">1.62.</span> <span class="toc-text">ajax生命周期&#x2F;状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5"><span class="toc-number">1.63.</span> <span class="toc-text">同步异步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9Dcookie%E5%92%8C%E6%8C%81%E4%B9%85cookie"><span class="toc-number">1.64.</span> <span class="toc-text">会话cookie和持久cookie</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.65.</span> <span class="toc-text">typeof返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4"><span class="toc-number">1.66.</span> <span class="toc-text">获取时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#url%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B"><span class="toc-number">1.67.</span> <span class="toc-text">url请求过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.68.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98"><span class="toc-number">1.69.</span> <span class="toc-text">回流和重绘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98"><span class="toc-number">1.70.</span> <span class="toc-text">如何减少回流和重绘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GET-%E5%92%8C-POST"><span class="toc-number">1.71.</span> <span class="toc-text">GET 和 POST</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">1.72.</span> <span class="toc-text">内存泄漏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.73.</span> <span class="toc-text">深拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.74.</span> <span class="toc-text">浅拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.75.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-number">1.76.</span> <span class="toc-text">事件冒泡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#H5%E6%96%B0%E6%A0%87%E7%AD%BE"><span class="toc-number">1.77.</span> <span class="toc-text">H5新标签</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8"><span class="toc-number">1.78.</span> <span class="toc-text">浏览器内核</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F"><span class="toc-number">1.79.</span> <span class="toc-text">跨域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BDjs"><span class="toc-number">1.80.</span> <span class="toc-text">异步加载js</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#px%EF%BC%8Cem%E5%92%8Crem%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.81.</span> <span class="toc-text">px，em和rem的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#link%E5%92%8C-import%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.82.</span> <span class="toc-text">link和@import的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.83.</span> <span class="toc-text">性能优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#img-%E4%B8%AD-title%E5%92%8Calt%E5%8C%BA%E5%88%AB"><span class="toc-number">1.84.</span> <span class="toc-text">img 中 title和alt区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM%E4%B8%8EBOM%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.85.</span> <span class="toc-text">DOM与BOM分别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-number">1.86.</span> <span class="toc-text">数组去重</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%88%86%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.87.</span> <span class="toc-text">区分数组对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.88.</span> <span class="toc-text">反转字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">1.89.</span> <span class="toc-text">事件委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B"><span class="toc-number">1.90.</span> <span class="toc-text">原型对象和对象的原型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.91.</span> <span class="toc-text">形参和实参是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arguments%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.92.</span> <span class="toc-text">arguments是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.93.</span> <span class="toc-text">解决跨域的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.94.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81%EF%BC%9A%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81%E3%80%81%E6%8A%BD%E8%B1%A1%E3%80%82"><span class="toc-number">1.94.0.0.0.1.</span> <span class="toc-text">面向对象的特征：封装、继承、多态、抽象。</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">1.95.</span> <span class="toc-text">原型 原型链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E6%8C%87%E5%90%91%E7%9A%84%E6%83%85%E5%86%B5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.96.</span> <span class="toc-text">this指向的情况有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Null%E5%92%8Cundefined%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.97.</span> <span class="toc-text">Null和undefined的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Call%E3%80%81apply%E3%80%81bind%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.98.</span> <span class="toc-text">Call、apply、bind的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOCtype-document-type-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.99.</span> <span class="toc-text">DOCtype(document type)的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS%E8%AF%AD%E8%A8%80%E4%B8%BB%E8%A6%81%E5%88%86%E5%93%AA%E5%87%A0%E9%83%A8%E5%88%86-%E4%B8%89%E9%83%A8%E5%88%86"><span class="toc-number">1.100.</span> <span class="toc-text">JS语言主要分哪几部分 三部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E3%80%81%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.101.</span> <span class="toc-text">原型对象、实例对象、构造函数三者之间的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E8%87%AA%E8%BA%AB%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%AD%A4%E5%B1%9E%E6%80%A7"><span class="toc-number">1.102.</span> <span class="toc-text">判断对象自身是否包含此属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E5%87%BD%E6%95%B0"><span class="toc-number">1.103.</span> <span class="toc-text">认识函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.104.</span> <span class="toc-text">JavaScript数组常用方法有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E8%87%B4JavaScript%E4%B8%ADthis%E6%8C%87%E5%90%91%E6%B7%B7%E4%B9%B1%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.105.</span> <span class="toc-text">导致JavaScript中this指向混乱的原因是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C%EF%BC%9A"><span class="toc-number">1.105.0.0.0.1.</span> <span class="toc-text">1、函数调用方式不同：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">1.105.0.0.0.2.</span> <span class="toc-text">2、箭头函数的使用：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%E3%80%81%E4%BD%BF%E7%94%A8apply%E3%80%81call%E3%80%81bind%E6%96%B9%E6%B3%95"><span class="toc-number">1.105.0.0.0.3.</span> <span class="toc-text">3、使用apply、call、bind方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B5%8C%E5%A5%97%E5%92%8C%E7%BB%A7%E6%89%BF%EF%BC%9A"><span class="toc-number">1.105.0.0.0.4.</span> <span class="toc-text">4、对象的嵌套和继承：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8"><span class="toc-number">1.106.</span> <span class="toc-text">怎么实现虚拟列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E5%AF%B9%E8%BD%AE%E8%AF%A2%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.107.</span> <span class="toc-text">说说对轮询的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AE%E8%AF%A2"><span class="toc-number">1.107.0.0.0.1.</span> <span class="toc-text">什么是轮询</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2%E5%92%8C%E9%95%BF%E8%BD%AE%E8%AF%A2%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.107.0.0.0.2.</span> <span class="toc-text">轮询和长轮询有什么区别</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E8%BD%AE%E8%AF%A2%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88"><span class="toc-number">1.107.0.0.0.3.</span> <span class="toc-text">前端轮询的实现方法有什么</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9"><span class="toc-number">1.107.0.0.0.4.</span> <span class="toc-text">轮询有什么缺点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E8%BD%AE%E8%AF%A2%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">1.107.0.0.0.5.</span> <span class="toc-text">如何避免轮询的缺点</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">1.108.</span> <span class="toc-text">作用域和作用域链</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.108.1.</span> <span class="toc-text">作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.108.1.0.0.1.</span> <span class="toc-text">全局作用域</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.108.1.0.0.2.</span> <span class="toc-text">函数作用域</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.108.1.0.0.3.</span> <span class="toc-text">块级作用域</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.108.2.</span> <span class="toc-text">词法作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">1.108.3.</span> <span class="toc-text">作用域链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">1.109.</span> <span class="toc-text">ES6有哪些新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81let%E3%80%81const-%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%92%8C-var-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.109.1.</span> <span class="toc-text">1、let、const 块级作用域以及和 var 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%A7%A3%E6%9E%84-%E5%BF%AB%E9%80%9F%E6%8F%90%E5%8F%96%E6%95%B0%E7%BB%84-%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">1.109.2.</span> <span class="toc-text">2、解构-快速提取数组&#x2F;对象中的元素</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84"><span class="toc-number">1.109.2.0.0.1.</span> <span class="toc-text">数组解构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84"><span class="toc-number">1.109.2.0.0.2.</span> <span class="toc-text">对象解构</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.109.3.</span> <span class="toc-text">3、模板字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95"><span class="toc-number">1.109.4.</span> <span class="toc-text">4、字符串扩展方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC-%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0"><span class="toc-number">1.109.5.</span> <span class="toc-text">5、参数默认值&amp;剩余参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%B1%95%E5%BC%80%E6%95%B0%E7%BB%84"><span class="toc-number">1.109.6.</span> <span class="toc-text">6、展开数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">1.109.7.</span> <span class="toc-text">7、箭头函数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%B9%E6%80%A7-%E4%BC%98%E5%8A%BF%EF%BC%9A"><span class="toc-number">1.109.7.0.0.1.</span> <span class="toc-text">特性&amp;优势：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F%E5%A2%9E%E5%BC%BA"><span class="toc-number">1.109.8.</span> <span class="toc-text">8、对象字面量增强</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81Object-assign-target1-target2-targetN-%E5%A4%8D%E5%88%B6-%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.109.9.</span> <span class="toc-text">9、Object.assign(target1, target2, targetN)-复制&#x2F;合并对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81Object-is-value1-value2"><span class="toc-number">1.109.10.</span> <span class="toc-text">10、Object.is(value1, value2)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81Proxy-object-handler"><span class="toc-number">1.109.11.</span> <span class="toc-text">11、Proxy(object, handler)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-Reflect"><span class="toc-number">1.109.12.</span> <span class="toc-text">12.Reflect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-Promise"><span class="toc-number">1.109.13.</span> <span class="toc-text">13.Promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-class-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95-%E7%BB%A7%E6%89%BF"><span class="toc-number">1.109.14.</span> <span class="toc-text">14.class&amp;静态方法&amp;继承</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.109.14.0.0.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.109.14.0.0.2.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%EF%BC%9A%E5%AD%90%E7%B1%BB%E4%BD%BF%E7%94%A8-extends-%E5%85%B3%E9%94%AE%E5%AD%97%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E6%89%80%E6%9C%89%E5%B1%9E%E6%80%A7"><span class="toc-number">1.109.14.0.0.3.</span> <span class="toc-text">继承：子类使用 extends 关键字实现继承，可以继承父类所有属性</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-Set"><span class="toc-number">1.109.15.</span> <span class="toc-text">15.Set</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">1.109.15.0.0.1.</span> <span class="toc-text">说明：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-number">1.109.15.0.0.2.</span> <span class="toc-text">特性：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%94%A8%E9%80%94%EF%BC%9A"><span class="toc-number">1.109.15.0.0.3.</span> <span class="toc-text">用途：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-Map"><span class="toc-number">1.109.16.</span> <span class="toc-text">16.Map</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E%EF%BC%9A-1"><span class="toc-number">1.109.16.0.0.1.</span> <span class="toc-text">说明：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.109.16.0.0.2.</span> <span class="toc-text">区别：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%EF%BC%9A"><span class="toc-number">1.109.16.0.0.3.</span> <span class="toc-text">实例：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-Symbol"><span class="toc-number">1.109.17.</span> <span class="toc-text">17.Symbol</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E%EF%BC%9A-2"><span class="toc-number">1.109.17.0.0.1.</span> <span class="toc-text">说明：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-number">1.109.17.0.0.2.</span> <span class="toc-text">作用：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-for%E2%80%A6of%E2%80%A6"><span class="toc-number">1.109.18.</span> <span class="toc-text">18.for…of…</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%94%A8%E9%80%94%EF%BC%9A-1"><span class="toc-number">1.109.18.0.0.1.</span> <span class="toc-text">用途：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%EF%BC%9A-1"><span class="toc-number">1.109.18.0.0.2.</span> <span class="toc-text">特性：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%EF%BC%9A-1"><span class="toc-number">1.109.18.0.0.3.</span> <span class="toc-text">实例：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.109.19.</span> <span class="toc-text">19. 迭代器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%EF%BC%9A-1"><span class="toc-number">1.109.19.0.0.1.</span> <span class="toc-text">作用：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87-for%E2%80%A6of%E2%80%A6%E5%8E%BB%E8%BF%AD%E4%BB%A3%E5%86%85%E9%83%A8%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">1.109.19.0.0.2.</span> <span class="toc-text">外部可以通过 for…of…去迭代内部的数据</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20%E3%80%81Generator%E5%87%BD%E6%95%B0"><span class="toc-number">1.109.20.</span> <span class="toc-text">20、Generator函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-includes-%E5%87%BD%E6%95%B0-es2016"><span class="toc-number">1.109.21.</span> <span class="toc-text">21.includes 函数-es2016</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E8%BF%90%E7%AE%97%E7%AC%A6-es2016"><span class="toc-number">1.109.22.</span> <span class="toc-text">22. 运算符-es2016</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-values-%E5%87%BD%E6%95%B0-es2017"><span class="toc-number">1.109.23.</span> <span class="toc-text">23.values 函数-es2017</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-entries-%E5%87%BD%E6%95%B0-es2017"><span class="toc-number">1.109.24.</span> <span class="toc-text">24.entries 函数-es2017</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-Object-getOwnPropertyDescriptors-obj-es2017"><span class="toc-number">1.109.25.</span> <span class="toc-text">25.Object.getOwnPropertyDescriptors(obj)-es2017</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-padStart-padEnd-%E5%87%BD%E6%95%B0-es2017"><span class="toc-number">1.109.26.</span> <span class="toc-text">26.padStart, padEnd 函数-es2017</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%EF%BC%9A"><span class="toc-number">1.109.26.0.0.1.</span> <span class="toc-text">参数：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%84%E5%88%99%EF%BC%9A"><span class="toc-number">1.109.26.0.0.2.</span> <span class="toc-text">规则：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%EF%BC%9A-2"><span class="toc-number">1.109.26.0.0.3.</span> <span class="toc-text">作用：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">1.110.</span> <span class="toc-text">函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.110.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.110.2.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.110.3.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">1.110.3.0.0.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">1.110.3.0.0.2.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cookie%E3%80%81localStorage%E5%92%8CsessionStorage-%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.111.</span> <span class="toc-text">cookie、localStorage和sessionStorage 三者之间有什么区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.111.1.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E6%94%BE%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.111.2.</span> <span class="toc-text">存放数据大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%93%E7%94%A8%E6%80%A7"><span class="toc-number">1.111.3.</span> <span class="toc-text">易用性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%BC%93%E5%AD%98%EF%BC%8C%E5%90%84%E7%A7%8D%E7%BC%93%E5%AD%98%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">1.112.</span> <span class="toc-text">浏览器有哪几种缓存，各种缓存的优先级是什么样的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98%EF%BC%9A"><span class="toc-number">1.112.1.</span> <span class="toc-text">强制缓存：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%EF%BC%9A"><span class="toc-number">1.112.2.</span> <span class="toc-text">协商缓存：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service-Worker-%E7%BC%93%E5%AD%98%EF%BC%9A"><span class="toc-number">1.112.3.</span> <span class="toc-text">Service Worker 缓存：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Web-Storage-%E7%BC%93%E5%AD%98%EF%BC%9A"><span class="toc-number">1.112.4.</span> <span class="toc-text">Web Storage 缓存：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%99%E4%BA%9B%E7%BC%93%E5%AD%98%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">1.112.5.</span> <span class="toc-text">这些缓存的优先级如下：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E9%A6%96%E5%B1%8F%E6%8F%90%E9%80%9F"><span class="toc-number">1.113.</span> <span class="toc-text">项目首屏提速</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%84%9F%E7%9F%A5%E6%8F%90%E9%80%9F"><span class="toc-number">1.113.1.</span> <span class="toc-text">用户感知提速</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%8A%A0%E8%BD%BD%E6%8F%90%E9%80%9F"><span class="toc-number">1.113.2.</span> <span class="toc-text">技术加载提速</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css%E5%85%83%E7%B4%A0%E9%9A%90%E8%97%8F"><span class="toc-number">1.114.</span> <span class="toc-text">css元素隐藏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD"><span class="toc-number">1.115.</span> <span class="toc-text">css元素居中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#em%E5%92%8Crem%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.116.</span> <span class="toc-text">em和rem的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#em"><span class="toc-number">1.116.0.0.0.1.</span> <span class="toc-text">em</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#rem"><span class="toc-number">1.116.0.0.0.2.</span> <span class="toc-text">rem</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP1-0%E5%92%8CHTTP2-0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.117.</span> <span class="toc-text">HTTP1.0和HTTP2.0的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1%E3%80%81%E8%BF%9E%E6%8E%A5%E5%A4%8D%E7%94%A8"><span class="toc-number">1.117.0.0.0.1.</span> <span class="toc-text">1、连接复用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2%E3%80%81%E8%AF%B7%E6%B1%82-%E5%93%8D%E5%BA%94%E6%96%B9%E5%BC%8F"><span class="toc-number">1.117.0.0.0.2.</span> <span class="toc-text">2、请求-响应方式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3%E3%80%81%E5%A4%B4%E9%83%A8%E5%8E%8B%E7%BC%A9"><span class="toc-number">1.117.0.0.0.3.</span> <span class="toc-text">3、头部压缩</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.117.0.0.0.4.</span> <span class="toc-text">4、二进制协议</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5%E3%80%81%E6%B5%81%E6%8E%A7%E5%88%B6%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.117.0.0.0.5.</span> <span class="toc-text">5、流控制和优先级</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6%E3%80%81%E9%95%BF%E8%BF%9E%E6%8E%A5%E6%94%AF%E6%8C%81"><span class="toc-number">1.117.0.0.0.6.</span> <span class="toc-text">6、长连接支持</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88DFS%EF%BC%89%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95"><span class="toc-number">1.118.</span> <span class="toc-text">（DFS）深度优先搜索算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFS%EF%BC%88%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">1.119.</span> <span class="toc-text">BFS（宽度优先算法）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">1.120.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.121.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.122.</span> <span class="toc-text">JavaScript中常见的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Queue-%E9%98%9F%E5%88%97"><span class="toc-number">1.122.0.0.0.1.</span> <span class="toc-text">Queue 队列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Stack-%E6%A0%88"><span class="toc-number">1.122.0.0.0.2.</span> <span class="toc-text">Stack 栈</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Linked-List-%E9%93%BE%E8%A1%A8"><span class="toc-number">1.122.0.0.0.3.</span> <span class="toc-text">Linked List 链表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">1.122.0.0.0.4.</span> <span class="toc-text">集合</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">1.122.0.0.0.5.</span> <span class="toc-text">树</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.122.0.0.0.6.</span> <span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">1.122.0.0.0.7.</span> <span class="toc-text">堆</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#es6%E4%B8%ADmap%E5%92%8Cobject%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.123.</span> <span class="toc-text">es6中map和object的区别是什么</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue"><span class="toc-number">2.</span> <span class="toc-text">Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BC%98%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.</span> <span class="toc-text">Vue的最大优势是什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVVM%E5%92%8CMVC%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.2.</span> <span class="toc-text">MVVM和MVC区别是什么?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MVC-%EF%BC%9A-%E4%BC%A0%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%82"><span class="toc-number">2.2.1.</span> <span class="toc-text">MVC ： 传统的设计模式。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVVM%EF%BC%9A-vue%E6%89%80%E4%BD%BF%E7%94%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.2.</span> <span class="toc-text">MVVM： vue所使用的设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%9C%A8vue%E4%B8%AD%EF%BC%8C%E4%B8%8D%E6%8E%A8%E8%8D%90%E7%9B%B4%E6%8E%A5%E6%89%8B%E5%8A%A8%E6%93%8D%E4%BD%9CDOM%EF%BC%81%EF%BC%81%EF%BC%81"><span class="toc-number">2.2.2.0.0.1.</span> <span class="toc-text">1. 在vue中，不推荐直接手动操作DOM！！！</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E5%9C%A8vue%E4%B8%AD%EF%BC%8C%E9%80%9A%E8%BF%87%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E8%A7%86%E5%9B%BE%EF%BC%8C%E4%B8%8D%E8%A6%81%E5%9C%A8%E6%83%B3%E7%9D%80%E6%80%8E%E4%B9%88%E6%93%8D%E4%BD%9CDOM%EF%BC%8C%E8%80%8C%E6%98%AF%E6%83%B3%E7%9D%80%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%EF%BC%81%EF%BC%81-%E6%80%9D%E6%83%B3%E8%BD%AC%E5%8F%98"><span class="toc-number">2.2.2.0.0.2.</span> <span class="toc-text">2. 在vue中，通过数据驱动视图，不要在想着怎么操作DOM，而是想着如何操作数据！！(思想转变)</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8A%A0%E8%BD%BD%E9%A1%B5%E9%9D%A2"><span class="toc-number">2.3.</span> <span class="toc-text">vue第一次加载页面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E5%B8%B8%E7%94%A8%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">2.4.</span> <span class="toc-text">Vue常用修饰符有哪些?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9Vue%E6%B8%90%E8%BF%9B%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.5.</span> <span class="toc-text">对Vue渐进式的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.6.</span> <span class="toc-text">vue 生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E5%87%BA%E8%87%B3%E5%B0%914%E4%B8%AAVue%E6%8C%87%E4%BB%A4%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-number">2.7.</span> <span class="toc-text">说出至少4个Vue指令及作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%81%BF%E5%85%8Dv-for%E5%92%8Cv-if%E5%9C%A8%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8"><span class="toc-number">2.8.</span> <span class="toc-text">为什么避免v-for和v-if在一起使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-if%E4%B8%8Ev-show%E5%8C%BA%E5%88%AB%E9%80%90%E5%AD%97%E7%A8%BF"><span class="toc-number">2.9.</span> <span class="toc-text">v-if与v-show区别逐字稿</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E4%B8%ADkey%E5%80%BC%E4%BD%9C%E7%94%A8"><span class="toc-number">2.10.</span> <span class="toc-text">Vue中key值作用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%AE%98%E4%BD%A0%E5%A5%BD-%E6%88%91%E6%98%AF%E8%BF%99%E4%B9%88%E7%90%86%E8%A7%A3key%E5%80%BC%E7%9A%84-key%E5%80%BC%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8%E6%98%AF%E7%BB%99%E5%85%83%E7%B4%A0%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E7%AC%A6-%E7%94%A8%E4%BA%8E%E6%8F%90%E9%AB%98vue%E6%B8%B2%E6%9F%93%E6%80%A7%E8%83%BD-%E5%BD%93data%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%E7%9A%84%E6%97%B6%E5%80%99-vue%E4%BC%9A%E4%BD%BF%E7%94%A8diff%E7%AE%97%E6%B3%95%E6%9D%A5%E5%AF%B9%E6%AF%94%E6%96%B0%E6%97%A7%E8%99%9A%E6%8B%9FDOM-%E5%A6%82%E6%9E%9Ckey%E5%80%BC%E7%9B%B8%E5%90%8C-%E6%89%8D%E4%BC%9A%E8%80%83%E8%99%91%E5%A4%8D%E7%94%A8%E5%85%83%E7%B4%A0-%E5%A6%82%E6%9E%9Ckey%E5%80%BC%E4%B8%8D%E5%90%8C-%E5%88%99%E4%BC%9A%E5%BC%BA%E5%88%B6%E6%9B%B4%E6%96%B0%E5%85%83%E7%B4%A0-%E4%B8%80%E8%88%AC%E9%80%9A%E8%BF%87%E7%BB%99%E5%85%83%E7%B4%A0key%E8%AE%BE%E7%BD%AE%E4%B8%BAid-%E6%9D%A5%E4%BF%9D%E8%AF%81vue%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E6%9C%80%E5%A4%A7%E9%99%90%E5%BA%A6%E5%A4%8D%E7%94%A8%E7%9B%B8%E5%90%8C%E7%9A%84key%E5%80%BC%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">2.10.0.0.0.1.</span> <span class="toc-text">面试官你好,我是这么理解key值的,key值的主要作用是给元素添加一个唯一标识符,用于提高vue渲染性能,当data发生变化的时候,vue会使用diff算法来对比新旧虚拟DOM.如果key值相同,才会考虑复用元素.如果key值不同,则会强制更新元素.一般通过给元素key设置为id,来保证vue更新数据的时候可以最大限度复用相同的key值的元素.</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-for%E6%8C%87%E4%BB%A4%E4%BD%BF%E7%94%A8key%E5%80%BC%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">2.11.</span> <span class="toc-text">v-for指令使用key值几种情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E4%B8%AD-key%E4%BD%9C%E7%94%A8-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-number">2.12.</span> <span class="toc-text">Vue中:key作用, 为什么不能用索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-model%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86"><span class="toc-number">2.13.</span> <span class="toc-text">v-model的作用及原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E4%B8%AD%E6%9C%89%E6%97%B6%E5%80%99%E6%95%B0%E7%BB%84%E4%BC%9A%E6%9B%B4%E6%96%B0%E9%A1%B5%E9%9D%A2%EF%BC%8C%E6%9C%89%E6%97%B6%E5%80%99%E4%B8%8D%E6%9B%B4%E6%96%B0%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">2.14.</span> <span class="toc-text">Vue中有时候数组会更新页面，有时候不更新，这是为什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E8%AF%B4%E4%B8%8B%E5%B0%81%E8%A3%85-vue-%E7%BB%84%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">2.15.</span> <span class="toc-text">请说下封装 vue 组件的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC"><span class="toc-number">2.16.</span> <span class="toc-text">vue组件传值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E7%BB%84%E4%BB%B6-data-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E6%98%AF%E5%87%BD%E6%95%B0"><span class="toc-number">2.17.</span> <span class="toc-text">Vue 组件 data 为什么必须是函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B%E7%BB%84%E4%BB%B6%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">2.18.</span> <span class="toc-text">讲一下组件的命名规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scoped%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="toc-number">2.19.</span> <span class="toc-text">scoped作用与原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E7%9A%84-nextTick-%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.20.</span> <span class="toc-text">Vue 的 nextTick 的原理是什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BF%AE%E6%94%B9%E7%88%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">2.21.</span> <span class="toc-text">子组件修改父组件的数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-number">2.22.</span> <span class="toc-text">vue事件冒泡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F"><span class="toc-number">2.23.</span> <span class="toc-text">响应式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E6%A7%BD"><span class="toc-number">2.24.</span> <span class="toc-text">插槽</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-show-v-if"><span class="toc-number">2.25.</span> <span class="toc-text">v-show  v-if</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B-%E5%AE%83%E6%9C%89%E5%93%AA%E4%BA%9B%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-%EF%BC%88%E5%BF%85%E4%BC%9A%EF%BC%89"><span class="toc-number">2.26.</span> <span class="toc-text">自定义指令的方法有哪些?它有哪些钩子函数?还有哪些钩子函数参数?（必会）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E8%B7%AF%E7%94%B1%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="toc-number">2.27.</span> <span class="toc-text">vue路由作用与原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E4%B9%8B%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%B3%E8%BD%AC%E7%9A%84%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F"><span class="toc-number">2.28.</span> <span class="toc-text">路由之间是怎么跳转的？有哪些方式?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%8D%E7%94%A8%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E7%9A%84%E6%97%B6%E5%80%99%E9%98%B2%E6%AD%A2%E5%88%B7%E6%96%B0%E7%99%BD%E5%B1%8F"><span class="toc-number">2.29.</span> <span class="toc-text">再用动态路由的时候防止刷新白屏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-router%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1%EF%BC%88%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E5%85%AD%E4%B8%AA%E6%B5%81%E7%A8%8B%EF%BC%89"><span class="toc-number">2.30.</span> <span class="toc-text">vue-router怎么配置路由（路由配置六个流程）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-router%E7%9A%84%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%88%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB%EF%BC%89"><span class="toc-number">2.31.</span> <span class="toc-text">vue-router的钩子函数都有哪些（导航守卫）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="toc-number">2.32.</span> <span class="toc-text">完整的导航解析流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%EF%BC%9F"><span class="toc-number">2.33.</span> <span class="toc-text">什么是路由守卫？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%80%BC%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D"><span class="toc-number">2.34.</span> <span class="toc-text">路由传值的方式有哪几种</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8E%A5%E6%94%B6%E5%AF%B9%E5%BA%94%E7%9A%84%E5%80%BC%EF%BC%9F"><span class="toc-number">2.35.</span> <span class="toc-text">Vue路由传参方式，如何接收对应的值？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E7%9A%84%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%BC%8F%EF%BC%9Ahash%E6%A8%A1%E5%BC%8F%E5%92%8Chistory%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.36.</span> <span class="toc-text">Vue的路由实现模式：hash模式和history模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E8%AF%B4%E5%87%BA%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E9%A1%B9%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-number">2.37.</span> <span class="toc-text">请说出路由配置项常用的属性及作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#route%E5%92%8C-router%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.38.</span> <span class="toc-text">$route和$router的区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#keep-alive"><span class="toc-number">2.39.</span> <span class="toc-text">keep-alive</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%9Fkeep-alive%E6%9C%89%E5%85%B3%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%98%AF%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.40.</span> <span class="toc-text">跟keep-alive有关的生命周期是哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vuex%E4%BD%9C%E7%94%A8%E5%8F%8A%E4%BA%94%E5%A4%A7%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">2.41.</span> <span class="toc-text">vuex作用及五大组成部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vuex%E4%B8%ADaction%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.42.</span> <span class="toc-text">vuex中action工作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vuex%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%E4%B8%A2%E5%A4%B1%E6%95%B0%E6%8D%AE%E5%8E%9F%E5%9B%A0%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">2.43.</span> <span class="toc-text">vuex刷新页面丢失数据原因和解决方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%9C%A8vue%E4%B8%AD%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91"><span class="toc-number">2.44.</span> <span class="toc-text">说一下你在vue中踩过的坑</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.</span> <span class="toc-text">小程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.1.</span> <span class="toc-text">小程序的登录流程是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B9%E7%9B%AE%E5%85%81%E8%AE%B8%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BD%93%E7%A7%AF%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="toc-number">3.2.</span> <span class="toc-text">小程序项目允许的最大体积是多少</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%99%AE%E9%80%9A%E7%BD%91%E9%A1%B5%E5%8C%BA%E5%88%AB"><span class="toc-number">3.3.</span> <span class="toc-text">小程序和普通网页区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A1%B9%E7%9B%AE%E6%9E%84%E6%88%90"><span class="toc-number">3.4.</span> <span class="toc-text">小程序的项目构成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">3.5.</span> <span class="toc-text">小程序页面的组成部分**</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#app-json%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.6.</span> <span class="toc-text">## app.json中的配置有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#window%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.7.</span> <span class="toc-text">window配置中的配置项有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tabBar%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.8.</span> <span class="toc-text">tabBar配置中的配置项有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89tabBar"><span class="toc-number">3.9.</span> <span class="toc-text">如何自定义tabBar</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#networkTimeout%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.10.</span> <span class="toc-text">networkTimeout配置中的配置项有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%B2%E6%9F%93%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93"><span class="toc-number">3.11.</span> <span class="toc-text">小程序渲染数据如何渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E7%9A%84%E6%8C%87%E4%BB%A4%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.12.</span> <span class="toc-text">列表渲染的指令是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9item%E5%92%8Cindex%E7%9A%84%E5%90%8D%E5%AD%97"><span class="toc-number">3.13.</span> <span class="toc-text">列表渲染如何修改item和index的名字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E5%8F%AF%E4%BB%A5%E6%B8%B2%E6%9F%93%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.14.</span> <span class="toc-text">列表渲染可以渲染的数据类型有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#block%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.15.</span> <span class="toc-text">block标签的作用是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BF%AE%E6%94%B9"><span class="toc-number">3.16.</span> <span class="toc-text">小程序中如何实现响应式的数据修改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.17.</span> <span class="toc-text">小程序生命周期函数有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BA%A7%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.18.</span> <span class="toc-text">页面级生命周期函数有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E7%BA%A7%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.19.</span> <span class="toc-text">组件级生命周期函数有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%BB%E8%A6%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.20.</span> <span class="toc-text">组件的主要生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#input%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%8C%E7%BA%BF%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A"><span class="toc-number">3.21.</span> <span class="toc-text">input组件如何实现双线数据绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#input%E7%BB%84%E4%BB%B6%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E5%86%85%E5%AE%B9%E6%97%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BF%AE%E6%94%B9%E9%94%AE%E7%9B%98%E5%8F%B3%E4%B8%8B%E8%A7%92%E6%96%87%E5%AD%97%E6%8F%90%E7%A4%BA%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%E6%88%90%E5%93%AA%E4%BA%9B%E5%80%BC"><span class="toc-number">3.22.</span> <span class="toc-text">input组件用户输入内容时，如果修改键盘右下角文字提示，可以修改成哪些值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#input%E7%BB%84%E4%BB%B6%E4%B8%AD%E6%9C%89%E5%87%A0%E7%A7%8D%E9%94%AE%E7%9B%98%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.23.</span> <span class="toc-text">input组件中有几种键盘类型，分别是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scroll-view%E7%BB%84%E4%BB%B6%E6%83%B3%E8%A6%81%E7%BA%B5%E5%90%91%E6%BB%9A%E5%8A%A8%E6%97%B6%EF%BC%8C%E5%BF%85%E9%A1%BB%E8%A6%81%E8%AE%BE%E7%BD%AE%E7%9A%84%E5%86%85%E5%AE%B9%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.24.</span> <span class="toc-text">scroll-view组件想要纵向滚动时，必须要设置的内容有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#navigator%E7%BB%84%E4%BB%B6%E7%9A%84%E8%B7%B3%E8%BD%AC%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.25.</span> <span class="toc-text">navigator组件的跳转方式有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#navigate%E5%92%8C-redirect%E6%96%B9%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-number">3.26.</span> <span class="toc-text">navigate和 redirect方式有什么区别，共同点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#navigate%E5%92%8C-switchTab-%E6%96%B9%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-number">3.27.</span> <span class="toc-text">navigate和 switchTab 方式有什么区别，共同点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#navigate%E5%92%8C-reLaunch-%E6%96%B9%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-number">3.28.</span> <span class="toc-text">navigate和 reLaunch 方式有什么区别，共同点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E7%BB%84%E4%BB%B6%E6%98%AF%E5%90%A6%E6%9C%89%E9%BB%98%E8%AE%A4%E5%AE%BD%E9%AB%98%EF%BC%8C%E9%BB%98%E8%AE%A4%E5%AE%BD%E9%AB%98%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="toc-number">3.29.</span> <span class="toc-text">图片组件是否有默认宽高，默认宽高是多少?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wxss%E5%92%8Ccss%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.30.</span> <span class="toc-text">wxss和css的不同之处有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%9C%89%E5%87%A0%E7%A7%8D%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">3.31.</span> <span class="toc-text">小程序有几种绑定事件的方式，有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%BA%8B%E4%BB%B6%E6%9C%89%E5%93%AA%EF%BC%8C%E8%AF%B4%E5%87%BA5%E4%B8%AA%E4%BB%A5%E4%B8%8A"><span class="toc-number">3.32.</span> <span class="toc-text">常见移动端事件有哪，说出5个以上</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7%EF%BC%8C%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.33.</span> <span class="toc-text">触摸事件的事件对象中有哪些常见属性，作用是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#target-%E5%92%8CcurrentTarget%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.34.</span> <span class="toc-text">target 和currentTarget两者的区别是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE"><span class="toc-number">3.35.</span> <span class="toc-text">小程序中的事件如何传递数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%85%A8%E5%B1%80%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="toc-number">3.36.</span> <span class="toc-text">小程序中全局数据如何使用，有什么特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6"><span class="toc-number">3.37.</span> <span class="toc-text">如何自定义一个组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E6%A0%B7%E5%BC%8F%E6%98%AF%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E7%9A%84"><span class="toc-number">3.38.</span> <span class="toc-text">关于父子组件之间样式是如何影响的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E5%A4%96%E9%83%A8%E6%A0%B7%E5%BC%8F%E7%B1%BB%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE"><span class="toc-number">3.39.</span> <span class="toc-text">组件的外部样式类如何设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%83%B3%E8%A6%81%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8F%92%E6%A7%BD%E4%BD%BF%E7%94%A8%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE"><span class="toc-number">3.40.</span> <span class="toc-text">小程序想要实现多个插槽使用如何设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B6%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E4%BC%A0%E5%80%BC%E7%BB%99%E5%AD%90%E7%BB%84%E4%BB%B6"><span class="toc-number">3.41.</span> <span class="toc-text">父组件如何传值给子组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E4%BC%A0%E5%80%BC%E7%BB%99%E7%88%B6%E7%BB%84%E4%BB%B6"><span class="toc-number">3.42.</span> <span class="toc-text">子组件如何传值给父组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E9%A1%B5%E9%9D%A2%E7%BA%A7%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.43.</span> <span class="toc-text">组件如何监听页面级生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E4%BA%A4%E4%BA%92API%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.44.</span> <span class="toc-text">小程序中的交互API有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%9F%9F%E5%90%8D%E6%97%A0%E6%B3%95%E8%AF%86%E5%88%AB%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="toc-number">3.45.</span> <span class="toc-text">小程序中域名无法识别如何处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E9%99%90%E5%88%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%90%88%E6%B3%95%E5%9F%9F%E5%90%8D%EF%BC%9F"><span class="toc-number">3.46.</span> <span class="toc-text">网络请求限制，如何配置合法域名？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%ADbase64%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.47.</span> <span class="toc-text">小程序中base64与二进制数据流之间的转换如何转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E5%B0%81%E8%A3%85%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%E7%9A%84%EF%BC%9F"><span class="toc-number">3.48.</span> <span class="toc-text">你是怎么封装微信小程序的数据请求的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%94%AF%E4%BB%98%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">3.49.</span> <span class="toc-text">小程序支付如何实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%88%86%E5%8C%85"><span class="toc-number">3.50.</span> <span class="toc-text">小程序如何进行分包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%88%86%E5%8C%85%E5%92%8C%E7%8B%AC%E7%AB%8B%E5%88%86%E5%8C%85%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="toc-number">3.51.</span> <span class="toc-text">普通分包和独立分包有什么不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%85%E6%9C%89%E5%93%AA%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.52.</span> <span class="toc-text">分包有哪些注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#uni-app"><span class="toc-number">4.</span> <span class="toc-text">uni-app</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#uni-app%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF"><span class="toc-number">4.1.</span> <span class="toc-text">uni-app有哪些优势?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uni-app%E8%AF%AD%E6%B3%95%E3%80%81%E7%BB%84%E4%BB%B6-%E5%8F%8A-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E7%9A%84-%E7%9B%B8%E5%90%8C%E4%B9%8B%E5%A4%84%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">uni-app语法、组件 及 生命周期 的 相同之处？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#uni-app%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84%EF%BC%9F"><span class="toc-number">4.2.0.1.</span> <span class="toc-text">uni-app的不同之处？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B0%81%E8%A3%85"><span class="toc-number">4.3.</span> <span class="toc-text">网络封装</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue3"><span class="toc-number">5.</span> <span class="toc-text">Vue3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vue2%E5%92%8CVue3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.1.</span> <span class="toc-text">vue2和Vue3的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%80-%E6%A0%B9%E8%8A%82%E7%82%B9%E4%B8%8D%E5%90%8C"><span class="toc-number">5.1.0.0.0.1.</span> <span class="toc-text">一. 根节点不同</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%8C-%E7%BB%84%E5%90%88%E5%BC%8FAPI%E5%92%8C%E9%80%89%E9%A1%B9%E5%BC%8FAPI"><span class="toc-number">5.1.0.0.0.2.</span> <span class="toc-text">二. 组合式API和选项式API</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%89-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">5.1.0.0.0.3.</span> <span class="toc-text">三. 生命周期的变化</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9B%9B-v-if%E5%92%8Cv-for%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">5.1.0.0.0.4.</span> <span class="toc-text">四. v-if和v-for的优先级</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%94-diff%E7%AE%97%E6%B3%95%E4%B8%8D%E5%90%8C"><span class="toc-number">5.1.0.0.0.5.</span> <span class="toc-text">五. diff算法不同</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%AD-%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E4%B8%8D%E5%90%8C"><span class="toc-number">5.1.0.0.0.6.</span> <span class="toc-text">六. 响应式原理不同</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9Avue3%E8%AF%B7%E7%9C%8B%E6%88%91%E7%9A%84vue3-ts-%E5%93%A6%EF%BC%81"><span class="toc-number">5.2.</span> <span class="toc-text">更多vue3请看我的vue3 + ts 哦！</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/20/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="web前端面试题">web前端面试题</a><time datetime="2023-08-20T09:30:24.000Z" title="发表于 2023-08-20 17:30:24">2023-08-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/15/Vue3+TS%E7%AC%AC%E4%BA%8C%E7%AB%A0/" title="Vue3+TypeScript (第二章：Vue3篇)">Vue3+TypeScript (第二章：Vue3篇)</a><time datetime="2023-08-15T02:45:02.000Z" title="发表于 2023-08-15 10:45:02">2023-08-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/06/Vue3+TS%E7%AC%AC%E4%B8%80%E7%AB%A0/" title="Vue3+TypeScript (第一章：TS篇)">Vue3+TypeScript (第一章：TS篇)</a><time datetime="2023-08-06T04:02:36.000Z" title="发表于 2023-08-06 12:02:36">2023-08-06</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2023 By <a class="footer-bar-link" href="/" title="苏惜" target="_blank">苏惜</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="苏惜的世界"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="苏惜的世界"/><span class="back-menu-item-text">苏惜的世界</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用!`,
    `生活明朗, 万物可爱`,
    `
     我是唐世闯欢迎来到我的博客世界！   
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By  V1.6.4",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by  %c 你正在访问 苏惜 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>