<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Vue3+TypeScript (第一章：TS篇) | 苏惜的小世界</title><meta name="author" content="苏惜"><meta name="copyright" content="苏惜"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Vue3+TypeScript (第一章：TS篇)"><meta name="application-name" content="Vue3+TypeScript (第一章：TS篇)"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Vue3+TypeScript (第一章：TS篇)"><meta property="og:url" content="http://example.com/2023/08/06/Vue3+TS%E7%AC%AC%E4%B8%80%E7%AB%A0/index.html"><meta property="og:site_name" content="苏惜的小世界"><meta property="og:description" content="Vue3+TypeScript？看这一篇就够了（由于东西太多我就分章写喽！） 1、TypeScript快速上手1.1 初识 TypeScript TypeScript 的介绍TypeScript是一种由微软开发的开源、跨平台的编程语言。它是JavaScript的超集，最终会被编译为JavaScr"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://example.com/img/default_cover.jpg"><meta property="article:author" content="苏惜"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/img/default_cover.jpg"><meta name="description" content="Vue3+TypeScript？看这一篇就够了（由于东西太多我就分章写喽！） 1、TypeScript快速上手1.1 初识 TypeScript TypeScript 的介绍TypeScript是一种由微软开发的开源、跨平台的编程语言。它是JavaScript的超集，最终会被编译为JavaScr"><link rel="shortcut icon" href="/img/userimg.jpg"><link rel="canonical" href="http://example.com/2023/08/06/Vue3+TS%E7%AC%AC%E4%B8%80%E7%AB%A0/"><link rel="preconnect" href="//npm.elemecdn.com"/><link rel="preconnect" href="//npm.onmicrosoft.cn"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":null},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 苏惜","link":"链接: ","source":"来源: 苏惜的小世界","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#3b70fc","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '苏惜的小世界',
  title: 'Vue3+TypeScript (第一章：TS篇)',
  postAI: '',
  pageFillDescription: '1、TypeScript快速上手, 1.1 初识 TypeScript, TypeScript 的介绍, TypeScript 的特点, 总结, 1.2 安装 TypeScript, 1.3. 第一个 TypeScript 程序, 编写 TS 程序, 手动编译代码, VsCode自动编译, 类型注解, 接口, 类, 总结, 使用webpack打包TS, 下载依赖, 入口JS srcx2Fmain.ts, index页面 publicx2Findex.html, buildx2Fwebpack.config.js, 配置打包命令, 运行与打包, 2、TypeScript常用语法, 2.1 基础类型, 布尔值, 数字, 字符串, undefined 和 null, 数组, 元组 Tuple, 枚举, any, void, object, 联合类型, 类型断言, 类型推断, 2.2 接口, 接口初探, 可选属性, 只读属性, 函数类型, 类类型, 一个类可以实现多个接口, 接口继承接口, 2.3 类, 基本示例, 继承, 公共私有与受保护的修饰符, readonly 修饰符, 存取器, 静态属性, 抽象类, 2.4 函数, 基本示例, 函数类型, 2.5 泛型, 引入, 使用函数泛型, 多个泛型参数的函数, 泛型接口, 泛型类, 泛型约束, 2.6 其它, 声明文件, 内置对象看这一篇就够了由于东西太多我就分章写喽快速上手初识的介绍是一种由微软开发的开源跨平台的编程语言它是的超集最终会被编译为代码年月微软发布了首个公开版本的年月日在经历了一个预览版之后微软正式发布了正式版的作者是安德斯海尔斯伯格的首席架构师它是开源和跨平台的编程语言扩展了的语法所以任何现有的程序可以运行在环境中是为大型应用的开发而设计并且可以编译为是的一个超集主要提供了类型系统和对的支持它由开发代码开源于上是的一个超集主要提供了类型系统和对的支持它由开发代码开源于上的特点主要有大特点始于归于可以编译出纯净简洁的代码并且可以运行在任何浏览器上环境中和任何支持或更高版本的引擎中强大的类型系统类型系统允许开发者在开发应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构先进的提供最新的和不断发展的特性包括那些来自年的和未来的提案中的特性比如异步功能和以帮助建立健壮的组件总结在社区的流行度越来越高它非常适用于一些大型项目也非常适用于一些基础库极大地帮助我们提升了开发效率和体验安装命令行运行如下命令全局安装安装完成后在控制台运行如下命令检查安装是否成功第一个程序编写程序手动编译代码我们使用了扩展名但是这段代码仅仅是而已在命令行上运行编译器输出结果为一个文件它包含了和输入文件中相同的代码在命令行上通过运行这段代码控制台输出自动编译生成配置文件修改配置启动监视任务终端运行任务监视类型注解接下来让我们看看工具带来的高级功能给函数的参数添加类型注解如下里的类型注解是一种轻量级的为函数或变量添加约束的方式在这个例子里我们希望函数接收一个字符串参数然后尝试把的调用改成传入一个数组重新编译你会看到产生了一个错误类似地尝试删除调用的所有参数会告诉你使用了非期望个数的参数调用了这个函数在这两种情况中提供了静态的代码分析它可以分析代码结构和提供的类型注解要注意的是尽管有错误文件还是被创建了就算你的代码里有错误你仍然可以使用但在这种情况下会警告你代码可能不会按预期执行接口让我们继续扩展这个示例应用这里我们使用接口来描述一个拥有和字段的对象在里只在两个类型内部的结构兼容那么这两个类型就是兼容的这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以而不必明确地使用语句类最后让我们使用类来改写这个例子支持的新特性比如支持基于类的面向对象编程让我们创建一个类它带有一个构造函数和一些公共字段因为类的字段包含了接口所需要的字段所以他们能很好的兼容还要注意的是我在类的声明上会注明所有的成员变量这样比较一目了然重新运行你会看到里的类只是一个语法糖本质上还是函数的实现总结到这里你已经对有了一个大致的印象那么下一章让我们来一起学习的一些常用语法吧使用打包下载依赖入口页面是否生产环境主机名打包日志输出输出错误信息配置打包命令运行与打包常用语法基础类型支持与几乎相同的数据类型此外还提供了实用的枚举类型方便我们使用布尔值最基本的数据类型就是简单的值在和里叫做其它语言中也一样数字和一样里的所有数字都是浮点数这些浮点数的类型是除了支持十进制和十六进制字面量还支持中引入的二进制和八进制字面量十进制二进制八进制十六进制字符串程序的另一项基本操作是处理网页或服务器端的文本数据像其它语言里一样我们使用表示文本数据类型和一样可以使用双引号或单引号表示字符串和里和两者各自有自己的类型分别叫做和它们的本身的类型用处不是很大默认情况下和是所有类型的子类型就是说你可以把和赋值给类型的变量数组像一样可以操作数组元素有两种方式可以定义数组第一种可以在元素类型后面接上表示由此类型元素组成的一个数组第二种方式是使用数组泛型元素类型元组元组类型允许表示一个已知元素数量和类型的数组各元素的类型不必相同比如你可以定义一对值分别为和类型的元组当访问一个已知索引的元素会得到正确的类型不存在方法枚举类型是对标准数据类型的一个补充使用枚举类型可以为一组数值赋予友好的名字枚举数值默认从开始依次递增根据特定的名称得到对应的枚举数值默认情况下从开始为元素编号你也可以手动的指定成员的数值例如我们将上面的例子改成从开始编号或者全部都采用手动赋值枚举类型提供的一个便利是你可以由枚举的值得到它的名字例如我们知道数值为但是不确定它映射到里的哪个名字我们可以查找相应的名字有时候我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型这些值可能来自于动态的内容比如来自用户输入或第三方代码库这种情况下我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查那么我们可以使用类型来标记这些变量也可以是个在对现有代码进行改写的时候类型是十分有用的它允许你在编译时可选择地包含或移除类型检查并且当你只知道一部分数据的类型时类型也是有用的比如你有一个数组它包含了不同的类型的数据某种程度上来说类型像是与类型相反它表示没有任何类型当一个函数没有返回值时你通常会见到其返回值类型是表示没有任何类型一般用来说明函数的返回值不能是和之外的值声明一个类型的变量没有什么大用因为你只能为它赋予和表示非原始类型也就是除之外的类型使用类型就可以更好的表示像这样的例如联合类型联合类型表示取值可以为多种类型中的一种需求定义一个一个函数得到一个数字或字符串值的字符串形式值需求定义一个一个函数得到一个数字或字符串值的长度类型断言通过类型断言这种方式可以告诉编译器相信我我知道自己在干什么类型断言好比其它语言里的类型转换但是不进行特殊的数据检查和解构它没有运行时的影响只是在编译阶段起作用会假设你程序员已经进行了必须的检查类型断言有两种形式其一是尖括号语法另一个为语法类型断言可以用来手动指定一个值的类型语法方式一类型值方式二值类型中只能用这种方式需求定义一个函数得到一个字符串或者数值数据的长度类型推断类型推断会在没有明确的指定类型的时候推测出一个类型有下面种情况定义变量时赋值了推断为对应的类型定义变量时没有赋值推断为类型定义变量时赋值了推断为对应的类型定义变量时没有赋值推断为类型类型接口的核心原则之一是对值所具有的结构进行类型检查我们使用接口来定义对象的类型接口是对象的状态属性和行为方法的抽象描述接口初探需求创建人的对象需要对人的属性进行一定的约束是类型必须有只读的是类型必须有是类型必须有是类型可以没有下面通过一个简单示例来观察接口是如何工作的在中我们使用接口来定义对象的类型接口是对象的状态属性和行为方法的抽象描述接口类型的对象多了或者少了属性是不允许的可选属性只读属性需求创建人的对象需要对人的属性进行一定的约束是类型必须有只读的是类型必须有是类型必须有是类型可以没有定义人的接口男类型检查器会查看对象内部的属性是否与接口描述一致如果不一致就会提示类型错误可选属性接口里的属性不全都是必需的有些是只在某些条件下存在或者根本不存在带有可选属性的接口与普通的接口定义差不多只是在可选属性名字定义的后面加一个符号可选属性的好处之一是可以对可能存在的属性进行预定义好处之二是可以捕获引用了不存在的属性时的错误男可以没有只读属性一些对象属性只能在对象刚刚创建的时候修改其值你可以在属性名前用来指定只读属性一旦赋值后再也不能被改变了男可以没有没有在接口中定义不能有最简单判断该用还是的方法是看要把它做为变量使用还是做为一个属性做为变量使用的话用若做为属性则使用函数类型接口能够描述中对象拥有的各种各样的外形除了描述带有属性的普通对象外接口也可以描述函数类型为了使用接口表示函数类型我们需要给接口定义一个调用签名它就像是一个只有参数列表和返回值类型的函数定义参数列表里的每个参数都需要名字和类型接口可以描述函数类型参数的类型与返回的类型这样定义后我们可以像使用其它接口一样使用这个函数类型的接口下例展示了如何创建一个函数类型的变量并将一个同类型的函数赋值给这个变量类类型类实现接口与或里接口的基本作用一样也能够用它来明确的强制一个类去符合某种契约类类型实现接口一个类可以实现多个接口一个接口可以继承多个接口一个类可以实现多个接口接口继承接口和类一样接口也可以相互继承这让我们能够从一个接口里复制成员到另一个接口里可以更灵活地将接口分割到可重用的模块里类对于传统的程序我们会使用函数和基于原型的继承来创建可重用的组件但对于熟悉使用面向对象方式的程序员使用这些语法就有些棘手因为他们用的是基于类的继承并且对象是由类构建出来的从也就是开始程序员将能够使用基于类的面向对象的方式使用我们允许开发者现在就使用这些特性并且编译后的可以在所有主流浏览器和平台上运行而不需要等到下个版本基本示例下面看一个使用类的例子类的基本定义与使用声明属性构造方法一般方法创建类的实例调用实例的方法如果你使用过或你会对这种语法非常熟悉我们声明一个类这个类有个成员一个叫做的属性一个构造函数和一个方法你会注意到我们在引用任何一个类成员的时候都用了它表示我们访问的是类的成员后面一行我们使用构造了类的一个实例它会调用之前定义的构造函数创建一个类型的新对象并执行构造函数初始化它最后一行通过对象调用其方法继承在里我们可以使用常用的面向对象模式基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类看下面的例子类的继承可以调用从父中继承得到的方法这个例子展示了最基本的继承类从基类中继承了属性和方法这里是一个派生类它派生自基类通过关键字派生类通常被称作子类基类通常被称作超类因为继承了的功能因此我们可以创建一个的实例它能够和下面我们来看个更加复杂的例子调用父类型构造方法重写父类型的方法调用父类型构造方法重写父类型的方法调用父类型的一般方法父类型引用指向子类型的实例多态如果子类型没有扩展的方法可以让子类型引用指向父类型的实例如果子类型有扩展的方法不能让子类型引用指向父类型的实例这个例子展示了一些上面没有提到的特性这一次我们使用关键字创建了的两个子类和与前一个例子的不同点是派生类包含了一个构造函数它必须调用它会执行基类的构造函数而且在构造函数里访问的属性之前我们一定要调用这个是强制执行的一条重要规则这个例子演示了如何在子类里可以重写父类的方法类和类都创建了方法它们重写了从继承来的方法使得方法根据不同的类而具有不同的功能注意即使被声明为类型但因为它的值是调用时它会调用里重写的方法公共私有与受保护的修饰符默认为在上面的例子里我们可以自由的访问程序里定义的成员如果你对其它语言中的类比较了解就会注意到我们在之前的代码里并没有使用来做修饰例如要求必须明确地使用指定成员是可见的在里成员都默认为你也可以明确的将一个成员标记成我们可以用下面的方式来重写上面的类理解当成员被标记成时它就不能在声明它的类的外部访问理解修饰符与修饰符的行为很相似但有一点不同成员在派生类中仍然可以访问例如访问修饰符用来描述类内部的属性方法的可访问性默认值公开的外部也可以访问只能类内部可以访问类内部和子类可以访问男子类能看到父类中受保护的成员子类看不到父类中私有的成员公开的可见受保护的不可见私有的不可见修饰符你可以使用关键字将属性设置为只读的只读属性必须在声明时或构造函数里被初始化参数属性在上面的例子中我们必须在类里定义一个只读成员和一个参数为的构造函数并且立刻将的值赋给这种情况经常会遇到参数属性可以方便地让我们在一个地方定义并初始化一个成员下面的例子是对之前类的修改版使用了参数属性注意看我们是如何舍弃参数仅在构造函数里使用参数来创建和初始化成员我们把声明和赋值合并至一处参数属性通过给构造函数参数前面添加一个访问限定符来声明使用限定一个参数属性会声明并初始化一个私有成员对于和来说也是一样存取器支持通过来截取对对象成员的访问它能帮助你有效的控制对对象成员的访问下面来看如何把一个简单的类改写成使用和首先我们从一个没有使用存取器的例子开始静态属性到目前为止我们只讨论了类的实例成员那些仅当类被实例化的时候才会被初始化的属性我们也可以创建类的静态成员这些属性存在于类本身上面而不是类的实例上在这个例子里我们使用定义因为它是所有网格都会用到的属性每个实例想要访问这个属性的时候都要在前面加上类名如同在实例属性上使用来访问属性一样这里我们使用来访问静态属性静态属性是类对象的属性非静态属性是类的实例对象的属性抽象类抽象类做为其它派生类的基类使用它们不能被实例化不同于接口抽象类可以包含成员的实现细节关键字是用于定义抽象类和在抽象类内部定义抽象方法抽象类不能创建实例对象只有实现类才能创建实例可以包含未实现的抽象方法函数函数是应用程序的基础它帮助你实现抽象层模拟类信息隐藏和模块在里虽然已经支持类命名空间和模块但函数仍然是主要的定义行为的地方为函数添加了额外的功能让我们可以更容易地使用基本示例和一样函数可以创建有名字的函数和匿名函数你可以随意选择适合应用程序的方式不论是定义一系列函数还是只使用一次的函数通过下面的例子可以迅速回想起这两种中的函数命名函数匿名函数函数类型为函数定义类型让我们为上面那个函数添加类型我们可以给每个参数添加类型之后再为函数本身添加返回值类型能够根据返回语句自动推断出返回值类型书写完整函数类型现在我们已经为函数指定了类型下面让我们写出函数的完整类型可选参数和默认参数里的每个函数参数都是必须的这不是指不能传递或作为参数而是说编译器检查用户是否为每个参数都传入了值编译器还会假设只有这些参数会被传递进函数简短地说传递给一个函数的参数个数必须与函数期望的参数个数一致里每个参数都是可选的可传可不传没传参的时候它的值就是在里我们可以在参数名旁使用实现可选参数的功能比如我们想让是可选的在里我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是时它们叫做有默认初始化值的参数让我们修改上例把的默认值设置为剩余参数必要参数默认参数和可选参数有个共同点它们表示某一个参数有时你想同时操作多个参数或者你并不知道会有多少参数传递进来在里你可以使用来访问所有传入的参数在里你可以把所有参数收集到一个变量里剩余参数会被当做个数不限的可选参数可以一个都没有同样也可以有任意个编译器创建参数数组名字是你在省略号后面给定的名字你可以在函数体内使用这个数组函数重载函数重载函数名相同而形参不同的多个函数在中由于弱类型的特点和形参与实参可以不匹配是没有函数重载这一说的但在中与其它面向对象的语言如就存在此语法函数重载函数名相同而形参不同的多个函数需求我们有一个函数它可以接收个类型的参数进行拼接也可以接收个类型的参数进行相加重载函数声明定义函数实现在实现上我们要注意严格判断两个参数的类型是否相等而不能简单的写一个泛型指在定义函数接口或类的时候不预先指定具体的类型而在使用的时候再指定具体类型的一种特性引入下面创建一个函数实现功能根据指定的数量和数据创建一个包含个的数组不用泛型的话这个函数可能是下面这样使用函数泛型多个泛型参数的函数一个函数可以定义多个泛型参数泛型接口在定义接口时为接口中的属性或方法定义泛型类型在使用接口时再指定具体的泛型类型主键自增姓名年龄保存泛型类在定义类时为类中的属性或方法定义泛型类型在创建类的实例时再指定特定的泛型类型泛型约束如果我们直接对一个泛型参数取属性会报错因为这个泛型根本就不知道它有这个属性没有泛型约束我们可以使用泛型约束来实现指定泛型约束我们需要传入符合约束类型的值必须包含必须属性没有属性其它声明文件当使用第三方库时我们需要引用它的声明文件才能获得对应的代码补全接口提示等功能什么是声明语句假如我们想使用第三方库一种常见的方式是在中通过标签引入然后就可以使用全局变量或了但是在中编译器并不知道或是什么东西当使用第三方库时我们需要引用它的声明文件才能获得对应的代码补全接口提示等功能声明语句如果需要对新的语法进行检查需要要加载了对应的类型说明代码声明文件把声明语句放到一个单独的文件中会自动解析到项目中所有声明文件下载声明文件这时我们需要使用来定义它的类型并没有真的定义一个变量只是定义了全局变量的类型仅仅会用于编译时的检查在编译结果中会被删除它编译结果是一般声明文件都会单独写成一个文件创建将声明语句定义其中编译器会扫描并加载项目中所有的声明文件很多的第三方库都定义了对应的声明文件库库文件名一般为可以在进行搜索有的第三库在下载时就会自动下载对应的声明文件库比如有的可能需要单独下载比如内置对象中有很多内置对象它们可以直接在中当做定义好了的类型内置对象是指根据标准在全局作用域上存在的对象这里的标准是指和其他环境比如的标准的内置对象的内置对象和的内置对象',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-07 14:59:08',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/img/userimg.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">苏惜的小世界</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 文章总览</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=8152657892&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/img/wxewm.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="/img/wxewm.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/zfbewm.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="/img/zfbewm.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">音乐</div><span class="author-content-item-title">灵魂的碰撞💥</span></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">Vue3+TypeScript (第一章：TS篇)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-08-06T04:02:36.000Z" title="发表于 2023-08-06 12:02:36">2023-08-06</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-09-07T06:59:08.048Z" title="更新于 2023-09-07 14:59:08">2023-09-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为北京"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>北京</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/img/default_cover.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2023/08/06/Vue3+TS%E7%AC%AC%E4%B8%80%E7%AB%A0/"><header><h1 id="CrawlerTitle" itemprop="name headline">Vue3+TypeScript (第一章：TS篇)</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">苏惜</span><time itemprop="dateCreated datePublished" datetime="2023-08-06T04:02:36.000Z" title="发表于 2023-08-06 12:02:36">2023-08-06</time><time itemprop="dateCreated datePublished" datetime="2023-09-07T06:59:08.048Z" title="更新于 2023-09-07 14:59:08">2023-09-07</time></header><!-- More info: [Server](https://hexo.io/docs/server.html) 跳转 -->

<p>Vue3+TypeScript？看这一篇就够了（由于东西太多我就分章写喽！）</p>
<h2 id="1、TypeScript快速上手"><a href="#1、TypeScript快速上手" class="headerlink" title="1、TypeScript快速上手"></a>1、TypeScript快速上手</h2><h3 id="1-1-初识-TypeScript"><a href="#1-1-初识-TypeScript" class="headerlink" title="1.1 初识 TypeScript"></a>1.1 初识 TypeScript</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/c8a21d00a775af5a8eef4bb91c5def2e.png" alt="image"></p>
<h4 id="TypeScript-的介绍"><a href="#TypeScript-的介绍" class="headerlink" title="TypeScript 的介绍"></a>TypeScript 的介绍</h4><p>TypeScript是一种由微软开发的开源、跨平台的编程语言。它是JavaScript的超集，最终会被编译为JavaScript代码。</p>
<p>2012年10月，微软发布了首个公开版本的TypeScript，2013年6月19日，在经历了一个预览版之后微软正式发布了正式版TypeScript</p>
<p>TypeScript的作者是安德斯·海尔斯伯格，C#的首席架构师。它是开源和跨平台的编程语言。</p>
<p>TypeScript扩展了JavaScript的语法，所以任何现有的JavaScript程序可以运行在TypeScript环境中。</p>
<p>TypeScript是为大型应用的开发而设计，并且可以编译为JavaScript。</p>
<p>TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6+ 的支持**，它由 Microsoft 开发，代码开源于 GitHub 上</p>
<p>TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6+ 的支持，它由 Microsoft 开发，代码开源于 GitHub 上</p>
<h4 id="TypeScript-的特点"><a href="#TypeScript-的特点" class="headerlink" title="TypeScript 的特点"></a>TypeScript 的特点</h4><p><strong>TypeScript 主要有 3 大特点：</strong></p>
<ol>
<li><p>始于JavaScript，归于JavaScript<br>TypeScript 可以编译出纯净、 简洁的 JavaScript 代码，并且可以运行在任何浏览器上、Node.js 环境中和任何支持 ECMAScript 3（或更高版本）的JavaScript 引擎中。</p>
</li>
<li><p>强大的类型系统<br>类型系统允许 JavaScript 开发者在开发 JavaScript 应用程序时使用高效的开发工具和常用操作比如静态检查和代码重构。</p>
</li>
<li><p>先进的 JavaScript<br>TypeScript 提供最新的和不断发展的 JavaScript 特性，包括那些来自 2015 年的 ECMAScript 和未来的提案中的特性，比如异步功能和 Decorators，以帮助建立健壮的组件。</p>
</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>TypeScript 在社区的流行度越来越高，它非常适用于一些大型项目，也非常适用于一些基础库，极大地帮助我们提升了开发效率和体验。</p>
<h3 id="1-2-安装-TypeScript"><a href="#1-2-安装-TypeScript" class="headerlink" title="1.2 安装 TypeScript"></a>1.2 安装 TypeScript</h3><p>命令行运行如下命令，全局安装 TypeScript：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure>
<p>安装完成后，在控制台运行如下命令，检查安装是否成功(3.x)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc -V </span><br></pre></td></tr></table></figure>

<h3 id="1-3-第一个-TypeScript-程序"><a href="#1-3-第一个-TypeScript-程序" class="headerlink" title="1.3. 第一个 TypeScript 程序"></a>1.3. 第一个 TypeScript 程序</h3><h4 id="编写-TS-程序"><a href="#编写-TS-程序" class="headerlink" title="编写 TS 程序"></a>编写 TS 程序</h4><p>src&#x2F;helloworld.ts   </p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greeter</span> (person) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + person</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="string">&#x27;Yee&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">greeter</span>(user))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="手动编译代码"><a href="#手动编译代码" class="headerlink" title="手动编译代码"></a>手动编译代码</h4><p>我们使用了 .ts 扩展名，但是这段代码仅仅是 JavaScript 而已。</p>
<p>在命令行上，运行 TypeScript 编译器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc helloworld.ts</span><br></pre></td></tr></table></figure>
<p>输出结果为一个 helloworld.js 文件，它包含了和输入文件中相同的 JavsScript 代码。</p>
<p>在命令行上，通过 Node.js 运行这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node helloworld.js</span><br></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, Yee</span><br></pre></td></tr></table></figure>

<h4 id="VsCode自动编译"><a href="#VsCode自动编译" class="headerlink" title="VsCode自动编译"></a>VsCode自动编译</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1). 生成配置文件tsconfig.json</span><br><span class="line">    tsc --init</span><br><span class="line">2). 修改tsconfig.json配置</span><br><span class="line">    &quot;outDir&quot;: &quot;./js&quot;,</span><br><span class="line">    &quot;strict&quot;: false,    </span><br><span class="line">3). 启动监视任务: </span><br><span class="line">    终端 -&gt; 运行任务 -&gt; 监视tsconfig.json</span><br></pre></td></tr></table></figure>

<h4 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h4><p>接下来让我们看看 TypeScript 工具带来的高级功能。 给 person 函数的参数添加 : string 类型注解，如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greeter</span> (<span class="attr">person</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + person</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="string">&#x27;Yee&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">greeter</span>(user))</span><br></pre></td></tr></table></figure>
<p>TypeScript 里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望 greeter 函数接收一个字符串参数。 然后尝试把 greeter 的调用改成传入一个数组：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greeter</span> (<span class="attr">person</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + person</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">greeter</span>(user))</span><br></pre></td></tr></table></figure>
<p>重新编译，你会看到产生了一个错误：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error TS2345: Argument of type &#x27;number[]&#x27; is not assignable to parameter of type &#x27;string&#x27;.</span><br></pre></td></tr></table></figure>
<p>类似地，尝试删除 greeter 调用的所有参数。 TypeScript 会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。</p>
<p>要注意的是尽管有错误，greeter.js 文件还是被创建了。 就算你的代码里有错误，你仍然可以使用 TypeScript。但在这种情况下，TypeScript 会警告你代码可能不会按预期执行。</p>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>让我们继续扩展这个示例应用。这里我们使用接口来描述一个拥有 firstName 和 lastName 字段的对象。 在 TypeScript 里，只在两个类型内部的结构兼容，那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 implements 语句。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">lastName</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greeter</span> (<span class="attr">person</span>: <span class="title class_">Person</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + person.<span class="property">firstName</span> + <span class="string">&#x27; &#x27;</span> + person.<span class="property">lastName</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;Yee&#x27;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;Huang&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">greeter</span>(user))</span><br></pre></td></tr></table></figure>

<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>最后，让我们使用类来改写这个例子。 TypeScript 支持 JavaScript 的新特性，比如支持基于类的面向对象编程。</p>
<p>让我们创建一个 User 类，它带有一个构造函数和一些公共字段。因为类的字段包含了接口所需要的字段，所以他们能很好的兼容。</p>
<p>还要注意的是，我在类的声明上会注明所有的成员变量，这样比较一目了然。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">fullName</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">lastName</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> (<span class="attr">firstName</span>: <span class="built_in">string</span>, <span class="attr">lastName</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstName</span> = firstName</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lastName</span> = lastName</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fullName</span> = firstName + <span class="string">&#x27; &#x27;</span> + lastName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">lastName</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greeter</span> (<span class="attr">person</span>: <span class="title class_">Person</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Hello, &#x27;</span> + person.<span class="property">firstName</span> + <span class="string">&#x27; &#x27;</span> + person.<span class="property">lastName</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&#x27;Yee&#x27;</span>, <span class="string">&#x27;Huang&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">greeter</span>(user))</span><br></pre></td></tr></table></figure>
<p>重新运行 tsc greeter.ts，你会看到 TypeScript 里的类只是一个语法糖，本质上还是 JavaScript 函数的实现。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>到这里，你已经对 TypeScript 有了一个大致的印象，那么下一章让我们来一起学习 TypeScript 的一些常用语法吧。</p>
<h3 id="使用webpack打包TS"><a href="#使用webpack打包TS" class="headerlink" title="使用webpack打包TS"></a>使用webpack打包TS</h3><h4 id="下载依赖"><a href="#下载依赖" class="headerlink" title="下载依赖"></a>下载依赖</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D typescript</span><br><span class="line">yarn add -D webpack webpack-cli</span><br><span class="line">yarn add -D webpack-dev-server</span><br><span class="line">yarn add -D html-webpack-plugin clean-webpack-plugin</span><br><span class="line">yarn add -D ts-loader</span><br><span class="line">yarn add -D cross-env</span><br></pre></td></tr></table></figure>

<h4 id="入口JS-src-main-ts"><a href="#入口JS-src-main-ts" class="headerlink" title="入口JS: src&#x2F;main.ts"></a>入口JS: src&#x2F;main.ts</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import &#x27;./01_helloworld&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;Hello Webpack TS!&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="index页面-public-index-html"><a href="#index页面-public-index-html" class="headerlink" title="index页面: public&#x2F;index.html"></a>index页面: public&#x2F;index.html</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>webpack &amp; TS<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="build-webpack-config-js"><a href="#build-webpack-config-js" class="headerlink" title="build&#x2F;webpack.config.js"></a>build&#x2F;webpack.config.js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;<span class="title class_">CleanWebpackPlugin</span>&#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isProd = process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span> <span class="comment">// 是否生产环境</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolve</span> (dir) &#123;</span><br><span class="line">  <span class="keyword">return</span> path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;..&#x27;</span>, dir)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">mode</span>: isProd ? <span class="string">&#x27;production&#x27;</span> : <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  <span class="attr">entry</span>: &#123;</span><br><span class="line">    <span class="attr">app</span>: <span class="string">&#x27;./src/main.ts&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="title function_">resolve</span>(<span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;[name].[contenthash:8].js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">        <span class="attr">use</span>: <span class="string">&#x27;ts-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">include</span>: [<span class="title function_">resolve</span>(<span class="string">&#x27;src&#x27;</span>)]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CleanWebpackPlugin</span>(&#123;</span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./public/index.html&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.tsx&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">devtool</span>: isProd ? <span class="string">&#x27;cheap-module-source-map&#x27;</span> : <span class="string">&#x27;cheap-module-eval-source-map&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>, <span class="comment">// 主机名</span></span><br><span class="line">    <span class="attr">stats</span>: <span class="string">&#x27;errors-only&#x27;</span>, <span class="comment">// 打包日志输出输出错误信息</span></span><br><span class="line">    <span class="attr">port</span>: <span class="number">8081</span>,</span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="配置打包命令"><a href="#配置打包命令" class="headerlink" title="配置打包命令"></a>配置打包命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --config build/webpack.config.js&quot;,</span><br><span class="line">&quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config build/webpack.config.js&quot;</span><br></pre></td></tr></table></figure>

<h4 id="运行与打包"><a href="#运行与打包" class="headerlink" title="运行与打包"></a>运行与打包</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn dev</span><br><span class="line">yarn build</span><br></pre></td></tr></table></figure>

<h2 id="2、TypeScript常用语法"><a href="#2、TypeScript常用语法" class="headerlink" title="2、TypeScript常用语法"></a>2、TypeScript常用语法</h2><h3 id="2-1-基础类型"><a href="#2-1-基础类型" class="headerlink" title="2.1 基础类型"></a>2.1 基础类型</h3><p>TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p>
<h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><p>最基本的数据类型就是简单的 true&#x2F;false 值，在JavaScript 和 TypeScript 里叫做 boolean（其它语言中也一样）。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">isDone</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">isDone = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// isDone = 2 // error</span></span><br></pre></td></tr></table></figure>
<h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p>和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015中引入的二进制和八进制字面量。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a1</span>: <span class="built_in">number</span> = <span class="number">10</span> <span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a2</span>: <span class="built_in">number</span> = <span class="number">0b1010</span>  <span class="comment">// 二进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a3</span>: <span class="built_in">number</span> = <span class="number">0o12</span> <span class="comment">// 八进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a4</span>: <span class="built_in">number</span> = <span class="number">0xa</span> <span class="comment">// 十六进制</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>JavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 string 表示文本数据类型。 和 JavaScript 一样，可以使用双引号（”）或单引号（’）表示字符串。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">name</span>:<span class="built_in">string</span> = <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">name = <span class="string">&#x27;jack&#x27;</span></span><br><span class="line"><span class="comment">// name = 12 // error</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">age</span>:<span class="built_in">number</span> = <span class="number">12</span></span><br><span class="line"><span class="keyword">const</span> info = <span class="string">`My name is <span class="subst">$&#123;name&#125;</span>, I am <span class="subst">$&#123;age&#125;</span> years old!`</span></span><br></pre></td></tr></table></figure>

<h4 id="undefined-和-null"><a href="#undefined-和-null" class="headerlink" title="undefined 和 null"></a>undefined 和 null</h4><p>TypeScript 里，undefined 和 null 两者各自有自己的类型分别叫做 undefined 和 null。 它们的本身的类型用处不是很大：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">u</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">n</span>: <span class="literal">null</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>TypeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上[]，表示由此类型元素组成的一个数组：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list1</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>第二种方式是使用数组泛型，Array&lt;元素类型&gt;：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list2</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h4 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h4><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string 和 number 类型的元组。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">t1</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>]</span><br><span class="line">t1 = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>] <span class="comment">// OK</span></span><br><span class="line">t1 = [<span class="number">10</span>, <span class="string">&#x27;hello&#x27;</span>] <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>
<p>当访问一个已知索引的元素，会得到正确的类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(t1[<span class="number">0</span>].<span class="title function_">substring</span>(<span class="number">1</span>)) <span class="comment">// OK</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(t1[<span class="number">1</span>].<span class="title function_">substring</span>(<span class="number">1</span>)) <span class="comment">// Error, &#x27;number&#x27; 不存在 &#x27;substring&#x27; 方法</span></span><br></pre></td></tr></table></figure>

<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>enum 类型是对 JavaScript 标准数据类型的一个补充。 使用枚举类型可以为一组数值赋予友好的名字。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span>,</span><br><span class="line">  <span class="title class_">Green</span>,</span><br><span class="line">  <span class="title class_">Blue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举数值默认从0开始依次递增</span></span><br><span class="line"><span class="comment">// 根据特定的名称得到对应的枚举数值</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">myColor</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>  <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myColor, <span class="title class_">Color</span>.<span class="property">Red</span>, <span class="title class_">Color</span>.<span class="property">Blue</span>)</span><br></pre></td></tr></table></figure>
<p>默认情况下，从 0 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1 开始编号：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span></span><br></pre></td></tr></table></figure>
<p>或者，全部都采用手动赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;</span><br><span class="line">let c: Color = Color.Green</span><br></pre></td></tr></table></figure>
<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span> = <span class="number">1</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">colorName</span>: <span class="built_in">string</span> = <span class="title class_">Color</span>[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colorName)  <span class="comment">// &#x27;Green&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="any"><a href="#any" class="headerlink" title="any"></a>any</h4><p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any 类型来标记这些变量：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: <span class="built_in">any</span> = <span class="number">4</span></span><br><span class="line">notSure = <span class="string">&#x27;maybe a string&#x27;</span></span><br><span class="line">notSure = <span class="literal">false</span> <span class="comment">// 也可以是个 boolean</span></span><br></pre></td></tr></table></figure>
<p>在对现有代码进行改写的时候，any 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。并且当你只知道一部分数据的类型时，any 类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">&#x27;free&#x27;</span>]</span><br><span class="line"></span><br><span class="line">list[<span class="number">1</span>] = <span class="number">100</span></span><br></pre></td></tr></table></figure>

<h4 id="void"><a href="#void" class="headerlink" title="void"></a>void</h4><p>某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 表示没有任何类型, 一般用来说明函数的返回值不能是undefined和null之外的值 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn()&#x27;</span>)</span><br><span class="line">  <span class="comment">// return undefined</span></span><br><span class="line">  <span class="comment">// return null</span></span><br><span class="line">  <span class="comment">// return 1 // error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明一个 void 类型的变量没有什么大用，因为你只能为它赋予 undefined 和 null：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">unusable</span>: <span class="built_in">void</span> = <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="object"><a href="#object" class="headerlink" title="object"></a>object</h4><p>object 表示非原始类型，也就是除 number，string，boolean之外的类型。</p>
<p>使用 object 类型，就可以更好的表示像 Object.create 这样的 API。例如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params">obj:<span class="built_in">object</span></span>):<span class="built_in">object</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn2()&#x27;</span>, obj)</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  <span class="comment">// return undefined</span></span><br><span class="line">  <span class="comment">// return null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn2</span>(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;abc&#x27;</span>)))</span><br><span class="line"><span class="comment">// console.log(fn2(&#x27;abc&#x27;) // error</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn2</span>(<span class="title class_">String</span>))</span><br></pre></td></tr></table></figure>
<h4 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h4><p>联合类型（Union Types）表示取值可以为多种类型中的一种<br>需求1: 定义一个一个函数得到一个数字或字符串值的字符串形式值</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toString2</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>) : <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x.<span class="title function_">toString</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需求2: 定义一个一个函数得到一个数字或字符串值的长度</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getLength</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return x.length // error</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x.<span class="property">length</span>) &#123; <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">return</span> x.<span class="property">length</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x.<span class="title function_">toString</span>().<span class="property">length</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。</p>
<p>类型断言有两种形式。 其一是“尖括号”语法, 另一个为 as 语法</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">类型断言(Type Assertion): 可以用来手动指定一个值的类型</span></span><br><span class="line"><span class="comment">语法:</span></span><br><span class="line"><span class="comment">    方式一: &lt;类型&gt;值</span></span><br><span class="line"><span class="comment">    方式二: 值 as 类型  tsx中只能用这种方式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 需求: 定义一个函数得到一个字符串或者数值数据的长度 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getLength</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((&lt;<span class="built_in">string</span>&gt;x).<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (x <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x.<span class="title function_">toString</span>().<span class="property">length</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getLength</span>(<span class="string">&#x27;abcd&#x27;</span>), <span class="title function_">getLength</span>(<span class="number">1234</span>))</span><br></pre></td></tr></table></figure>
<h4 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h4><p>类型推断: TS会在没有明确的指定类型的时候推测出一个类型<br>有下面2种情况: 1. 定义变量时赋值了, 推断为对应的类型. 2. 定义变量时没有赋值, 推断为any类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义变量时赋值了, 推断为对应的类型 */</span></span><br><span class="line"><span class="keyword">let</span> b9 = <span class="number">123</span> <span class="comment">// number</span></span><br><span class="line"><span class="comment">// b9 = &#x27;abc&#x27; // error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义变量时没有赋值, 推断为any类型 */</span></span><br><span class="line"><span class="keyword">let</span> b10  <span class="comment">// any类型</span></span><br><span class="line">b10 = <span class="number">123</span></span><br><span class="line">b10 = <span class="string">&#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-接口"><a href="#2-2-接口" class="headerlink" title="2.2 接口"></a>2.2 接口</h3><p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查。我们使用接口（Interfaces）来定义对象的类型。接口是对象的状态(属性)和行为(方法)的抽象(描述)</p>
<h4 id="接口初探"><a href="#接口初探" class="headerlink" title="接口初探"></a>接口初探</h4><p>需求: 创建人的对象, 需要对人的属性进行一定的约束</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id是number类型, 必须有, 只读的</span><br><span class="line">name是string类型, 必须有</span><br><span class="line">age是number类型, 必须有</span><br><span class="line">sex是string类型, 可以没有</span><br></pre></td></tr></table></figure>
<p>下面通过一个简单示例来观察接口是如何工作的：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型</span></span><br><span class="line"><span class="comment">接口: 是对象的状态(属性)和行为(方法)的抽象(描述)</span></span><br><span class="line"><span class="comment">接口类型的对象</span></span><br><span class="line"><span class="comment">    多了或者少了属性是不允许的</span></span><br><span class="line"><span class="comment">    可选属性: ?</span></span><br><span class="line"><span class="comment">    只读属性: readonly</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">需求: 创建人的对象, 需要对人的属性进行一定的约束</span></span><br><span class="line"><span class="comment">  id是number类型, 必须有, 只读的</span></span><br><span class="line"><span class="comment">  name是string类型, 必须有</span></span><br><span class="line"><span class="comment">  age是number类型, 必须有</span></span><br><span class="line"><span class="comment">  sex是string类型, 可以没有</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义人的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">sex</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person1</span>: <span class="title class_">IPerson</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型检查器会查看对象内部的属性是否与IPerson接口描述一致, 如果不一致就会提示类型错误。</p>
<h4 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h4><p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  sex?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 ? 符号。</p>
<p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">person2</span>: <span class="title class_">IPerson</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="comment">// sex: &#x27;男&#x27; // 可以没有</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h4><p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly 来指定只读属性:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  sex?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦赋值后再也不能被改变了。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">person2</span>: <span class="title class_">IPerson</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="comment">// sex: &#x27;男&#x27; // 可以没有</span></span><br><span class="line">  <span class="comment">// xxx: 12 // error 没有在接口中定义, 不能有</span></span><br><span class="line">&#125;</span><br><span class="line">person2.<span class="property">id</span> = <span class="number">2</span> <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p><strong>readonly vs const</strong><br>最简单判断该用 readonly 还是 const 的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用 readonly。</p>
<h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><p>接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</p>
<p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">接口可以描述函数类型(参数的类型与返回的类型)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SearchFunc</span> &#123;</span><br><span class="line">  (<span class="attr">source</span>: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">mySearch</span>: <span class="title class_">SearchFunc</span> = <span class="keyword">function</span> (<span class="params">source: <span class="built_in">string</span>, sub: <span class="built_in">string</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> source.<span class="title function_">search</span>(sub) &gt; -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">mySearch</span>(<span class="string">&#x27;abcd&#x27;</span>, <span class="string">&#x27;bc&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h4 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h4><p><strong>类实现接口</strong><br>与 C# 或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">类类型: 实现接口</span></span><br><span class="line"><span class="comment">1. 一个类可以实现多个接口</span></span><br><span class="line"><span class="comment">2. 一个接口可以继承多个接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">  <span class="title function_">alert</span>(): <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Light</span> &#123;</span><br><span class="line">  <span class="title function_">lightOn</span>(): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">lightOff</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Alarm</span> &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Car alert&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一个类可以实现多个接口"><a href="#一个类可以实现多个接口" class="headerlink" title="一个类可以实现多个接口"></a>一个类可以实现多个接口</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car2</span> <span class="keyword">implements</span> <span class="title class_">Alarm</span>, <span class="title class_">Light</span> &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Car alert&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">lightOn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Car light on&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">lightOff</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Car light off&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="接口继承接口"><a href="#接口继承接口" class="headerlink" title="接口继承接口"></a>接口继承接口</h4><p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">LightableAlarm</span> <span class="keyword">extends</span> <span class="title class_">Alarm</span>, <span class="title class_">Light</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-类"><a href="#2-3-类" class="headerlink" title="2.3 类"></a>2.3 类</h3><p>对于传统的 JavaScript 程序我们会使用<strong>函数</strong>和<strong>基于原型的继承</strong>来创建可重用的组件，但对于熟悉使用面向对象方式的程序员使用这些语法就有些棘手，因为他们用的是<strong>基于类的继承</strong>并且对象是由类构建出来的。 从 ECMAScript 2015，也就是 ES6 开始， JavaScript 程序员将能够使用基于类的面向对象的方式。 使用 TypeScript，我们允许开发者现在就使用这些特性，并且编译后的 JavaScript 可以在所有主流浏览器和平台上运行，而不需要等到下个 JavaScript 版本。</p>
<h4 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h4><p>下面看一个使用类的例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">类的基本定义与使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="comment">// 声明属性</span></span><br><span class="line">  <span class="attr">message</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造方法</span></span><br><span class="line">  <span class="title function_">constructor</span> (<span class="attr">message</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">message</span> = message</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一般方法</span></span><br><span class="line">  greet (): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello &#x27;</span> + <span class="variable language_">this</span>.<span class="property">message</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类的实例</span></span><br><span class="line"><span class="keyword">const</span> greeter = <span class="keyword">new</span> <span class="title class_">Greeter</span>(<span class="string">&#x27;world&#x27;</span>)</span><br><span class="line"><span class="comment">// 调用实例的方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeter.<span class="title function_">greet</span>())</span><br></pre></td></tr></table></figure>
<p>如果你使用过 C# 或 Java，你会对这种语法非常熟悉。 我们声明一个 Greeter 类。这个类有 3 个成员：一个叫做 message 的属性，一个构造函数和一个 greet 方法。</p>
<p>你会注意到，我们在引用任何一个类成员的时候都用了 this。 它表示我们访问的是类的成员。</p>
<p>后面一行，我们使用 new 构造了 Greeter 类的一个实例。它会调用之前定义的构造函数，创建一个 Greeter 类型的新对象，并执行构造函数初始化它。</p>
<p>最后一行通过 greeter 对象调用其 greet 方法</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>在 TypeScript 里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。</p>
<p>看下面的例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">类的继承</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  run (<span class="attr">distance</span>: <span class="built_in">number</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Animal run <span class="subst">$&#123;distance&#125;</span>m`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  cry () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;wang! wang!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>()</span><br><span class="line">dog.<span class="title function_">cry</span>() </span><br><span class="line">dog.<span class="title function_">run</span>(<span class="number">100</span>) <span class="comment">// 可以调用从父中继承得到的方法</span></span><br></pre></td></tr></table></figure>
<p>这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里，<strong>Dog</strong> 是一个 派生类，它派生自 <strong>Animal</strong> 基类，通过 <strong>extends</strong> 关键字。 派生类通常被称作子类，基类通常被称作超类。</p>
<p>因为 <strong>Dog</strong> 继承了 <strong>Animal</strong> 的功能，因此我们可以创建一个 Dog 的实例，它能够 <strong>cry()</strong> 和 **run()**。</p>
<p>下面我们来看个更加复杂的例子。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  </span><br><span class="line">  <span class="title function_">constructor</span> (<span class="attr">name</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  run (<span class="attr">distance</span>: <span class="built_in">number</span>=<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> run <span class="subst">$&#123;distance&#125;</span>m`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Snake</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> (<span class="attr">name</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用父类型构造方法</span></span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写父类型的方法</span></span><br><span class="line">  run (<span class="attr">distance</span>: <span class="built_in">number</span>=<span class="number">5</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sliding...&#x27;</span>)</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">run</span>(distance)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Horse</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> (<span class="attr">name</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用父类型构造方法</span></span><br><span class="line">    <span class="variable language_">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写父类型的方法</span></span><br><span class="line">  run (<span class="attr">distance</span>: <span class="built_in">number</span>=<span class="number">50</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;dashing...&#x27;</span>)</span><br><span class="line">    <span class="comment">// 调用父类型的一般方法</span></span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">run</span>(distance)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  xxx () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;xxx()&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> snake = <span class="keyword">new</span> <span class="title class_">Snake</span>(<span class="string">&#x27;sn&#x27;</span>)</span><br><span class="line">snake.<span class="title function_">run</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> horse = <span class="keyword">new</span> <span class="title class_">Horse</span>(<span class="string">&#x27;ho&#x27;</span>)</span><br><span class="line">horse.<span class="title function_">run</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类型引用指向子类型的实例 ==&gt; 多态</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">tom</span>: <span class="title class_">Animal</span> = <span class="keyword">new</span> <span class="title class_">Horse</span>(<span class="string">&#x27;ho22&#x27;</span>)</span><br><span class="line">tom.<span class="title function_">run</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果子类型没有扩展的方法, 可以让子类型引用指向父类型的实例 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">tom3</span>: <span class="title class_">Snake</span> = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;tom3&#x27;</span>)</span><br><span class="line">tom3.<span class="title function_">run</span>()</span><br><span class="line"><span class="comment">/* 如果子类型有扩展的方法, 不能让子类型引用指向父类型的实例 */</span></span><br><span class="line"><span class="comment">// const tom2: Horse = new Animal(&#x27;tom2&#x27;)</span></span><br><span class="line"><span class="comment">// tom2.run()</span></span><br></pre></td></tr></table></figure>
<p>这个例子展示了一些上面没有提到的特性。 这一次，我们使用 extends 关键字创建了 Animal的两个子类：Horse 和 Snake。</p>
<p>与前一个例子的不同点是，派生类包含了一个构造函数，它 必须调用 super()，它会执行基类的构造函数。 而且，在构造函数里访问 this 的属性之前，我们 一定要调用 super()。 这个是 TypeScript 强制执行的一条重要规则。</p>
<p>这个例子演示了如何在子类里可以重写父类的方法。Snake类和 Horse 类都创建了 run 方法，它们重写了从 Animal 继承来的 run 方法，使得 run 方法根据不同的类而具有不同的功能。注意，即使 tom 被声明为 Animal 类型，但因为它的值是 Horse，调用 tom.run(34) 时，它会调用 Horse 里重写的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sliding...</span><br><span class="line">sn run 5m</span><br><span class="line">dashing...</span><br><span class="line">ho run 50m</span><br></pre></td></tr></table></figure>
<h4 id="公共，私有与受保护的修饰符"><a href="#公共，私有与受保护的修饰符" class="headerlink" title="公共，私有与受保护的修饰符"></a>公共，私有与受保护的修饰符</h4><p><strong>默认为 public</strong><br>在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用 public 来做修饰；例如，C# 要求必须明确地使用 public 指定成员是可见的。 在 TypeScript 里，成员都默认为 public。</p>
<p>你也可以明确的将一个成员标记成 public。 我们可以用下面的方式来重写上面的 Animal 类：</p>
<p><strong>理解 private</strong><br>当成员被标记成 private 时，它就不能在声明它的类的外部访问。</p>
<p><strong>理解 protected</strong><br>protected 修饰符与 private 修饰符的行为很相似，但有一点不同，protected成员在派生类中仍然可以访问。例如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">访问修饰符: 用来描述类内部的属性/方法的可访问性</span></span><br><span class="line"><span class="comment">  public: 默认值, 公开的外部也可以访问</span></span><br><span class="line"><span class="comment">  private: 只能类内部可以访问</span></span><br><span class="line"><span class="comment">  protected: 类内部和子类可以访问</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">constructor</span> (<span class="attr">name</span>: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> run (<span class="attr">distance</span>: <span class="built_in">number</span>=<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> run <span class="subst">$&#123;distance&#125;</span>m`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">18</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">sex</span>: <span class="built_in">string</span> = <span class="string">&#x27;男&#x27;</span></span><br><span class="line"></span><br><span class="line">  run (<span class="attr">distance</span>: <span class="built_in">number</span>=<span class="number">5</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Person jumping...&#x27;</span>)</span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">run</span>(distance)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  run (<span class="attr">distance</span>: <span class="built_in">number</span>=<span class="number">6</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Student jumping...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">sex</span>) <span class="comment">// 子类能看到父类中受保护的成员</span></span><br><span class="line">    <span class="comment">// console.log(this.age) //  子类看不到父类中私有的成员</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">super</span>.<span class="title function_">run</span>(distance)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;abc&#x27;</span>).<span class="property">name</span>) <span class="comment">// 公开的可见</span></span><br><span class="line"><span class="comment">// console.log(new Person(&#x27;abc&#x27;).sex) // 受保护的不可见</span></span><br><span class="line"><span class="comment">// console.log(new Person(&#x27;abc&#x27;).age) //  私有的不可见</span></span><br></pre></td></tr></table></figure>
<h4 id="readonly-修饰符"><a href="#readonly-修饰符" class="headerlink" title="readonly 修饰符"></a>readonly 修饰符</h4><p>你可以使用 readonly 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> john = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;John&#x27;</span>)</span><br><span class="line"><span class="comment">// john.name = &#x27;peter&#x27; // error</span></span><br></pre></td></tr></table></figure>
<p><strong>参数属性</strong><br>在上面的例子中，我们必须在 Person 类里定义一个只读成员 name 和一个参数为 name 的构造函数，并且立刻将 name 的值赋给 this.name，这种情况经常会遇到。 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 Person 类的修改版，使用了参数属性：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">readonly</span> name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person2</span>(<span class="string">&#x27;jack&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>)</span><br></pre></td></tr></table></figure>
<p>注意看我们是如何舍弃参数 name，仅在构造函数里使用 readonly name: string 参数来创建和初始化 name 成员。 我们把声明和赋值合并至一处。</p>
<p>参数属性通过给构造函数参数前面添加一个访问限定符来声明。使用 private 限定一个参数属性会声明并初始化一个私有成员；对于 public 和 protected 来说也是一样。</p>
<h4 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h4><p>TypeScript 支持通过 getters&#x2F;setters 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</p>
<p>下面来看如何把一个简单的类改写成使用 get 和 set。 首先，我们从一个没有使用存取器的例子开始。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="built_in">string</span> = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">  <span class="attr">lastName</span>: <span class="built_in">string</span> = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">  get fullName () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span></span><br><span class="line">  &#125;</span><br><span class="line">  set fullName (value) &#123;</span><br><span class="line">    <span class="keyword">const</span> names = value.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstName</span> = names[<span class="number">0</span>]</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lastName</span> = names[<span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">fullName</span>)</span><br><span class="line"></span><br><span class="line">p.<span class="property">firstName</span> = <span class="string">&#x27;C&#x27;</span></span><br><span class="line">p.<span class="property">lastName</span> =  <span class="string">&#x27;D&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">fullName</span>)</span><br><span class="line"></span><br><span class="line">p.<span class="property">fullName</span> = <span class="string">&#x27;E-F&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">firstName</span>, p.<span class="property">lastName</span>)</span><br></pre></td></tr></table></figure>
<h4 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h4><p>到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用 static 定义 origin，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在 origin 前面加上类名。 如同在实例属性上使用 this.xxx 来访问属性一样，这里我们使用 Grid.xxx 来访问静态属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">静态属性, 是类对象的属性</span></span><br><span class="line"><span class="comment">非静态属性, 是类的实例对象的属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name1</span>: <span class="built_in">string</span> = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="attr">name2</span>: <span class="built_in">string</span> = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">name2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Person</span>().<span class="property">name1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>抽象类做为其它派生类的基类使用。 它们不能被实例化。不同于接口，抽象类可以包含成员的实现细节。 abstract 关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">抽象类</span></span><br><span class="line"><span class="comment">  不能创建实例对象, 只有实现类才能创建实例</span></span><br><span class="line"><span class="comment">  可以包含未实现的抽象方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> cry ()</span><br><span class="line"></span><br><span class="line">  run () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;run()&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  cry () &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27; Dog cry()&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>()</span><br><span class="line">dog.<span class="title function_">cry</span>()</span><br><span class="line">dog.<span class="title function_">run</span>()</span><br></pre></td></tr></table></figure>
<h3 id="2-4-函数"><a href="#2-4-函数" class="headerlink" title="2.4 函数"></a>2.4 函数</h3><p>函数是 JavaScript 应用程序的基础，它帮助你实现抽象层，模拟类，信息隐藏和模块。在 TypeScript 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义行为的地方。TypeScript 为 JavaScript 函数添加了额外的功能，让我们可以更容易地使用。</p>
<h4 id="基本示例-1"><a href="#基本示例-1" class="headerlink" title="基本示例"></a>基本示例</h4><p>和 JavaScript 一样，TypeScript 函数可以创建有名字的函数和匿名函数。你可以随意选择适合应用程序的方式，不论是定义一系列 API 函数还是只使用一次的函数。</p>
<p>通过下面的例子可以迅速回想起这两种 JavaScript 中的函数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命名函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数类型-1"><a href="#函数类型-1" class="headerlink" title="函数类型"></a>函数类型</h4><p><strong>为函数定义类型</strong><br>让我们为上面那个函数添加类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123; </span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以给每个参数添加类型之后再为函数本身添加返回值类型。TypeScript 能够根据返回语句自动推断出返回值类型。<br><strong>书写完整函数类型</strong><br>现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myAdd2</span>: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = </span><br><span class="line"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可选参数和默认参数</strong><br>TypeScript 里的每个函数参数都是必须的。 这不是指不能传递 null 或 undefined 作为参数，而是说编译器检查用户是否为每个参数都传入了值。编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。</p>
<p>JavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 undefined。 在TypeScript 里我们可以在参数名旁使用 ? 实现可选参数的功能。 比如，我们想让 lastName 是可选的：</p>
<p>在 TypeScript 里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是 undefined 时。 它们叫做有默认初始化值的参数。 让我们修改上例，把firstName 的默认值设置为 “A”。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>=<span class="string">&#x27;A&#x27;</span>, lastName?: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (lastName) &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">&#x27;-&#x27;</span> + lastName</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">buildName</span>(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">buildName</span>(<span class="string">&#x27;C&#x27;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">buildName</span>())</span><br></pre></td></tr></table></figure>
<p><strong>剩余参数</strong><br>必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在 JavaScript 里，你可以使用 arguments 来访问所有传入的参数。</p>
<p>在 TypeScript 里，你可以把所有参数收集到一个变量里：<br>剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（ …）后面给定的名字，你可以在函数体内使用这个数组。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">info</span>(<span class="params">x: <span class="built_in">string</span>, ...args: <span class="built_in">string</span>[]</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x, args)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">info</span>(<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>函数重载</strong><br>函数重载: 函数名相同, 而形参不同的多个函数<br>在JS中, 由于弱类型的特点和形参与实参可以不匹配, 是没有函数重载这一说的<br>但在TS中, 与其它面向对象的语言(如Java)就存在此语法</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">函数重载: 函数名相同, 而形参不同的多个函数</span></span><br><span class="line"><span class="comment">需求: 我们有一个add函数，它可以接收2个string类型的参数进行拼接，也可以接收2个number类型的参数进行相加 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载函数声明</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (<span class="attr">x</span>: <span class="built_in">string</span>, <span class="attr">y</span>: <span class="built_in">string</span>): <span class="built_in">string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span> (<span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数实现</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x: <span class="built_in">string</span> | <span class="built_in">number</span>, y: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="built_in">string</span> | <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="comment">// 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 x + y</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> y === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> y === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>))</span><br><span class="line"><span class="comment">// console.log(add(1, &#x27;a&#x27;)) // error</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-泛型"><a href="#2-5-泛型" class="headerlink" title="2.5 泛型"></a>2.5 泛型</h3><p>指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定具体类型的一种特性。</p>
<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>下面创建一个函数, 实现功能: 根据指定的数量 count 和数据 value , 创建一个包含 count 个 value 的数组<br>不用泛型的话，这个函数可能是下面这样：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createArray</span>(<span class="params">value: <span class="built_in">any</span>, count: <span class="built_in">number</span></span>): <span class="built_in">any</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">arr</span>: <span class="built_in">any</span>[] = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; count; index++) &#123;</span><br><span class="line">    arr.<span class="title function_">push</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr1 = <span class="title function_">createArray</span>(<span class="number">11</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">const</span> arr2 = <span class="title function_">createArray</span>(<span class="string">&#x27;aa&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1[<span class="number">0</span>].<span class="title function_">toFixed</span>(), arr2[<span class="number">0</span>].<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h4 id="使用函数泛型"><a href="#使用函数泛型" class="headerlink" title="使用函数泛型"></a>使用函数泛型</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> createArray2 &lt;T&gt; (<span class="attr">value</span>: T, <span class="attr">count</span>: <span class="built_in">number</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">arr</span>: <span class="title class_">Array</span>&lt;T&gt; = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; count; index++) &#123;</span><br><span class="line">    arr.<span class="title function_">push</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arr3 = createArray2&lt;<span class="built_in">number</span>&gt;(<span class="number">11</span>, <span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr3[<span class="number">0</span>].<span class="title function_">toFixed</span>())</span><br><span class="line"><span class="comment">// console.log(arr3[0].split(&#x27;&#x27;)) // error</span></span><br><span class="line"><span class="keyword">const</span> arr4 = createArray2&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;aa&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr4[<span class="number">0</span>].<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line"><span class="comment">// console.log(arr4[0].toFixed()) // error</span></span><br></pre></td></tr></table></figure>
<h4 id="多个泛型参数的函数"><a href="#多个泛型参数的函数" class="headerlink" title="多个泛型参数的函数"></a>多个泛型参数的函数</h4><p>一个函数可以定义多个泛型参数</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> swap &lt;K, V&gt; (<span class="attr">a</span>: K, <span class="attr">b</span>: V): [K, V] &#123;</span><br><span class="line">  <span class="keyword">return</span> [a, b]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = swap&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;(<span class="string">&#x27;abc&#x27;</span>, <span class="number">123</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result[<span class="number">0</span>].<span class="property">length</span>, result[<span class="number">1</span>].<span class="title function_">toFixed</span>())</span><br></pre></td></tr></table></figure>
<h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>在定义接口时, 为接口中的属性或方法定义泛型类型<br>在使用接口时, 再指定具体的泛型类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IbaseCRUD</span> &lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">data</span>: T[]</span><br><span class="line">  <span class="attr">add</span>: <span class="function">(<span class="params">t: T</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  <span class="attr">getById</span>: <span class="function">(<span class="params">id: <span class="built_in">number</span></span>) =&gt;</span> T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  id?: <span class="built_in">number</span>; <span class="comment">//id主键自增</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>; <span class="comment">//姓名</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>; <span class="comment">//年龄</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> (name, age) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserCRUD</span> <span class="keyword">implements</span> <span class="title class_">IbaseCRUD</span> &lt;<span class="title class_">User</span>&gt; &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="title class_">User</span>[] = []</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">add</span>(<span class="attr">user</span>: <span class="title class_">User</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    user = &#123;...user, <span class="attr">id</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>()&#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">push</span>(user)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;保存user&#x27;</span>, user.<span class="property">id</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getById</span>(<span class="attr">id</span>: <span class="built_in">number</span>): <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">id</span>===id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userCRUD = <span class="keyword">new</span> <span class="title class_">UserCRUD</span>()</span><br><span class="line">userCRUD.<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&#x27;tom&#x27;</span>, <span class="number">12</span>))</span><br><span class="line">userCRUD.<span class="title function_">add</span>(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&#x27;tom2&#x27;</span>, <span class="number">13</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userCRUD.<span class="property">data</span>)</span><br></pre></td></tr></table></figure>
<h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><p>在定义类时, 为类中的属性或方法定义泛型类型<br>在创建类的实例时, 再指定特定的泛型类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericNumber</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">zeroValue</span>: T</span><br><span class="line">  <span class="attr">add</span>: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> <span class="title class_">GenericNumber</span>&lt;<span class="built_in">number</span>&gt;()</span><br><span class="line">myGenericNumber.<span class="property">zeroValue</span> = <span class="number">0</span></span><br><span class="line">myGenericNumber.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericString = <span class="keyword">new</span> <span class="title class_">GenericNumber</span>&lt;<span class="built_in">string</span>&gt;()</span><br><span class="line">myGenericString.<span class="property">zeroValue</span> = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">myGenericString.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myGenericString.<span class="title function_">add</span>(myGenericString.<span class="property">zeroValue</span>, <span class="string">&#x27;test&#x27;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myGenericNumber.<span class="title function_">add</span>(myGenericNumber.<span class="property">zeroValue</span>, <span class="number">12</span>))</span><br></pre></td></tr></table></figure>
<h4 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h4><p>如果我们直接对一个泛型参数取 length 属性, 会报错, 因为这个泛型根本就不知道它有这个属性</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有泛型约束</span></span><br><span class="line"><span class="keyword">function</span> fn &lt;T&gt;(<span class="attr">x</span>: T): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="comment">// console.log(x.length)  // error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用泛型约束来实现</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Lengthwise</span> &#123;</span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定泛型约束</span></span><br><span class="line"><span class="keyword">function</span> fn2 &lt;T <span class="keyword">extends</span> <span class="title class_">Lengthwise</span>&gt;(<span class="attr">x</span>: T): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="property">length</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要传入符合约束类型的值，必须包含必须 length 属性：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fn2</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="comment">// fn2(123) // error  number没有length属性</span></span><br></pre></td></tr></table></figure>

<h3 id="2-6-其它"><a href="#2-6-其它" class="headerlink" title="2.6 其它"></a>2.6 其它</h3><h4 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h4><p>当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能</p>
<p>什么是声明语句</p>
<p>假如我们想使用第三方库 jQuery，一种常见的方式是在 html 中通过</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span> 标签引入 jQuery，然后就可以使用全局变量 $ 或 jQuery 了。</span><br></pre></td></tr></table></figure>
<p>但是在 ts 中，编译器并不知道 $ 或 jQuery 是什么东西</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。</span></span><br><span class="line"><span class="comment">声明语句: 如果需要ts对新的语法进行检查, 需要要加载了对应的类型说明代码</span></span><br><span class="line"><span class="comment">  declare var jQuery: (selector: string) =&gt; any;</span></span><br><span class="line"><span class="comment">声明文件: 把声明语句放到一个单独的文件（jQuery.d.ts）中, ts会自动解析到项目中所有声明文件</span></span><br><span class="line"><span class="comment">下载声明文件: npm install @types/jquery --save-dev</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">jQuery</span>(<span class="string">&#x27;#foo&#x27;</span>);</span><br><span class="line"><span class="comment">// ERROR: Cannot find name &#x27;jQuery&#x27;.</span></span><br></pre></td></tr></table></figure>
<p>这时，我们需要使用 declare var 来定义它的类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="attr">jQuery</span>: <span class="function">(<span class="params">selector: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">jQuery</span>(<span class="string">&#x27;#foo&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>declare var 并没有真的定义一个变量，只是定义了全局变量 jQuery 的类型，仅仅会用于编译时的检查，在编译结果中会被删除。它编译结果是：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">jQuery</span>(<span class="string">&#x27;#foo&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>一般声明文件都会单独写成一个 xxx.d.ts 文件</p>
<p>创建 01_jQuery.d.ts, 将声明语句定义其中, TS编译器会扫描并加载项目中所有的TS声明文件</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> <span class="attr">jQuery</span>: <span class="function">(<span class="params">selector: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure>
<p>很多的第三方库都定义了对应的声明文件库, 库文件名一般为 @types&#x2F;xxx, 可以在 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/package">https://www.npmjs.com/package/package</a> 进行搜索</p>
<p>有的第三库在下载时就会自动下载对应的声明文件库(比如: webpack),有的可能需要单独下载(比如jQuery&#x2F;react)</p>
<h4 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h4><p>JavaScript 中有很多内置对象，它们可以直接在 TypeScript 中当做定义好了的类型。</p>
<p>内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。</p>
<ol>
<li>ECMAScript 的内置对象</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Boolean</span><br><span class="line">Number</span><br><span class="line">String</span><br><span class="line">Date</span><br><span class="line">RegExp</span><br><span class="line">Error</span><br></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1. ECMAScript 的内置对象 */</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>: <span class="title class_">Boolean</span> = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="attr">n</span>: <span class="title class_">Number</span> = <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="attr">s</span>: <span class="title class_">String</span> = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="attr">d</span>: <span class="title class_">Date</span> = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line"><span class="keyword">let</span> <span class="attr">r</span>: <span class="title class_">RegExp</span> = <span class="regexp">/^1/</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">e</span>: <span class="title class_">Error</span> = <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;error message&#x27;</span>)</span><br><span class="line">b = <span class="literal">true</span></span><br><span class="line"><span class="comment">// let bb: boolean = new Boolean(2)  // error</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>BOM 和 DOM 的内置对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Window</span><br><span class="line">Document</span><br><span class="line">HTMLElement</span><br><span class="line">DocumentFragment</span><br><span class="line">Event</span><br><span class="line">NodeList</span><br></pre></td></tr></table></figure>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">div</span>: <span class="title class_">HTMLElement</span> = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="attr">divs</span>: <span class="title class_">NodeList</span> = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">event: MouseEvent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">dir</span>(event.<span class="property">target</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> <span class="attr">fragment</span>: <span class="title class_">DocumentFragment</span> = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>()</span><br></pre></td></tr></table></figure></li>
</ol>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/userimg.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/userimg.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">苏惜</div><div class="post-copyright__author_desc">生活明朗，万物可爱，美好生活，就是现在！</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2023/08/06/Vue3+TS%E7%AC%AC%E4%B8%80%E7%AB%A0/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2023/08/06/Vue3+TS%E7%AC%AC%E4%B8%80%E7%AB%A0/')">Vue3+TypeScript (第一章：TS篇)</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/img/wxewm.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/wxewm.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/zfbewm.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/zfbewm.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2023/08/06/Vue3+TS%E7%AC%AC%E4%B8%80%E7%AB%A0/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Vue3+TypeScript (第一章：TS篇)&amp;url=http://example.com/2023/08/06/Vue3+TS%E7%AC%AC%E4%B8%80%E7%AB%A0/&amp;pic=/img/default_cover.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">苏惜的小世界</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div></div><div class="post_share"><div class="social-share" data-image="/img/default_cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/08/15/Vue3+TS%E7%AC%AC%E4%BA%8C%E7%AB%A0/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/default_cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Vue3+TypeScript (第二章：Vue3篇)</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/userimg.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/states.png" ait="status"/></div></div><div class="author-info__description"></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">苏惜</h1><div class="author-info__desc">生活明朗，万物可爱，美好生活，就是现在！</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/suxi0212/suxi0212.github.io" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(/img/gzh.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81TypeScript%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B"><span class="toc-number">1.</span> <span class="toc-text">1、TypeScript快速上手</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%88%9D%E8%AF%86-TypeScript"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 初识 TypeScript</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TypeScript-%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.1.</span> <span class="toc-text">TypeScript 的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TypeScript-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.2.</span> <span class="toc-text">TypeScript 的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%AE%89%E8%A3%85-TypeScript"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 安装 TypeScript</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E7%AC%AC%E4%B8%80%E4%B8%AA-TypeScript-%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.3.</span> <span class="toc-text">1.3. 第一个 TypeScript 程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99-TS-%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">编写 TS 程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81"><span class="toc-number">1.3.2.</span> <span class="toc-text">手动编译代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#VsCode%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91"><span class="toc-number">1.3.3.</span> <span class="toc-text">VsCode自动编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.3.4.</span> <span class="toc-text">类型注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.5.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">1.3.6.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.3.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8webpack%E6%89%93%E5%8C%85TS"><span class="toc-number">1.4.</span> <span class="toc-text">使用webpack打包TS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E4%BE%9D%E8%B5%96"><span class="toc-number">1.4.1.</span> <span class="toc-text">下载依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E5%8F%A3JS-src-main-ts"><span class="toc-number">1.4.2.</span> <span class="toc-text">入口JS: src&#x2F;main.ts</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#index%E9%A1%B5%E9%9D%A2-public-index-html"><span class="toc-number">1.4.3.</span> <span class="toc-text">index页面: public&#x2F;index.html</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#build-webpack-config-js"><span class="toc-number">1.4.4.</span> <span class="toc-text">build&#x2F;webpack.config.js</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%89%93%E5%8C%85%E5%91%BD%E4%BB%A4"><span class="toc-number">1.4.5.</span> <span class="toc-text">配置打包命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E4%B8%8E%E6%89%93%E5%8C%85"><span class="toc-number">1.4.6.</span> <span class="toc-text">运行与打包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81TypeScript%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">2、TypeScript常用语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 基础类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E5%80%BC"><span class="toc-number">2.1.1.</span> <span class="toc-text">布尔值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97"><span class="toc-number">2.1.2.</span> <span class="toc-text">数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.1.3.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undefined-%E5%92%8C-null"><span class="toc-number">2.1.4.</span> <span class="toc-text">undefined 和 null</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">2.1.5.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%BB%84-Tuple"><span class="toc-number">2.1.6.</span> <span class="toc-text">元组 Tuple</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">2.1.7.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#any"><span class="toc-number">2.1.8.</span> <span class="toc-text">any</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#void"><span class="toc-number">2.1.9.</span> <span class="toc-text">void</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#object"><span class="toc-number">2.1.10.</span> <span class="toc-text">object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.11.</span> <span class="toc-text">联合类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">2.1.12.</span> <span class="toc-text">类型断言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">2.1.13.</span> <span class="toc-text">类型推断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%88%9D%E6%8E%A2"><span class="toc-number">2.2.1.</span> <span class="toc-text">接口初探</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7"><span class="toc-number">2.2.2.</span> <span class="toc-text">可选属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">2.2.3.</span> <span class="toc-text">只读属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.4.</span> <span class="toc-text">函数类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.5.</span> <span class="toc-text">类类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.2.6.</span> <span class="toc-text">一个类可以实现多个接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.2.7.</span> <span class="toc-text">接口继承接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%B1%BB"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.3.1.</span> <span class="toc-text">基本示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">2.3.2.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%85%B1%EF%BC%8C%E7%A7%81%E6%9C%89%E4%B8%8E%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">2.3.3.</span> <span class="toc-text">公共，私有与受保护的修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#readonly-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">2.3.4.</span> <span class="toc-text">readonly 修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%8F%96%E5%99%A8"><span class="toc-number">2.3.5.</span> <span class="toc-text">存取器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7"><span class="toc-number">2.3.6.</span> <span class="toc-text">静态属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">2.3.7.</span> <span class="toc-text">抽象类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">2.4.1.</span> <span class="toc-text">基本示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B-1"><span class="toc-number">2.4.2.</span> <span class="toc-text">函数类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E6%B3%9B%E5%9E%8B"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5"><span class="toc-number">2.5.1.</span> <span class="toc-text">引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%B3%9B%E5%9E%8B"><span class="toc-number">2.5.2.</span> <span class="toc-text">使用函数泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.3.</span> <span class="toc-text">多个泛型参数的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.5.4.</span> <span class="toc-text">泛型接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">2.5.5.</span> <span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">2.5.6.</span> <span class="toc-text">泛型约束</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E5%85%B6%E5%AE%83"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 其它</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%96%87%E4%BB%B6"><span class="toc-number">2.6.1.</span> <span class="toc-text">声明文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.6.2.</span> <span class="toc-text">内置对象</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/20/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="web前端面试题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/default_cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="web前端面试题"/></a><div class="content"><a class="title" href="/2023/08/20/%E9%9D%A2%E8%AF%95%E9%A2%98/" title="web前端面试题">web前端面试题</a><time datetime="2023-08-20T09:30:24.000Z" title="发表于 2023-08-20 17:30:24">2023-08-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/15/Vue3+TS%E7%AC%AC%E4%BA%8C%E7%AB%A0/" title="Vue3+TypeScript (第二章：Vue3篇)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/default_cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue3+TypeScript (第二章：Vue3篇)"/></a><div class="content"><a class="title" href="/2023/08/15/Vue3+TS%E7%AC%AC%E4%BA%8C%E7%AB%A0/" title="Vue3+TypeScript (第二章：Vue3篇)">Vue3+TypeScript (第二章：Vue3篇)</a><time datetime="2023-08-15T02:45:02.000Z" title="发表于 2023-08-15 10:45:02">2023-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/06/Vue3+TS%E7%AC%AC%E4%B8%80%E7%AB%A0/" title="Vue3+TypeScript (第一章：TS篇)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/default_cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue3+TypeScript (第一章：TS篇)"/></a><div class="content"><a class="title" href="/2023/08/06/Vue3+TS%E7%AC%AC%E4%B8%80%E7%AB%A0/" title="Vue3+TypeScript (第一章：TS篇)">Vue3+TypeScript (第一章：TS篇)</a><time datetime="2023-08-06T04:02:36.000Z" title="发表于 2023-08-06 12:02:36">2023-08-06</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2023 By <a class="footer-bar-link" href="/" title="苏惜" target="_blank">苏惜</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://suxi.org.edu.kg" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/states.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">音乐盒</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://suxi.org.edu.kg/music/?id=8152657892&amp;server=netease" title="苏惜的音乐盒"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/userimg.jpg" alt="苏惜的音乐盒"/><span class="back-menu-item-text">苏惜的音乐盒</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 文章总览</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=8152657892&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152657892" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://music.163.com/#/my/m/music/playlist?id=8152657892&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用!`,
    `生活明朗, 万物可爱`,
    `
     我是唐世闯欢迎来到我的博客世界！   
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By  V1.6.4",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by  %c 你正在访问 苏惜 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="archives"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script src="/js/xxx"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>